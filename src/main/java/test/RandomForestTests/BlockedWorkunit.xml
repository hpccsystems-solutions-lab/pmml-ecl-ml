<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet href="../esp/xslt/xmlformatter.xsl" type="text/xsl"?><W20210629-061748 agentSession='4294993060'
                                                                                                                              buildVersion='community_8.0.2-1'
                                                                                                                              cloneable='1'
                                                                                                                              clusterName='thor'
                                                                                                                              codeVersion='652'
                                                                                                                              eclVersion='BUILD_VERSION_MAJOR.BUILD_VERSION_MINOR.BUILD_VERSION_POINT'
                                                                                                                              hash='2244056846'
                                                                                                                              isClone='0'
                                                                                                                              jobName='tmp_exec'
                                                                                                                              scope='aparra'
                                                                                                                              state='blocked'
                                                                                                                              submitID='aparra'
                                                                                                                              wuidVersion='2'
                                                                                                                              xmlns:xsi='http://www.w3.org/1999/XMLSchema-instance'> <Action>compile</Action>
    <Debug>
        <allowvariableroxiefilenames>1</allowvariableroxiefilenames>
        <created_by>ws_workunits</created_by>
        <created_for>aparra</created_for>
        <eclcc_compiler_version>8.0.14</eclcc_compiler_version>
        <expandpersistinputdependencies>1</expandpersistinputdependencies>
        <maxcompilethreads>2</maxcompilethreads>
        <passdfstoeclcc>1</passdfstoeclcc>
        <targetclustertype>thorlcr</targetclustertype>
    </Debug>
    <Exceptions>
        <Exception code="2007"
                   col="37"
                   filename="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl"
                   row="75"
                   sequence="0"
                   severity="1"
                   source="eclcc"
                   time="2021-06-29T06:17:49Z">
            Incompatible types for rmVal: should cast Integer to a Boolean
        </Exception>
    </Exceptions>
    <Graphs>
        <Graph name="graph1" type="activities" wfid="1">
            <xgmml>
                <graph wfid="1">
                    <edge id="17_19" source="1" target="18">
                        <att name="_sourceActivity" value="17"/>
                        <att name="_targetActivity" value="19"/>
                    </edge>
                    <edge id="27_29" source="18" target="28">
                        <att name="_sourceActivity" value="27"/>
                        <att name="_targetActivity" value="29"/>
                    </edge>
                    <edge id="27_36" source="18" target="35">
                        <att name="_sourceActivity" value="27"/>
                        <att name="_targetActivity" value="36"/>
                    </edge>
                    <edge id="11_43" source="1" target="35">
                        <att name="_sourceActivity" value="11"/>
                        <att name="_targetActivity" value="43"/>
                    </edge>
                    <edge id="47_53" source="35" target="52">
                        <att name="_sourceActivity" value="47"/>
                        <att name="_targetActivity" value="53"/>
                    </edge>
                    <edge id="47_56" source="35" target="52">
                        <att name="_sourceActivity" value="47"/>
                        <att name="_targetActivity" value="56"/>
                    </edge>
                    <edge id="49_60" source="35" target="52">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="49"/>
                        <att name="_targetActivity" value="60"/>
                    </edge>
                    <edge id="11_66" source="1" target="65">
                        <att name="_sourceActivity" value="11"/>
                        <att name="_targetActivity" value="66"/>
                    </edge>
                    <edge id="63_73" source="52" target="72">
                        <att name="_sourceActivity" value="63"/>
                        <att name="_targetActivity" value="73"/>
                    </edge>
                    <edge id="71_75" source="65" target="72">
                        <att name="_sourceActivity" value="71"/>
                        <att name="_targetActivity" value="75"/>
                    </edge>
                    <edge id="11_76" source="1" target="72">
                        <att name="_sourceActivity" value="11"/>
                        <att name="_targetActivity" value="76"/>
                    </edge>
                    <edge id="51_77" source="35" target="72">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="51"/>
                        <att name="_targetActivity" value="77"/>
                    </edge>
                    <edge id="34_86" source="28" target="85">
                        <att name="_sourceActivity" value="34"/>
                        <att name="_targetActivity" value="86"/>
                    </edge>
                    <edge id="27_87" source="18" target="85">
                        <att name="_sourceActivity" value="27"/>
                        <att name="_targetActivity" value="87"/>
                    </edge>
                    <edge id="51_88" source="35" target="85">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="51"/>
                        <att name="_targetActivity" value="88"/>
                    </edge>
                    <edge id="15_103" source="1" target="102">
                        <att name="_sourceActivity" value="15"/>
                        <att name="_targetActivity" value="103"/>
                    </edge>
                    <edge id="108_110" source="102" target="109">
                        <att name="_sourceActivity" value="108"/>
                        <att name="_targetActivity" value="110"/>
                    </edge>
                    <edge id="47_111" source="35" target="109">
                        <att name="_sourceActivity" value="47"/>
                        <att name="_targetActivity" value="111"/>
                    </edge>
                    <edge id="84_115" source="72" target="114">
                        <att name="_sourceActivity" value="84"/>
                        <att name="_targetActivity" value="115"/>
                    </edge>
                    <edge id="83_116" source="72" target="114">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="83"/>
                        <att name="_targetActivity" value="116"/>
                    </edge>
                    <edge id="137_142" source="118" target="141">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="137"/>
                        <att name="_targetActivity" value="142"/>
                    </edge>
                    <edge id="47_144" source="35" target="141">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="47"/>
                        <att name="_targetActivity" value="144"/>
                    </edge>
                    <edge id="153_155" source="141" target="154">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="153"/>
                        <att name="_targetActivity" value="155"/>
                    </edge>
                    <edge id="97_156" source="85" target="154">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="97"/>
                        <att name="_targetActivity" value="156"/>
                    </edge>
                    <edge id="137_160" source="118" target="159">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="137"/>
                        <att name="_targetActivity" value="160"/>
                    </edge>
                    <edge id="158_161" source="154" target="159">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="158"/>
                        <att name="_targetActivity" value="161"/>
                    </edge>
                    <edge id="153_162" source="141" target="159">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="153"/>
                        <att name="_targetActivity" value="162"/>
                    </edge>
                    <edge id="101_163" source="85" target="159">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="101"/>
                        <att name="_targetActivity" value="163"/>
                    </edge>
                    <edge id="42_163" source="35" target="159">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="42"/>
                        <att name="_targetActivity" value="163"/>
                    </edge>
                    <edge id="167_169" source="159" target="168">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="167"/>
                        <att name="_targetActivity" value="169"/>
                    </edge>
                    <edge id="172_174" source="168" target="173">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="172"/>
                        <att name="_targetActivity" value="174"/>
                    </edge>
                    <edge id="90_175" source="85" target="173">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="90"/>
                        <att name="_targetActivity" value="175"/>
                    </edge>
                    <edge id="178_180" source="173" target="179">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="178"/>
                        <att name="_targetActivity" value="180"/>
                    </edge>
                    <edge id="178_186" source="173" target="185">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="178"/>
                        <att name="_targetActivity" value="186"/>
                    </edge>
                    <edge id="184_187" source="179" target="185">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="184"/>
                        <att name="_targetActivity" value="187"/>
                    </edge>
                    <edge id="184_190" source="179" target="185">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="184"/>
                        <att name="_targetActivity" value="190"/>
                    </edge>
                    <edge id="198_201" source="185" target="200">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="198"/>
                        <att name="_targetActivity" value="201"/>
                    </edge>
                    <edge id="205_207" source="200" target="206">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="205"/>
                        <att name="_targetActivity" value="207"/>
                    </edge>
                    <edge id="205_208" source="200" target="206">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="205"/>
                        <att name="_targetActivity" value="208"/>
                    </edge>
                    <edge id="139_221" source="118" target="206">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="139"/>
                        <att name="_targetActivity" value="221"/>
                    </edge>
                    <edge id="99_223" source="85" target="206">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="99"/>
                        <att name="_targetActivity" value="223"/>
                    </edge>
                    <edge id="199_224" source="185" target="206">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="199"/>
                        <att name="_targetActivity" value="224"/>
                    </edge>
                    <edge id="178_230" source="173" target="229">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="178"/>
                        <att name="_targetActivity" value="230"/>
                    </edge>
                    <edge id="228_231" source="206" target="229">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="228"/>
                        <att name="_targetActivity" value="231"/>
                    </edge>
                    <edge id="236_238" source="229" target="237">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="236"/>
                        <att name="_targetActivity" value="238"/>
                    </edge>
                    <edge id="235_239" source="229" target="237">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="235"/>
                        <att name="_targetActivity" value="239"/>
                    </edge>
                    <edge id="235_243" source="229" target="242">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="235"/>
                        <att name="_targetActivity" value="243"/>
                    </edge>
                    <edge id="241_244" source="237" target="242">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="241"/>
                        <att name="_targetActivity" value="244"/>
                    </edge>
                    <edge id="249_251" source="242" target="250">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="249"/>
                        <att name="_targetActivity" value="251"/>
                    </edge>
                    <edge id="249_260" source="242" target="259">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="249"/>
                        <att name="_targetActivity" value="260"/>
                    </edge>
                    <edge id="258_261" source="250" target="259">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="258"/>
                        <att name="_targetActivity" value="261"/>
                    </edge>
                    <edge id="263_265" source="259" target="264">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="263"/>
                        <att name="_targetActivity" value="265"/>
                    </edge>
                    <edge id="140_269" source="118" target="268">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="140"/>
                        <att name="_targetActivity" value="269"/>
                    </edge>
                    <edge id="228_270" source="206" target="268">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="228"/>
                        <att name="_targetActivity" value="270"/>
                    </edge>
                    <edge id="140_275" source="118" target="274">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="140"/>
                        <att name="_targetActivity" value="275"/>
                    </edge>
                    <edge id="138_276" source="118" target="274">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="138"/>
                        <att name="_targetActivity" value="276"/>
                    </edge>
                    <edge id="273_284" source="268" target="274">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="273"/>
                        <att name="_targetActivity" value="284"/>
                    </edge>
                    <edge id="236_287" source="229" target="274">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="236"/>
                        <att name="_targetActivity" value="287"/>
                    </edge>
                    <edge id="267_289" source="264" target="274">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="267"/>
                        <att name="_targetActivity" value="289"/>
                    </edge>
                    <edge id="249_290" source="242" target="274">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="249"/>
                        <att name="_targetActivity" value="290"/>
                    </edge>
                    <edge id="248_291" source="242" target="274">
                        <att name="_dependsOn" value="1"/>
                        <att name="_sourceActivity" value="248"/>
                        <att name="_targetActivity" value="291"/>
                    </edge>
                    <edge id="64_302" source="52" target="114">
                        <att name="_sourceActivity" value="64"/>
                        <att name="_targetActivity" value="302"/>
                    </edge>
                    <edge id="113_303" source="109" target="114">
                        <att name="_sourceActivity" value="113"/>
                        <att name="_targetActivity" value="303"/>
                    </edge>
                    <edge id="307_309" source="114" target="308">
                        <att name="_sourceActivity" value="307"/>
                        <att name="_targetActivity" value="309"/>
                    </edge>
                    <edge id="321_323" source="308" target="322">
                        <att name="_sourceActivity" value="321"/>
                        <att name="_targetActivity" value="323"/>
                    </edge>
                    <edge id="321_330" source="308" target="329">
                        <att name="_sourceActivity" value="321"/>
                        <att name="_targetActivity" value="330"/>
                    </edge>
                    <edge id="328_337" source="322" target="336">
                        <att name="_sourceActivity" value="328"/>
                        <att name="_targetActivity" value="337"/>
                    </edge>
                    <edge id="335_339" source="329" target="336">
                        <att name="_sourceActivity" value="335"/>
                        <att name="_targetActivity" value="339"/>
                    </edge>
                    <node id="1">
                        <att>
                            <graph>
                                <att name="rootGraph" value="1"/>
                                <edge id="2_0" source="2" target="3"/>
                                <edge id="3_0" source="3" target="4"/>
                                <edge id="4_0" source="4" target="5"/>
                                <edge id="5_0" source="5" target="6"/>
                                <edge id="6_0" source="6" target="7"/>
                                <edge id="7_0" source="7" target="8"/>
                                <edge id="8_0" source="8" target="9"/>
                                <edge id="9_0" source="9" target="10"/>
                                <edge id="10_0" source="10" target="11"/>
                                <edge id="6_1" source="6" target="12">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="3_1" source="3" target="13">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="8_1" source="8" target="14">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="14_0" source="14" target="15"/>
                                <edge id="3_2" source="3" target="16">
                                    <att name="_sourceIndex" value="2"/>
                                </edge>
                                <edge id="16_0" source="16" target="17"/>
                                <node id="2" label="Inline Dataset">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(65,1)"/>
                                    <att name="name" value="ds"/>
                                    <att name="_kind" value="148"/>
                                    <att name="ecl" value="DATASET(1000, make_data(LEFT, COUNTER));&#10;"/>
                                    <att name="recordSize" value="40"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="3" label="Split">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(65,7)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="ds;&#10;"/>
                                    <att name="recordSize" value="40"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="4" label="Project">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(75,1)"/>
                                    <att name="name" value="Y"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({ unsigned8 id, integer4 value },SELF.id := LEFT.id;SELF.value := IF(rnd / 1000000.0 &lt;= 0.0, (LEFT.y  +  1) % 2, LEFT.y);));&#10;"/>
                                    <att name="recordSize" value="12"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="5" label="Project">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(82,1)"/>
                                    <att name="name" value="Ye"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({(RECORD&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10; END) integer4 value },...));&#10;"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="6" label="Split">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(82,7)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="Ye;&#10;"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="7" label="Project">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl(46,7)"/>
                                    <att name="name" value="dsOut"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({ unsigned2 wi, unsigned8 id, real8 value },SELF.wi := LEFT.wi;SELF.id := LEFT.id;...));&#10;"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="8" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl(46,16)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="dsOut;&#10;"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="9" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(146,3)"/>
                                    <att name="name" value="YD"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="10" label="Local Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(148,3)"/>
                                    <att name="name" value="YSD"/>
                                    <att name="_kind" value="3"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="SORT(wi, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="11" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::6&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="_fileName" value="~spill::6"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                                <node id="12" label="Output&#10;&apos;Y_train&apos;">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(84,1)"/>
                                    <att name="_kind" value="16"/>
                                    <att name="ecl" value="OUTPUT(..., , named(&apos;Y_train&apos;), workunit);&#10;"/>
                                    <att name="recordSize" value="18"/>
                                </node>
                                <node id="13" label="Output&#10;&apos;TrainingData&apos;">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(66,1)"/>
                                    <att name="_kind" value="16"/>
                                    <att name="ecl" value="OUTPUT(..., , named(&apos;TrainingData&apos;), workunit);&#10;"/>
                                    <att name="recordSize" value="40"/>
                                </node>
                                <node id="14" label="Project">
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({ unsigned2 wi, real8 value },SELF.wi := LEFT.wi;SELF.value := LEFT.value;));&#10;"/>
                                    <att name="recordSize" value="10"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="15" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::5&apos;, __compressed__);&#10;"/>
                                    <att name="recordSize" value="10"/>
                                    <att name="_fileName" value="~spill::5"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                                <node id="16" label="Project">
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned8 id;&#10;  real8 x1;&#10;  unsigned8 x2;&#10;  unsigned8 x3;&#10; END,...));&#10;"/>
                                    <att name="recordSize" value="32"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="17" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::4&apos;, __compressed__);&#10;"/>
                                    <att name="recordSize" value="32"/>
                                    <att name="_fileName" value="~spill::4"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="18">
                        <att>
                            <graph>
                                <edge id="19_0" source="19" target="20"/>
                                <edge id="20_0" source="20" target="21"/>
                                <edge id="20_1" source="20" target="22">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="20_2" source="20" target="23">
                                    <att name="_sourceIndex" value="2"/>
                                </edge>
                                <edge id="21_0" source="21" target="24"/>
                                <edge id="22_0" source="22" target="24">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="23_0" source="23" target="24">
                                    <att name="_targetIndex" value="2"/>
                                </edge>
                                <edge id="24_0" source="24" target="25"/>
                                <edge id="25_0" source="25" target="26"/>
                                <edge id="26_0" source="26" target="27"/>
                                <node id="19" label="Spill Read">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(65,1)"/>
                                    <att name="name" value="ds"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::4&apos;, RECORD&#10;  unsigned8 id;&#10;  real8 x1;&#10;  unsigned8 x2;&#10;  unsigned8 x3;&#10; END, THOR, __compressed__);&#10;"/>
                                    <att name="recordSize" value="32"/>
                                    <att name="predictedCount" value="1000"/>
                                    <att name="_fileName" value="~spill::4"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="20" label="Split">
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="ds;&#10;"/>
                                    <att name="recordSize" value="32"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="21" label="Project">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(68,1)"/>
                                    <att name="name" value="X1"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.isordinal := true;SELF.wi := 1;...));&#10;"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="22" label="Project">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(70,1)"/>
                                    <att name="name" value="X2"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.isordinal := true;SELF.wi := 1;...));&#10;"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="23" label="Project">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(72,1)"/>
                                    <att name="name" value="X3"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.isordinal := true;SELF.wi := 1;...));&#10;"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="24" label="Funnel">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl(41,16)"/>
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(81,7)"/>
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(78,1)"/>
                                    <att name="name" value="X"/>
                                    <att name="_kind" value="17"/>
                                    <att name="ordered" value="0"/>
                                    <att name="ecl" value="X1  +  X2  +  X3;&#10;"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="25" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(145,3)"/>
                                    <att name="name" value="XD"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="26" label="Local Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(147,3)"/>
                                    <att name="name" value="XSD"/>
                                    <att name="_kind" value="3"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="SORT(wi, id, number, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi, id, number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="27" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::7&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi, id, number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="_fileName" value="~spill::7"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="28">
                        <att>
                            <graph>
                                <edge id="29_0" source="29" target="30"/>
                                <edge id="30_0" source="30" target="31"/>
                                <edge id="31_0" source="31" target="32"/>
                                <edge id="32_0" source="32" target="33"/>
                                <edge id="33_0" source="33" target="34"/>
                                <node id="29" label="Projected&#10;Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(128,5)"/>
                                    <att name="name" value="xDat"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::7&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi, id, number"/>
                                    <att name="recordSize" value="30"/>
                                    <att name="predictedCount" value="3000"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(147,3)"/>
                                    <att name="name" value="XSD"/>
                                    <att name="_fileName" value="~spill::7"/>
                                    <att name="_isTransformSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="30" label="Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(134,5)"/>
                                    <att name="name" value="xDatS"/>
                                    <att name="_kind" value="3"/>
                                    <att name="ecl" value="SORT(wi, id);&#10;"/>
                                    <att name="metaDistribution" value="sorted(wi, id)"/>
                                    <att name="metaGlobalSortOrder" value="wi, id"/>
                                    <att name="metaLocalSortOrder" value="wi, id"/>
                                    <att name="recordSize" value="30"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="31" label="Iterate">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(135,5)"/>
                                    <att name="name" value="xDat2"/>
                                    <att name="_kind" value="9"/>
                                    <att name="ecl" value="ITERATE(TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10;  real8 value;&#10;  unsigned8 newid;&#10; END,...));&#10;"/>
                                    <att name="metaGlobalSortOrder" value="wi, id"/>
                                    <att name="metaLocalSortOrder" value="wi, id"/>
                                    <att name="recordSize" value="30"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="32" label="Project">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(136,5)"/>
                                    <att name="name" value="outDat0"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.id := LEFT.newid;SELF.wi := LEFT.wi;...));&#10;"/>
                                    <att name="metaGlobalSortOrder" value="wi"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="33" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(137,5)"/>
                                    <att name="name" value="outDat"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="34" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::8&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="_fileName" value="~spill::8"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="35">
                        <att>
                            <graph>
                                <edge id="36_0" source="36" target="37"/>
                                <edge id="37_0" source="37" target="38"/>
                                <edge id="38_0" source="38" target="39"/>
                                <edge id="39_0" source="39" target="40"/>
                                <edge id="40_0" source="40" target="41"/>
                                <edge id="41_0" source="41" target="42"/>
                                <edge id="43_0" source="43" target="44"/>
                                <edge id="44_0"
                                      label="LEFT"
                                      source="44"
                                      target="45"/>
                                <edge id="40_1"
                                      label="RIGHT"
                                      source="40"
                                      target="45">
                                    <att name="_sourceIndex" value="1"/>
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="45_0" source="45" target="46"/>
                                <edge id="46_0" source="46" target="47"/>
                                <edge id="46_1" source="46" target="48">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="48_0" source="48" target="49"/>
                                <edge id="44_1" source="44" target="50">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="50_0" source="50" target="51"/>
                                <node id="36" label="Projected&#10;Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(147,3)"/>
                                    <att name="name" value="XSD"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::7&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi, id, number"/>
                                    <att name="recordSize" value="14"/>
                                    <att name="predictedCount" value="3000"/>
                                    <att name="_fileName" value="~spill::7"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="37" label="Local Group">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(164,17)"/>
                                    <att name="_kind" value="15"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="GROUP(wi, id, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaGrouping" value="wi, id"/>
                                    <att name="metaLocalSortOrder" value="wi, id"/>
                                    <att name="metaGroupSortOrder" value="number"/>
                                    <att name="recordSize" value="14"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="38" label="Grouped Aggregate">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(164,3)"/>
                                    <att name="name" value="idFeatures"/>
                                    <att name="_kind" value="10"/>
                                    <att name="grouped" value="1"/>
                                    <att name="ecl" value="TABLE({ unsigned2 wi := wi, integer8 numfeats := COUNT(group), unsigned4 maxfnum := MAX(group, number) }, local);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="14"/>
                                    <att name="predictedCount" value="1..3000[group]"/>
                                </node>
                                <node id="39" label="Hash Aggregate">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(165,3)"/>
                                    <att name="name" value="wiFeatures"/>
                                    <att name="_kind" value="11"/>
                                    <att name="ecl" value="TABLE({ unsigned2 wi := wi, integer8 numfeatures := MAX(group, numfeats), unsigned4 maxnum := MAX(group, maxfnum) }, wi);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="14"/>
                                    <att name="predictedCount" value="1..3000[group]"/>
                                </node>
                                <node id="40" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(165,24)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.wiFeatures;&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="14"/>
                                    <att name="predictedCount" value="1..3000[group]"/>
                                </node>
                                <node id="41" label="Aggregate">
                                    <att name="_kind" value="10"/>
                                    <att name="ecl" value="TABLE({ integer8 value := SUM(group, maxnum) });&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="1"/>
                                </node>
                                <node id="42" label="Store&#10;Internal(&apos;a4&apos;)">
                                    <att name="_kind" value="22"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="extractresult(value, named(&apos;a4&apos;));&#10;"/>
                                    <att name="recordSize" value="8"/>
                                </node>
                                <node id="43" label="Disk Grouped Aggregate&#10;Spill">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(163,3)"/>
                                    <att name="name" value="wiSamples"/>
                                    <att name="_kind" value="75"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::6&apos;, { unsigned2 wi, unsigned8 id, real8 value }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1..1000[group]"/>
                                    <att name="_fileName" value="~spill::6"/>
                                    <att name="_isTransformSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="44" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(163,23)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.wiSamples;&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1..1000[group]"/>
                                </node>
                                <node id="45" label="Join">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,20)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                    <att name="name" value="wiMeta0"/>
                                    <att name="_kind" value="155"/>
                                    <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, makeMeta(LEFT));&#10;"/>
                                    <att name="recordSize" value="22"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="46" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,20)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,14)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="wiMeta0;&#10;"/>
                                    <att name="recordSize" value="22"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="47" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::1&apos;, __compressed__);&#10;"/>
                                    <att name="recordSize" value="22"/>
                                    <att name="_fileName" value="~spill::1"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                                <node id="48" label="Aggregate">
                                    <att name="_kind" value="10"/>
                                    <att name="ecl" value="TABLE({ unsigned8 numsamples := MAX(group, numsamples) });&#10;"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="1"/>
                                </node>
                                <node id="49" label="Store&#10;Internal(&apos;a1&apos;)">
                                    <att name="_kind" value="22"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="extractresult(numsamples, named(&apos;a1&apos;));&#10;"/>
                                    <att name="recordSize" value="8"/>
                                </node>
                                <node id="50" label="Aggregate">
                                    <att name="_kind" value="10"/>
                                    <att name="ecl" value="TABLE({ integer8 value := SUM(group, ABS(numsamples  -  maxid)) });&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="1"/>
                                </node>
                                <node id="51" label="Store&#10;Internal(&apos;a2&apos;)">
                                    <att name="_kind" value="22"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="extractresult(value, named(&apos;a2&apos;));&#10;"/>
                                    <att name="recordSize" value="8"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="52">
                        <att>
                            <graph>
                                <edge id="53_0" source="53" target="54"/>
                                <edge id="54_0" source="54" target="55"/>
                                <edge id="55_0"
                                      label="LEFT"
                                      source="55"
                                      target="57"/>
                                <edge id="56_0"
                                      label="RIGHT"
                                      source="56"
                                      target="57">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="58_0" source="58" target="59"/>
                                <edge id="59_0" source="59" target="60"/>
                                <edge id="60_0" source="60" target="61"/>
                                <edge id="57_0"
                                      label="LEFT"
                                      source="57"
                                      target="62"/>
                                <edge id="61_0"
                                      label="RIGHT"
                                      source="61"
                                      target="62">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="62_0" source="62" target="63"/>
                                <edge id="61_1" source="61" target="64">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <node id="53" label="Projected&#10;Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(340,5)"/>
                                    <att name="name" value="dummyTrees"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::1&apos;, RECORD&#10;  unsigned2 wi;&#10;  unsigned8 numsamples;&#10;  unsigned4 numfeatures;&#10;  unsigned8 featurespernode;&#10; END, THOR, __compressed__);&#10;"/>
                                    <att name="recordSize" value="2"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,3)"/>
                                    <att name="name" value="wiMeta"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                    <att name="name" value="wiMeta0"/>
                                    <att name="_fileName" value="~spill::1"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="54" label="Normalize">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(342,5)"/>
                                    <att name="name" value="trees"/>
                                    <att name="_kind" value="21"/>
                                    <att name="ecl" value="NORMALIZE(20, TRANSFORM({ unsigned4 treeid, unsigned2 wi },SELF.treeid := COUNTER;SELF.wi := LEFT.wi;));&#10;"/>
                                    <att name="recordSize" value="6"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="55" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(344,5)"/>
                                    <att name="name" value="treesD"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="6"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="56" label="Projected&#10;Spill Read">
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::1&apos;, RECORD&#10;  unsigned2 wi;&#10;  unsigned8 numsamples;&#10;  unsigned4 numfeatures;&#10;  unsigned8 featurespernode;&#10; END, THOR, __compressed__);&#10;"/>
                                    <att name="recordSize" value="10"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,3)"/>
                                    <att name="name" value="wiMeta"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                    <att name="name" value="wiMeta0"/>
                                    <att name="_fileName" value="~spill::1"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="57" label="Lookup Join">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(306,5)"/>
                                    <att name="name" value="xTrees"/>
                                    <att name="_kind" value="157"/>
                                    <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, TRANSFORM({ unsigned4 treeid, unsigned2 wi, unsigned8 numsamples },SELF.numsamples := RIGHT.numsamples;...), lookup, few);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="14"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="58" label="Inline Dataset">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(216,3)"/>
                                    <att name="name" value="treeDummy"/>
                                    <att name="_kind" value="148"/>
                                    <att name="ecl" value="DATASET(20, TRANSFORM({ unsigned4 treeid },SELF.treeid := COUNTER;), { unsigned4 treeid });&#10;"/>
                                    <att name="recordSize" value="4"/>
                                    <att name="predictedCount" value="20"/>
                                </node>
                                <node id="59" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(218,3)"/>
                                    <att name="name" value="treeDummyD"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(treeid);&#10;"/>
                                    <att name="metaDistribution" value="treeid"/>
                                    <att name="recordSize" value="4"/>
                                    <att name="predictedCount" value="20"/>
                                </node>
                                <node id="60" label="Normalize">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(230,28)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(222,3)"/>
                                    <att name="name" value="treeSampleIndxSampled"/>
                                    <att name="_kind" value="21"/>
                                    <att name="ecl" value="NORMALIZE(INTERNAL(&apos;a1&apos;), TRANSFORM({ unsigned4 treeid, unsigned8 id, unsigned8 origid },SELF.origid := (RANDOM() % INTERNAL(&apos;a1&apos;)  +  1);...));&#10;"/>
                                    <att name="metaDistribution" value="treeid"/>
                                    <att name="recordSize" value="20"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="61" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(230,28)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(222,28)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="treeSampleIndxSampled;&#10;"/>
                                    <att name="metaDistribution" value="treeid"/>
                                    <att name="recordSize" value="20"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="62" label="Lookup Join">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(317,17)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(311,5)"/>
                                    <att name="name" value="treeDat0"/>
                                    <att name="_kind" value="157"/>
                                    <att name="ecl" value="JOIN(LEFT.treeid = RIGHT.treeid AND RIGHT.origid &lt;= LEFT.numsamples, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  integer4 origid;&#10; END,...), many, lookup);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="63" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::A&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="_fileName" value="~spill::A"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                                <node id="64" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::9&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="treeid"/>
                                    <att name="recordSize" value="20"/>
                                    <att name="_fileName" value="~spill::9"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="65">
                        <att>
                            <graph>
                                <edge id="66_0" source="66" target="67"/>
                                <edge id="67_0" source="67" target="68"/>
                                <edge id="68_0" source="68" target="69"/>
                                <edge id="69_0" source="69" target="70"/>
                                <edge id="70_0" source="70" target="71"/>
                                <node id="66" label="Projected&#10;Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(128,5)"/>
                                    <att name="name" value="xDat"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::6&apos;, { unsigned2 wi, unsigned8 id, real8 value }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="26"/>
                                    <att name="predictedCount" value="1000"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(148,3)"/>
                                    <att name="name" value="YSD"/>
                                    <att name="_fileName" value="~spill::6"/>
                                    <att name="_isTransformSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="67" label="Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(134,5)"/>
                                    <att name="name" value="xDatS"/>
                                    <att name="_kind" value="3"/>
                                    <att name="ecl" value="SORT(wi, id);&#10;"/>
                                    <att name="metaDistribution" value="sorted(wi, id)"/>
                                    <att name="metaGlobalSortOrder" value="wi, id"/>
                                    <att name="metaLocalSortOrder" value="wi, id"/>
                                    <att name="recordSize" value="26"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="68" label="Iterate">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(135,5)"/>
                                    <att name="name" value="xDat2"/>
                                    <att name="_kind" value="9"/>
                                    <att name="ecl" value="ITERATE(TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  real8 value;&#10;  unsigned8 newid;&#10; END,...));&#10;"/>
                                    <att name="metaGlobalSortOrder" value="wi, id"/>
                                    <att name="metaLocalSortOrder" value="wi, id"/>
                                    <att name="recordSize" value="26"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="69" label="Project">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(136,5)"/>
                                    <att name="name" value="outDat0"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({ unsigned2 wi, unsigned8 id, real8 value },SELF.id := LEFT.newid;SELF.wi := LEFT.wi;...));&#10;"/>
                                    <att name="metaGlobalSortOrder" value="wi"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="70" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(137,5)"/>
                                    <att name="name" value="outDat"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="71" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::B&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="_fileName" value="~spill::B"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="72">
                        <att>
                            <graph>
                                <edge id="73_0" source="73" target="74"/>
                                <edge id="75_0"
                                      label="True"
                                      source="75"
                                      target="77"/>
                                <edge id="76_0"
                                      label="False"
                                      source="76"
                                      target="77">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="74_0"
                                      label="LEFT"
                                      source="74"
                                      target="78"/>
                                <edge id="77_0"
                                      label="RIGHT"
                                      source="77"
                                      target="78">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="78_0" source="78" target="79"/>
                                <edge id="79_0" source="79" target="80"/>
                                <edge id="80_0" source="80" target="81"/>
                                <edge id="81_0" source="81" target="82"/>
                                <edge id="82_0" source="82" target="83"/>
                                <edge id="80_1" source="80" target="84">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <node id="73" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(317,17)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(311,5)"/>
                                    <att name="name" value="treeDat0"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::A&apos;, RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  integer4 origid;&#10; END, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="_fileName" value="~spill::A"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="74" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(319,5)"/>
                                    <att name="name" value="treeDat1D"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, origid));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="75" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(137,5)"/>
                                    <att name="name" value="outDat"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::B&apos;, { unsigned2 wi, unsigned8 id, real8 value }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                    <att name="_fileName" value="~spill::B"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="76" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(148,3)"/>
                                    <att name="name" value="YSD"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::6&apos;, { unsigned2 wi, unsigned8 id, real8 value }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                    <att name="_fileName" value="~spill::6"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="77" label="If">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(180,3)"/>
                                    <att name="name" value="Y"/>
                                    <att name="_kind" value="28"/>
                                    <att name="ecl" value="IF(INTERNAL(&apos;a2&apos;) != 0, outDat, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.YSD);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1000"/>
                                    <att name="_graphIndependent" value="1"/>
                                </node>
                                <node id="78" label="Local Join">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(323,5)"/>
                                    <att name="name" value="treeDat2"/>
                                    <att name="_kind" value="155"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.origid = RIGHT.id, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                    <att name="recordSize" value="82"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="79" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(362,5)"/>
                                    <att name="name" value="rootsD"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="82"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="80" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(362,15)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="rootsD;&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="82"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="81" label="Filter">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,52)"/>
                                    <att name="_kind" value="5"/>
                                    <att name="ecl" value="FILTER(id &gt; 0);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="82"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="82" label="Exists">
                                    <att name="_kind" value="124"/>
                                    <att name="ecl" value="TABLE({ boolean value := EXISTS(group) });&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="1"/>
                                    <att name="predictedCount" value="1"/>
                                </node>
                                <node id="83" label="Store&#10;Internal(&apos;a6&apos;)">
                                    <att name="_kind" value="22"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="extractresult(value, named(&apos;a6&apos;));&#10;"/>
                                    <att name="recordSize" value="1"/>
                                </node>
                                <node id="84" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::C&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="82"/>
                                    <att name="_fileName" value="~spill::C"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="85">
                        <att>
                            <graph>
                                <edge id="86_0"
                                      label="True"
                                      source="86"
                                      target="88"/>
                                <edge id="87_0"
                                      label="False"
                                      source="87"
                                      target="88">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="88_0" source="88" target="89"/>
                                <edge id="89_0" source="89" target="90"/>
                                <edge id="89_1" source="89" target="91">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="91_0" source="91" target="92"/>
                                <edge id="92_0" source="92" target="93"/>
                                <edge id="93_0" source="93" target="94"/>
                                <edge id="94_0" source="94" target="95"/>
                                <edge id="95_0" source="95" target="96"/>
                                <edge id="96_0" source="96" target="97"/>
                                <edge id="96_1" source="96" target="98">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="98_0" source="98" target="99"/>
                                <edge id="96_2" source="96" target="100">
                                    <att name="_sourceIndex" value="2"/>
                                </edge>
                                <edge id="100_0" source="100" target="101"/>
                                <node id="86" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(137,5)"/>
                                    <att name="name" value="outDat"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::8&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                    <att name="_fileName" value="~spill::8"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="87" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(147,3)"/>
                                    <att name="name" value="XSD"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::7&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaLocalSortOrder" value="wi, id, number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                    <att name="_fileName" value="~spill::7"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="88" label="If">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(179,3)"/>
                                    <att name="name" value="X"/>
                                    <att name="_kind" value="28"/>
                                    <att name="ecl" value="IF(INTERNAL(&apos;a2&apos;) != 0, outDat, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.XSD);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                    <att name="_graphIndependent" value="1"/>
                                </node>
                                <node id="89" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(179,15)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.X;&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="3000"/>
                                </node>
                                <node id="90" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::3&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="_fileName" value="~spill::3"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                                <node id="91" label="Filter">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(185,23)"/>
                                    <att name="_kind" value="5"/>
                                    <att name="ecl" value="FILTER(id = 1);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="0..3000[group]"/>
                                </node>
                                <node id="92" label="Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(185,3)"/>
                                    <att name="name" value="allFeatures"/>
                                    <att name="_kind" value="3"/>
                                    <att name="ecl" value="SORT(wi, number);&#10;"/>
                                    <att name="metaDistribution" value="sorted(wi, number)"/>
                                    <att name="metaGlobalSortOrder" value="wi, number"/>
                                    <att name="metaLocalSortOrder" value="wi, number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="0..3000[group]"/>
                                </node>
                                <node id="93" label="Group">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(186,3)"/>
                                    <att name="name" value="allFeaturesG"/>
                                    <att name="_kind" value="15"/>
                                    <att name="ecl" value="GROUP(wi);&#10;"/>
                                    <att name="metaGrouping" value="wi"/>
                                    <att name="metaGlobalSortOrder" value="wi, number"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="metaGroupSortOrder" value="number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="0..3000[group]"/>
                                </node>
                                <node id="94" label="Grouped Count Project">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(187,3)"/>
                                    <att name="name" value="featureMap0"/>
                                    <att name="_kind" value="31"/>
                                    <att name="grouped" value="1"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.id := COUNTER;SELF.wi := LEFT.wi;...));&#10;"/>
                                    <att name="metaGrouping" value="wi"/>
                                    <att name="metaGlobalSortOrder" value="wi, number"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="metaGroupSortOrder" value="number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="0..3000[group]"/>
                                </node>
                                <node id="95" label="Degroup">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(188,3)"/>
                                    <att name="name" value="featureMap"/>
                                    <att name="_kind" value="14"/>
                                    <att name="ecl" value="GROUP();&#10;"/>
                                    <att name="metaGlobalSortOrder" value="wi, number"/>
                                    <att name="metaLocalSortOrder" value="wi, number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="0..3000[group]"/>
                                </node>
                                <node id="96" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(188,24)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.featureMap;&#10;"/>
                                    <att name="metaGlobalSortOrder" value="wi, number"/>
                                    <att name="metaLocalSortOrder" value="wi, number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="predictedCount" value="0..3000[group]"/>
                                </node>
                                <node id="97" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::2&apos;, __compressed__);&#10;"/>
                                    <att name="metaGlobalSortOrder" value="wi, number"/>
                                    <att name="metaLocalSortOrder" value="wi, number"/>
                                    <att name="recordSize" value="23"/>
                                    <att name="_fileName" value="~spill::2"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                                <node id="98" label="Aggregate">
                                    <att name="_kind" value="10"/>
                                    <att name="ecl" value="TABLE({ unsigned8 id := MAX(group, id) });&#10;"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="1"/>
                                </node>
                                <node id="99" label="Store&#10;Internal(&apos;a5&apos;)">
                                    <att name="_kind" value="22"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="extractresult(id, named(&apos;a5&apos;));&#10;"/>
                                    <att name="recordSize" value="8"/>
                                </node>
                                <node id="100" label="Count">
                                    <att name="_kind" value="125"/>
                                    <att name="ecl" value="TABLE({ integer8 value := COUNT(group) });&#10;"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="1"/>
                                </node>
                                <node id="101" label="Store&#10;Internal(&apos;a3&apos;)">
                                    <att name="_kind" value="22"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="extractresult(value, named(&apos;a3&apos;));&#10;"/>
                                    <att name="recordSize" value="8"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="102">
                        <att>
                            <graph>
                                <edge id="103_0" source="103" target="104"/>
                                <edge id="104_0" source="104" target="105"/>
                                <edge id="105_0" source="105" target="106"/>
                                <edge id="106_0" source="106" target="107"/>
                                <edge id="107_0" source="107" target="108"/>
                                <node id="103" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl(46,7)"/>
                                    <att name="name" value="dsOut"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::5&apos;, { unsigned2 wi, real8 value }, THOR, __compressed__);&#10;"/>
                                    <att name="recordSize" value="10"/>
                                    <att name="predictedCount" value="1000"/>
                                    <att name="_fileName" value="~spill::5"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="104" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(52,5)"/>
                                    <att name="name" value="Y_DS"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, value));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, value)"/>
                                    <att name="recordSize" value="10"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="105" label="Local Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(53,20)"/>
                                    <att name="_kind" value="3"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="SORT(wi, value, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, value)"/>
                                    <att name="metaLocalSortOrder" value="wi, value"/>
                                    <att name="recordSize" value="10"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="106" label="Local Group">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(53,20)"/>
                                    <att name="_kind" value="15"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="GROUP(wi, value, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, value)"/>
                                    <att name="metaGrouping" value="wi, value"/>
                                    <att name="metaLocalSortOrder" value="wi, value"/>
                                    <att name="recordSize" value="10"/>
                                    <att name="predictedCount" value="1000"/>
                                </node>
                                <node id="107" label="Grouped Aggregate">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(53,5)"/>
                                    <att name="name" value="classCounts"/>
                                    <att name="_kind" value="10"/>
                                    <att name="grouped" value="1"/>
                                    <att name="ecl" value="TABLE({ unsigned2 wi := wi, real8 value := value, integer8 cnt := COUNT(group) });&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, value)"/>
                                    <att name="metaLocalSortOrder" value="wi, value"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1..1000[group]"/>
                                </node>
                                <node id="108" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::D&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, value)"/>
                                    <att name="metaLocalSortOrder" value="wi, value"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="_fileName" value="~spill::D"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="109">
                        <att>
                            <graph>
                                <edge id="110_0"
                                      label="LEFT"
                                      source="110"
                                      target="112"/>
                                <edge id="111_0"
                                      label="RIGHT"
                                      source="111"
                                      target="112">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="112_0" source="112" target="113"/>
                                <node id="110" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(53,5)"/>
                                    <att name="name" value="classCounts"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::D&apos;, { unsigned2 wi, real8 value, integer8 cnt }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, value)"/>
                                    <att name="metaLocalSortOrder" value="wi, value"/>
                                    <att name="recordSize" value="18"/>
                                    <att name="predictedCount" value="1..1000[group]"/>
                                    <att name="_fileName" value="~spill::D"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="111" label="Projected&#10;Spill Read">
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::1&apos;, RECORD&#10;  unsigned2 wi;&#10;  unsigned8 numsamples;&#10;  unsigned4 numfeatures;&#10;  unsigned8 featurespernode;&#10; END, THOR, __compressed__);&#10;"/>
                                    <att name="recordSize" value="10"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,3)"/>
                                    <att name="name" value="wiMeta"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                    <att name="name" value="wiMeta0"/>
                                    <att name="_fileName" value="~spill::1"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="112" label="Lookup Join">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(472,23)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(55,5)"/>
                                    <att name="name" value="classWeights"/>
                                    <att name="_kind" value="157"/>
                                    <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, TRANSFORM({ unsigned2 wi, real8 value, set of unsigned4 indexes },SELF.wi := LEFT.wi;...), lookup);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="113" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::E&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="_fileName" value="~spill::E"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="114">
                        <att>
                            <graph>
                                <att name="rootGraph" value="1"/>
                                <edge id="297_116"
                                      label="Child"
                                      source="297"
                                      target="116">
                                    <att name="_childGraph" value="1"/>
                                </edge>
                                <edge id="298_116"
                                      label="Body"
                                      source="298"
                                      target="116">
                                    <att name="_childGraph" value="1"/>
                                </edge>
                                <edge id="115_0" source="115" target="116"/>
                                <edge id="116_0" source="116" target="299"/>
                                <edge id="299_0" source="299" target="300"/>
                                <edge id="300_0" source="300" target="301"/>
                                <edge id="301_0" source="301" target="304"/>
                                <edge id="302_0" source="302" target="304">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="303_0" source="303" target="304">
                                    <att name="_targetIndex" value="2"/>
                                </edge>
                                <edge id="304_0" source="304" target="305"/>
                                <edge id="305_0" source="305" target="306"/>
                                <edge id="305_1" source="305" target="307">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <node id="115" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(362,5)"/>
                                    <att name="name" value="rootsD"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::C&apos;, RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                    <att name="recordSize" value="82"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="_fileName" value="~spill::C"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="116" label="Loop">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,5)"/>
                                    <att name="name" value="treeNodes"/>
                                    <att name="_kind" value="103"/>
                                    <att name="ecl" value="LOOP(LEFT.id &gt; 0, EXISTS(...), no_loopbody(), loopfirst(INTERNAL(&apos;a6&apos;)));&#10;"/>
                                    <att name="recordSize" value="82"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="_loopid" value="117"/>
                                </node>
                                <node id="117">
                                    <att name="_kind" value="1">
                                        <graph loopBody="1">
                                            <att name="_numResults" value="27"/>
                                            <node id="118">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="119_0" source="119" target="120"/>
                                                        <edge id="120_0" source="120" target="121"/>
                                                        <edge id="121_0" source="121" target="122"/>
                                                        <edge id="122_0" source="122" target="123"/>
                                                        <edge id="123_0" source="123" target="124"/>
                                                        <edge id="124_0" source="124" target="125"/>
                                                        <edge id="125_0" source="125" target="126"/>
                                                        <edge id="123_1"
                                                              label="LEFT"
                                                              source="123"
                                                              target="127">
                                                            <att name="_sourceIndex" value="1"/>
                                                        </edge>
                                                        <edge id="126_0"
                                                              label="RIGHT"
                                                              source="126"
                                                              target="127">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="127_0" source="127" target="128"/>
                                                        <edge id="128_0" source="128" target="129"/>
                                                        <edge id="129_0" source="129" target="130"/>
                                                        <edge id="130_0" source="130" target="131"/>
                                                        <edge id="131_0" source="131" target="132"/>
                                                        <edge id="132_0" source="132" target="133"/>
                                                        <edge id="133_0" source="133" target="134"/>
                                                        <edge id="134_0" source="134" target="135"/>
                                                        <edge id="126_1"
                                                              label="LEFT"
                                                              source="126"
                                                              target="136">
                                                            <att name="_sourceIndex" value="1"/>
                                                        </edge>
                                                        <edge id="135_0"
                                                              label="RIGHT"
                                                              source="135"
                                                              target="136">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="136_0" source="136" target="137"/>
                                                        <edge id="135_1" source="135" target="138">
                                                            <att name="_sourceIndex" value="1"/>
                                                        </edge>
                                                        <edge id="133_1" source="133" target="139">
                                                            <att name="_sourceIndex" value="1"/>
                                                        </edge>
                                                        <edge id="123_2" source="123" target="140">
                                                            <att name="_sourceIndex" value="2"/>
                                                        </edge>
                                                        <node id="119" label="Begin Loop">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,52)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(1);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="120" label="Local Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, treeid, nodeid, depend, parentid, isleft, local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="121" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, depend, parentid, isleft, local);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="122" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,5)"/>
                                                            <att name="name" value="nodeValCounts"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, real8 depend := depend, unsigned8 parentid := parentid, boolean isleft := isleft, integer8 cnt := COUNT(group), real8 weightsum := SUM(group, observweight) }, local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="recordSize" value="47"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="123" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="nodeValCounts;&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="recordSize" value="47"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="124" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(214,19)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="depend, parentid, isleft"/>
                                                            <att name="recordSize" value="47"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="125" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(214,5)"/>
                                                            <att name="name" value="nodeCounts"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, real8 totweights := SUM(group, weightsum) }, local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="126" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(214,19)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="nodeCounts;&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="127" label="Lightweight Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(219,5)"/>
                                                            <att name="name" value="nodeEntInfo"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="128" label="Local Group">
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="129" label="Grouped Sort">
                                                            <att name="_kind" value="3"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(parentid, isleft);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="parentid, isleft"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="130" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(226,17)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, parentid, isleft, local);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="131" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(226,5)"/>
                                                            <att name="name" value="nodeEnt0"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned8 parentid := parentid, boolean isleft := isleft, real8 entropy := SUM(group, plogp), unsigned8 tot := SUM(group, cnt) }, local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="132" label="Project">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(231,5)"/>
                                                            <att name="name" value="nodeImp"/>
                                                            <att name="_kind" value="7"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="PROJECT(TRANSFORM({(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;... END)... },...));&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="133" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(231,16)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="nodeImp;&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="134" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(238,5)"/>
                                                            <att name="name" value="pureEnoughNodes"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(impurity &lt; 1e-07 OR &lt;...&gt;.&lt;unnamed&gt; = 100);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="135" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(238,24)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="pureEnoughNodes;&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="136" label="Lightweight Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(242,5)"/>
                                                            <att name="name" value="toSplitNodes"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM({ unsigned4 treeid, unsigned8 nodeid, unsigned2 wi },SELF.treeid := LEFT.treeid;...), left only, local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="137" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(8);&#10;"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                        <node id="138" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(7);&#10;"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                        <node id="139" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(6);&#10;"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                        <node id="140" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(5);&#10;"/>
                                                            <att name="recordSize" value="47"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="141">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="142_0" source="142" target="143"/>
                                                        <edge id="143_0"
                                                              label="LEFT"
                                                              source="143"
                                                              target="145"/>
                                                        <edge id="144_0"
                                                              label="RIGHT"
                                                              source="144"
                                                              target="145">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="145_0" source="145" target="146"/>
                                                        <edge id="146_0" source="146" target="147"/>
                                                        <edge id="147_0" source="147" target="148"/>
                                                        <edge id="148_0" source="148" target="149"/>
                                                        <edge id="149_0" source="149" target="150"/>
                                                        <edge id="150_0" source="150" target="151"/>
                                                        <edge id="151_0" source="151" target="152"/>
                                                        <edge id="152_0" source="152" target="153"/>
                                                        <node id="142" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(242,5)"/>
                                                            <att name="name" value="toSplitNodes"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(8);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="143" label="Local Dedup">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(238,5)"/>
                                                            <att name="name" value="nodes"/>
                                                            <att name="_kind" value="4"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="144" label="Projected&#10;Spill Read">
                                                            <att name="_kind" value="195"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DATASET(&apos;~spill::1&apos;, RECORD&#10;  unsigned2 wi;&#10;  unsigned8 numsamples;&#10;  unsigned4 numfeatures;&#10;  unsigned8 featurespernode;&#10; END, THOR, __compressed__, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.wiMeta);&#10;"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,3)"/>
                                                            <att name="name" value="wiMeta"/>
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                                            <att name="name" value="wiMeta0"/>
                                                            <att name="_fileName" value="~spill::1"/>
                                                            <att name="_isSpill" value="1"/>
                                                            <att name="signedBy" value="hpcc"/>
                                                        </node>
                                                        <node id="145" label="Lookup Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(252,5)"/>
                                                            <att name="name" value="xNodes"/>
                                                            <att name="_kind" value="157"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned8 numfeatures;&#10;... END,...), lookup, few);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="30"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="146" label="Normalize">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(265,5)"/>
                                                            <att name="name" value="nodeVars0"/>
                                                            <att name="_kind" value="21"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="NORMALIZE(LEFT.featurespernode * 2, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10;... END,...));&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="34"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="147" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(266,5)"/>
                                                            <att name="name" value="nodeVars1"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="34"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="148" label="Grouped Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(267,5)"/>
                                                            <att name="name" value="nodeVars2"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, treeid, nodeid, number);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="34"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="149" label="Grouped Dedup">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(269,5)"/>
                                                            <att name="name" value="nodeVars3"/>
                                                            <att name="_kind" value="4"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DEDUP(wi, treeid, nodeid, number);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="34"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="150" label="Grouped Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(272,5)"/>
                                                            <att name="name" value="nodeVars4"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, treeid, nodeid, rnd);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="wi, treeid, nodeid, rnd"/>
                                                            <att name="recordSize" value="34"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="151" label="Grouped Count Project">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(275,26)"/>
                                                            <att name="_kind" value="31"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10; END,...));&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="152" label="Degroup">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(275,5)"/>
                                                            <att name="name" value="nodeVars5"/>
                                                            <att name="_kind" value="14"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP();&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="153" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(9);&#10;"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="154">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="155_0"
                                                              label="LEFT"
                                                              source="155"
                                                              target="157"/>
                                                        <edge id="156_0"
                                                              label="RIGHT"
                                                              source="156"
                                                              target="157">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="157_0" source="157" target="158"/>
                                                        <node id="155" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(275,5)"/>
                                                            <att name="name" value="nodeVars5"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(9);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="156" label="Projected&#10;Spill Read">
                                                            <att name="_kind" value="195"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DATASET(&apos;~spill::2&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.featureMap);&#10;"/>
                                                            <att name="metaGlobalSortOrder" value="wi, number"/>
                                                            <att name="metaLocalSortOrder" value="wi, number"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="predictedCount" value="0..3000[group]"/>
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(188,3)"/>
                                                            <att name="name" value="featureMap"/>
                                                            <att name="_fileName" value="~spill::2"/>
                                                            <att name="_isSpill" value="1"/>
                                                            <att name="signedBy" value="hpcc"/>
                                                        </node>
                                                        <node id="157" label="Lookup Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(281,7)"/>
                                                            <att name="name" value="rnDat"/>
                                                            <att name="_kind" value="157"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.id, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10; END,...), lookup);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="158" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(10);&#10;"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="159">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="161_0"
                                                              label="True"
                                                              source="161"
                                                              target="163"/>
                                                        <edge id="162_0"
                                                              label="False"
                                                              source="162"
                                                              target="163">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="160_0"
                                                              label="LEFT"
                                                              source="160"
                                                              target="164"/>
                                                        <edge id="163_0"
                                                              label="RIGHT"
                                                              source="163"
                                                              target="164">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="164_0"
                                                              label="LEFT"
                                                              source="164"
                                                              target="166"/>
                                                        <edge id="165_0"
                                                              label="RIGHT"
                                                              source="165"
                                                              target="166">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="166_0" source="166" target="167"/>
                                                        <node id="160" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(242,5)"/>
                                                            <att name="name" value="toSplitNodes"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(8);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="161" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(281,7)"/>
                                                            <att name="name" value="rnDat"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(10);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="162" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(275,5)"/>
                                                            <att name="name" value="nodeVars5"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(9);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="163" label="If">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(285,5)"/>
                                                            <att name="name" value="nodeVars"/>
                                                            <att name="_kind" value="66"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="IF(INTERNAL(&apos;a3&apos;) != INTERNAL(&apos;a4&apos;), rnDat, nodeVars5);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphIndependent" value="1"/>
                                                        </node>
                                                        <node id="164" label="Lightweight Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(290,5)"/>
                                                            <att name="name" value="nodeVarDat"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10; END,...), local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="18"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="165" label="Begin Loop">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,52)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(1);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="166" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(253,5)"/>
                                                            <att name="name" value="toSplitDat0"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="62"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="167" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(11);&#10;"/>
                                                            <att name="recordSize" value="62"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="168">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="169_0" source="169" target="170"/>
                                                        <edge id="170_0" source="170" target="171"/>
                                                        <edge id="171_0" source="171" target="172"/>
                                                        <node id="169" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(253,5)"/>
                                                            <att name="name" value="toSplitDat0"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(11);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="62"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="170" label="Hash Distribute">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(257,24)"/>
                                                            <att name="_kind" value="19"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DISTRIBUTE(HASH32(wi, origid));&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                                            <att name="recordSize" value="62"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="171" label="Local Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(257,5)"/>
                                                            <att name="name" value="toSplitDat1"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, origid, number, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, origid, number"/>
                                                            <att name="recordSize" value="62"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="172" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(12);&#10;"/>
                                                            <att name="recordSize" value="62"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="173">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="174_0"
                                                              label="LEFT"
                                                              source="174"
                                                              target="176"/>
                                                        <edge id="175_0"
                                                              label="RIGHT"
                                                              source="175"
                                                              target="176">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="176_0" source="176" target="177"/>
                                                        <edge id="177_0" source="177" target="178"/>
                                                        <node id="174" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(257,5)"/>
                                                            <att name="name" value="toSplitDat1"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(12);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, origid, number"/>
                                                            <att name="recordSize" value="62"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="175" label="Projected&#10;Spill Read">
                                                            <att name="_kind" value="195"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DATASET(&apos;~spill::3&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.X);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, id)"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="predictedCount" value="3000"/>
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(179,3)"/>
                                                            <att name="name" value="X"/>
                                                            <att name="_fileName" value="~spill::3"/>
                                                            <att name="_isSpill" value="1"/>
                                                            <att name="signedBy" value="hpcc"/>
                                                        </node>
                                                        <node id="176" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(258,5)"/>
                                                            <att name="name" value="toSplitDat2"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.origid = RIGHT.id AND LEFT.number = RIGHT.number, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="177" label="Hash Distribute">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(262,5)"/>
                                                            <att name="name" value="toSplitDat"/>
                                                            <att name="_kind" value="19"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid));&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="178" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(13);&#10;"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="179">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="180_0" source="180" target="181"/>
                                                        <edge id="181_0" source="181" target="182"/>
                                                        <edge id="182_0" source="182" target="183"/>
                                                        <edge id="183_0" source="183" target="184"/>
                                                        <node id="180" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(262,5)"/>
                                                            <att name="name" value="toSplitDat"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(13);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="181" label="Local Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,20)"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, treeid, nodeid, number, value, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="182" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,20)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, number, value, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid, number, value"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="183" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,5)"/>
                                                            <att name="name" value="featureVals"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 value := value, boolean rmval := false }, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="184" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(14);&#10;"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="185">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="187_0" source="187" target="188"/>
                                                        <edge id="188_0" source="188" target="189"/>
                                                        <edge id="190_0" source="190" target="191"/>
                                                        <edge id="191_0" source="191" target="192"/>
                                                        <edge id="192_0" source="192" target="193"/>
                                                        <edge id="193_0" source="193" target="194"/>
                                                        <edge id="189_0"
                                                              label="LEFT"
                                                              source="189"
                                                              target="195"/>
                                                        <edge id="194_0"
                                                              label="RIGHT"
                                                              source="194"
                                                              target="195">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="195_0" source="195" target="196"/>
                                                        <edge id="186_0"
                                                              label="LEFT"
                                                              source="186"
                                                              target="197"/>
                                                        <edge id="196_0"
                                                              label="RIGHT"
                                                              source="196"
                                                              target="197">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="197_0" source="197" target="198"/>
                                                        <edge id="193_1" source="193" target="199">
                                                            <att name="_sourceIndex" value="1"/>
                                                        </edge>
                                                        <node id="186" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(262,5)"/>
                                                            <att name="name" value="toSplitDat"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(13);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="187" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,5)"/>
                                                            <att name="name" value="featureVals"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(14);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="188" label="Local Iterate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(106,5)"/>
                                                            <att name="name" value="splitPoints1"/>
                                                            <att name="_kind" value="9"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="ITERATE(TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="189" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(107,5)"/>
                                                            <att name="name" value="splitPoints"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(NOT rmval);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="190" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,5)"/>
                                                            <att name="name" value="featureVals"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(14);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="191" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(79,17)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, number, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid, number"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="metaGroupSortOrder" value="value"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="192" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(79,5)"/>
                                                            <att name="name" value="features"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, boolean isordinal := true, integer8 vals := COUNT(group) }, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="193" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(79,17)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="features;&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="194" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(88,5)"/>
                                                            <att name="name" value="goodFeatures"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(vals &gt; 1);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="195" label="Lightweight Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(115,5)"/>
                                                            <att name="name" value="splitInfo0"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="196" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(123,5)"/>
                                                            <att name="name" value="splitInfo"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(NOT rmval);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="197" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(126,5)"/>
                                                            <att name="name" value="allSplitDat"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND RIGHT.nodeid = LEFT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  boolean isleft;&#10;  unsigned2 wi;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="198" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(16);&#10;"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                        <node id="199" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(15);&#10;"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="200">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="201_0" source="201" target="202"/>
                                                        <edge id="202_0" source="202" target="203"/>
                                                        <edge id="203_0" source="203" target="204"/>
                                                        <edge id="204_0" source="204" target="205"/>
                                                        <node id="201" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(126,5)"/>
                                                            <att name="name" value="allSplitDat"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(16);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="202" label="Local Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,21)"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, treeid, nodeid, number, splitval, isleft, depend, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft, depend"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="203" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,21)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, number, splitval, isleft, depend, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid, number, splitval, isleft, depend"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft, depend"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="204" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,5)"/>
                                                            <att name="name" value="dependGroups"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, boolean isleft := isleft, unsigned8 cnt := COUNT(group), real8 weightsum := SUM(group, observweight) }, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="205" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(17);&#10;"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="206">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="208_0" source="208" target="209"/>
                                                        <edge id="209_0" source="209" target="210"/>
                                                        <edge id="207_0"
                                                              label="LEFT"
                                                              source="207"
                                                              target="211"/>
                                                        <edge id="210_0"
                                                              label="RIGHT"
                                                              source="210"
                                                              target="211">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="211_0" source="211" target="212"/>
                                                        <edge id="212_0" source="212" target="213"/>
                                                        <edge id="213_0" source="213" target="214"/>
                                                        <edge id="214_0" source="214" target="215"/>
                                                        <edge id="215_0" source="215" target="216"/>
                                                        <edge id="216_0" source="216" target="217"/>
                                                        <edge id="217_0" source="217" target="218"/>
                                                        <edge id="218_0" source="218" target="219"/>
                                                        <edge id="219_0" source="219" target="220"/>
                                                        <edge id="221_0" source="221" target="222"/>
                                                        <edge id="220_0"
                                                              label="LEFT"
                                                              source="220"
                                                              target="223"/>
                                                        <edge id="222_0"
                                                              label="RIGHT"
                                                              source="222"
                                                              target="223">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="224_0" source="224" target="225"/>
                                                        <edge id="225_0" source="225" target="226"/>
                                                        <edge id="223_0"
                                                              label="LEFT"
                                                              source="223"
                                                              target="227"/>
                                                        <edge id="226_0"
                                                              label="RIGHT"
                                                              source="226"
                                                              target="227">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="227_0" source="227" target="228"/>
                                                        <node id="207" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,5)"/>
                                                            <att name="name" value="dependGroups"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(17);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="208" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,5)"/>
                                                            <att name="name" value="dependGroups"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(17);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="209" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(140,22)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, number, splitval, isleft, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="metaGroupSortOrder" value="depend"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="210" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(140,5)"/>
                                                            <att name="name" value="dependSummary"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, boolean isleft := isleft, real8 totweights := SUM(group, weightsum) }, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="211" label="Lightweight Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(144,5)"/>
                                                            <att name="name" value="dependRatios"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="212" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(153,21)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, number, splitval, isleft, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="213" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(153,5)"/>
                                                            <att name="name" value="lr_entropies"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, unsigned8 tot := SUM(group, cnt), real8 entropy := SUM(group, plogp) }, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval"/>
                                                            <att name="recordSize" value="42"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="214" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(158,19)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, number, splitval, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid, number, splitval"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval"/>
                                                            <att name="recordSize" value="42"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="215" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(158,19)"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, boolean isordinal := true, real8 _agg_6 := SUM(group, entropy * tot), unsigned8 _agg_7 := SUM(group, tot) }, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval"/>
                                                            <att name="recordSize" value="43"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="216" label="Project">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(158,5)"/>
                                                            <att name="name" value="entropies0"/>
                                                            <att name="_kind" value="7"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="NEWTABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, boolean isordinal := isordinal, real8 totentropy := (_agg_6 / _agg_7) });&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="217" label="Local Group">
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="number, splitval"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="218" label="Grouped Sort">
                                                            <att name="_kind" value="3"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(totentropy);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="totentropy"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="219" label="Degroup">
                                                            <att name="_kind" value="14"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP();&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, totentropy"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="220" label="Local Dedup">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(165,5)"/>
                                                            <att name="name" value="lowestEntropies"/>
                                                            <att name="_kind" value="4"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, totentropy"/>
                                                            <att name="recordSize" value="35"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="221" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(231,16)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(6);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="222" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(266,5)"/>
                                                            <att name="name" value="parentNodeImp"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(impurity &gt;= 1e-07 AND &lt;...&gt;.&lt;unnamed&gt; &lt; 100);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="223" label="Lightweight Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(173,5)"/>
                                                            <att name="name" value="ig"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned4 number;&#10;... END,...), right outer, local);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="224" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(79,17)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(15);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="225" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(86,5)"/>
                                                            <att name="name" value="constantFeatures"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(vals = 1);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="226" label="Local Dedup">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(87,5)"/>
                                                            <att name="name" value="dummySplits"/>
                                                            <att name="_kind" value="4"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                            <att name="recordSize" value="27"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="227" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(192,5)"/>
                                                            <att name="name" value="bestSplits"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD(RECORD&#10;   unsigned2 wi;&#10;   unsigned4 treeid;&#10;   unsigned8 nodeid;&#10;   unsigned8 parentid;&#10;...  END)&#10;... END,...), left outer, local);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="228" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(18);&#10;"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="229">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="231_0" source="231" target="232"/>
                                                        <edge id="232_0" source="232" target="233"/>
                                                        <edge id="230_0"
                                                              label="LEFT"
                                                              source="230"
                                                              target="234"/>
                                                        <edge id="233_0"
                                                              label="RIGHT"
                                                              source="233"
                                                              target="234">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="234_0" source="234" target="235"/>
                                                        <edge id="233_1" source="233" target="236">
                                                            <att name="_sourceIndex" value="1"/>
                                                        </edge>
                                                        <node id="230" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(262,5)"/>
                                                            <att name="name" value="toSplitDat"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(13);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="231" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(192,5)"/>
                                                            <att name="name" value="bestSplits"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(18);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="232" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(272,5)"/>
                                                            <att name="name" value="goodSplits"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(number != 0);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="233" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(272,19)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="goodSplits;&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="234" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(278,5)"/>
                                                            <att name="name" value="goodSplitDat"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="235" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(20);&#10;"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                        <node id="236" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(19);&#10;"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="237">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="238_0"
                                                              label="LEFT"
                                                              source="238"
                                                              target="240"/>
                                                        <edge id="239_0"
                                                              label="RIGHT"
                                                              source="239"
                                                              target="240">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="240_0" source="240" target="241"/>
                                                        <node id="238" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(272,19)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(19);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="239" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(278,5)"/>
                                                            <att name="name" value="goodSplitDat"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(20);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="240" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(284,5)"/>
                                                            <att name="name" value="leftIds"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 id;&#10; END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="241" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(21);&#10;"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="242">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="243_0"
                                                              label="LEFT"
                                                              source="243"
                                                              target="245"/>
                                                        <edge id="244_0"
                                                              label="RIGHT"
                                                              source="244"
                                                              target="245">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="245_0" source="245" target="246"/>
                                                        <edge id="246_0" source="246" target="247"/>
                                                        <edge id="247_0" source="247" target="248"/>
                                                        <edge id="246_1" source="246" target="249">
                                                            <att name="_sourceIndex" value="1"/>
                                                        </edge>
                                                        <node id="243" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(278,5)"/>
                                                            <att name="name" value="goodSplitDat"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(20);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="70"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="244" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(284,5)"/>
                                                            <att name="name" value="leftIds"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(21);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="245" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,5)"/>
                                                            <att name="name" value="LR_nextLevel"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), left outer, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="246" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,21)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="LR_nextLevel;&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="247" label="Aggregate">
                                                            <att name="_kind" value="10"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned8 nodeid := MAX(group, nodeid) });&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="8"/>
                                                            <att name="predictedCount" value="1"/>
                                                        </node>
                                                        <node id="248" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(4);&#10;"/>
                                                            <att name="recordSize" value="8"/>
                                                            <att name="_isSpill" value="1"/>
                                                            <att name="_fromChild" value="1"/>
                                                        </node>
                                                        <node id="249" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(22);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="250">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="251_0" source="251" target="252"/>
                                                        <edge id="252_0" source="252" target="253"/>
                                                        <edge id="253_0" source="253" target="254"/>
                                                        <edge id="254_0" source="254" target="255"/>
                                                        <edge id="255_0" source="255" target="256"/>
                                                        <edge id="256_0" source="256" target="257"/>
                                                        <edge id="257_0" source="257" target="258"/>
                                                        <node id="251" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,21)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(22);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="252" label="Local Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(316,21)"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="253" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(316,21)"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="254" label="Grouped Aggregate">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(316,5)"/>
                                                            <att name="name" value="nextLevelIds"/>
                                                            <att name="_kind" value="10"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid }, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="255" label="Local Group">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(317,5)"/>
                                                            <att name="name" value="nextLevelIdsG"/>
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid"/>
                                                            <att name="metaGroupSortOrder" value="nodeid"/>
                                                            <att name="recordSize" value="14"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="256" label="Grouped Count Project">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(318,5)"/>
                                                            <att name="name" value="newIdsG"/>
                                                            <att name="_kind" value="31"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 newid;&#10; END,...));&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaGrouping" value="wi, treeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid"/>
                                                            <att name="metaGroupSortOrder" value="nodeid"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="257" label="Degroup">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(319,5)"/>
                                                            <att name="name" value="newIds"/>
                                                            <att name="_kind" value="14"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP();&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="258" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(23);&#10;"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="259">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="260_0"
                                                              label="LEFT"
                                                              source="260"
                                                              target="262"/>
                                                        <edge id="261_0"
                                                              label="RIGHT"
                                                              source="261"
                                                              target="262">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="262_0" source="262" target="263"/>
                                                        <node id="260" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,21)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(22);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="261" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(319,5)"/>
                                                            <att name="name" value="newIds"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(23);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="22"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="262" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(320,22)"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="263" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(24);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="264">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="265_0" source="265" target="266"/>
                                                        <edge id="266_0" source="266" target="267"/>
                                                        <node id="265" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(320,22)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(24);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="266" label="Local Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(320,5)"/>
                                                            <att name="name" value="fixupIds"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="267" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(25);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="268">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <edge id="270_0" source="270" target="271"/>
                                                        <edge id="269_0"
                                                              label="LEFT"
                                                              source="269"
                                                              target="272"/>
                                                        <edge id="271_0"
                                                              label="RIGHT"
                                                              source="271"
                                                              target="272">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="272_0" source="272" target="273"/>
                                                        <node id="269" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(5);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="recordSize" value="47"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="270" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(192,5)"/>
                                                            <att name="name" value="bestSplits"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(18);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="271" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(274,5)"/>
                                                            <att name="name" value="badSplits"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(number = 0);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="272" label="Local Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(342,5)"/>
                                                            <att name="name" value="mixedLeafs0"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="273" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_internal" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(26);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="_isSpill" value="1"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                            <node id="274">
                                                <att name="_kind" value="1">
                                                    <graph child="1">
                                                        <att name="rootGraph" value="1"/>
                                                        <edge id="275_0"
                                                              label="LEFT"
                                                              source="275"
                                                              target="277"/>
                                                        <edge id="276_0"
                                                              label="RIGHT"
                                                              source="276"
                                                              target="277">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="277_0" source="277" target="278"/>
                                                        <edge id="278_0" source="278" target="279"/>
                                                        <edge id="279_0" source="279" target="280"/>
                                                        <edge id="280_0" source="280" target="281"/>
                                                        <edge id="281_0" source="281" target="282"/>
                                                        <edge id="282_0"
                                                              label="True"
                                                              source="282"
                                                              target="283"/>
                                                        <edge id="278_1"
                                                              label="False"
                                                              source="278"
                                                              target="283">
                                                            <att name="_sourceIndex" value="1"/>
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="284_0" source="284" target="285"/>
                                                        <edge id="285_0" source="285" target="286"/>
                                                        <edge id="287_0" source="287" target="288"/>
                                                        <edge id="289_0"
                                                              label="True"
                                                              source="289"
                                                              target="291"/>
                                                        <edge id="290_0"
                                                              label="False"
                                                              source="290"
                                                              target="291">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="283_0" source="283" target="292"/>
                                                        <edge id="286_0" source="286" target="292">
                                                            <att name="_targetIndex" value="1"/>
                                                        </edge>
                                                        <edge id="288_0" source="288" target="292">
                                                            <att name="_targetIndex" value="2"/>
                                                        </edge>
                                                        <edge id="291_0" source="291" target="292">
                                                            <att name="_targetIndex" value="3"/>
                                                        </edge>
                                                        <edge id="292_0" source="292" target="293"/>
                                                        <edge id="293_0" source="293" target="294"/>
                                                        <edge id="294_0" source="294" target="295"/>
                                                        <edge id="295_0" source="295" target="296"/>
                                                        <edge id="296_0" source="296" target="297"/>
                                                        <edge id="293_1" source="293" target="298">
                                                            <att name="_sourceIndex" value="1"/>
                                                        </edge>
                                                        <node id="275" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(5);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="recordSize" value="47"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="276" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(238,24)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(7);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                            <att name="recordSize" value="39"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="277" label="Lightweight Join">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(354,5)"/>
                                                            <att name="name" value="pureNodes0"/>
                                                            <att name="_kind" value="155"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="278" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(354,19)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="pureNodes0;&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="279" label="Local Group">
                                                            <att name="_kind" value="15"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="depend, parentid, isleft"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="280" label="Grouped Sort">
                                                            <att name="_kind" value="3"/>
                                                            <att name="grouped" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(-support);&#10;"/>
                                                            <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="metaGroupSortOrder" value="-support"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="281" label="Degroup">
                                                            <att name="_kind" value="14"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GROUP();&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, -support"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="282" label="Local Dedup">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(364,5)"/>
                                                            <att name="name" value="pureNodes2"/>
                                                            <att name="_kind" value="4"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, -support"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="283" label="If">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(365,5)"/>
                                                            <att name="name" value="pureNodes"/>
                                                            <att name="_kind" value="66"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="IF(&lt;...&gt;.&lt;unnamed&gt; = 100, pureNodes2, ...);&#10;"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="284" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(342,5)"/>
                                                            <att name="name" value="mixedLeafs0"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(26);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="285" label="Local Sort">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(348,5)"/>
                                                            <att name="name" value="mixedLeafs1"/>
                                                            <att name="_kind" value="3"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SORT(wi, treeid, nodeid, -support, local);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, -support"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="286" label="Local Dedup">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(349,5)"/>
                                                            <att name="name" value="mixedLeafs"/>
                                                            <att name="_kind" value="4"/>
                                                            <att name="local" value="1"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid, -support"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="287" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(272,19)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(19);&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="52"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="288" label="Project">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(329,5)"/>
                                                            <att name="name" value="splitNodes"/>
                                                            <att name="_kind" value="7"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...));&#10;"/>
                                                            <att name="metaDistribution" value="unknown"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="289" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(320,5)"/>
                                                            <att name="name" value="fixupIds"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(25);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="290" label="Read Local Result">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,21)"/>
                                                            <att name="_kind" value="93"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="GetGraphResult(22);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                            <att name="_graphId" value="117"/>
                                                        </node>
                                                        <node id="291" label="If">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(326,5)"/>
                                                            <att name="name" value="nextLevelDat"/>
                                                            <att name="_kind" value="66"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="IF(maxNodeId &gt;= 281474976710656.0, fixupIds, LR_nextLevel);&#10;"/>
                                                            <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="292" label="Funnel">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(203,3)"/>
                                                            <att name="name" value="GrowForestLevel"/>
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(369,12)"/>
                                                            <att name="_kind" value="17"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ordered" value="0"/>
                                                            <att name="ecl" value="leafNodes  +  splitNodes  +  nextLevelDat;&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="293" label="Split">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(369,12)"/>
                                                            <att name="_kind" value="6"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Classification.GrowForestLevel(ROWS, COUNTER);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="294" label="Filter">
                                                            <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,52)"/>
                                                            <att name="_kind" value="5"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="FILTER(id &gt; 0, &lt;...&gt;.&lt;unnamed&gt;  +  1 &lt;= 100);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                            <att name="predictedCount" value="0..?[disk]"/>
                                                        </node>
                                                        <node id="295" label="Exists">
                                                            <att name="_kind" value="124"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="TABLE({ boolean value := EXISTS(group) });&#10;"/>
                                                            <att name="recordSize" value="1"/>
                                                            <att name="predictedCount" value="1"/>
                                                        </node>
                                                        <node id="296" label="Project">
                                                            <att name="_kind" value="7"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="NEWTABLE({ boolean &lt;unnamed&gt; := value });&#10;"/>
                                                            <att name="recordSize" value="1"/>
                                                            <att name="predictedCount" value="1"/>
                                                        </node>
                                                        <node id="297" label="Local Result">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(3);&#10;"/>
                                                            <att name="recordSize" value="1"/>
                                                        </node>
                                                        <node id="298" label="End Loop">
                                                            <att name="_kind" value="94"/>
                                                            <att name="_parentActivity" value="116"/>
                                                            <att name="ecl" value="SetGraphResult(0);&#10;"/>
                                                            <att name="recordSize" value="82"/>
                                                        </node>
                                                    </graph>
                                                </att>
                                                <att name="_parentActivity" value="116"/>
                                            </node>
                                        </graph>
                                    </att>
                                    <att name="_parentActivity" value="116"/>
                                </node>
                                <node id="299" label="Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(360,3)"/>
                                    <att name="name" value="GrowForest"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(365,12)"/>
                                    <att name="_kind" value="3"/>
                                    <att name="ecl" value="SORT(wi, treeid, level, nodeid);&#10;"/>
                                    <att name="metaDistribution" value="sorted(wi, treeid, level, nodeid)"/>
                                    <att name="metaGlobalSortOrder" value="wi, treeid, level, nodeid"/>
                                    <att name="metaLocalSortOrder" value="wi, treeid, level, nodeid"/>
                                    <att name="recordSize" value="82"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="300" label="Count Project">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(573,5)"/>
                                    <att name="name" value="nodesExt"/>
                                    <att name="_kind" value="31"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...));&#10;"/>
                                    <att name="metaDistribution" value="sorted(wi, treeid, level, nodeid)"/>
                                    <att name="metaGlobalSortOrder" value="wi, treeid, level, nodeid"/>
                                    <att name="metaLocalSortOrder" value="wi, treeid, level, nodeid"/>
                                    <att name="recordSize" value="70"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="301" label="Normalize">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(240,15)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(575,5)"/>
                                    <att name="name" value="nfMod"/>
                                    <att name="_kind" value="21"/>
                                    <att name="ecl" value="NORMALIZE(11, nf_to_mod(LEFT));&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaGlobalSortOrder" value="wi"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="302" label="Projected&#10;Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(240,15)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(585,5)"/>
                                    <att name="name" value="nfIndexes"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::9&apos;, { unsigned4 treeid, unsigned8 id, unsigned8 origid }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(230,28)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(222,3)"/>
                                    <att name="name" value="treeSampleIndxSampled"/>
                                    <att name="_fileName" value="~spill::9"/>
                                    <att name="_isTransformSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="303" label="Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(472,23)"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(55,5)"/>
                                    <att name="name" value="classWeights"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::E&apos;, { unsigned2 wi, real8 value, set of unsigned4 indexes }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="_fileName" value="~spill::E"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="304" label="Funnel">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(475,5)"/>
                                    <att name="name" value="mod"/>
                                    <att name="_kind" value="17"/>
                                    <att name="ordered" value="0"/>
                                    <att name="ecl" value="baseMod  +  classWeights;&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="305" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(475,12)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="mod;&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="306" label="Output&#10;&apos;Model&apos;">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(93,1)"/>
                                    <att name="_kind" value="16"/>
                                    <att name="ecl" value="OUTPUT(..., , named(&apos;Model&apos;), workunit);&#10;"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                </node>
                                <node id="307" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::F&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="_fileName" value="~spill::F"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="308">
                        <att>
                            <graph>
                                <att name="rootGraph" value="1"/>
                                <edge id="309_0" source="309" target="310"/>
                                <edge id="310_0" source="310" target="311"/>
                                <edge id="311_0" source="311" target="312"/>
                                <edge id="312_0" source="312" target="313"/>
                                <edge id="313_0" source="313" target="314"/>
                                <edge id="314_0" source="314" target="315"/>
                                <edge id="315_0" source="315" target="316"/>
                                <edge id="316_0" source="316" target="317"/>
                                <edge id="317_0" source="317" target="318"/>
                                <edge id="318_0" source="318" target="319"/>
                                <edge id="316_1" source="316" target="320">
                                    <att name="_sourceIndex" value="1"/>
                                </edge>
                                <edge id="320_0" source="320" target="321"/>
                                <node id="309" label="Filtered&#10;Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(213,24)"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::F&apos;, { unsigned2 wi, real8 value, set of unsigned4 indexes }, THOR, __compressed__);&#10;FILTER(filter);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(475,5)"/>
                                    <att name="name" value="mod"/>
                                    <att name="_fileName" value="~spill::F"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="310" label="Assert">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(213,5)"/>
                                    <att name="name" value="outCells"/>
                                    <att name="_kind" value="5"/>
                                    <att name="ecl" value="ASSERT(COUNT(indexes) = 3, &apos;ModelOps2.ToNumericField: Extracted indexes must be exactly 2 dimensional.  Fou...&apos; + ..., fail);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="15..?(271)"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="311" label="Project">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(215,5)"/>
                                    <att name="name" value="outMod"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(mod_to_nf(LEFT));&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="22"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="312" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(519,5)"/>
                                    <att name="name" value="nfNodesD"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="recordSize" value="22"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="313" label="Local Group">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(520,5)"/>
                                    <att name="name" value="nfNodesG"/>
                                    <att name="_kind" value="15"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="GROUP(wi, id, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaGrouping" value="wi, id"/>
                                    <att name="recordSize" value="22"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="314" label="Grouped Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(521,5)"/>
                                    <att name="name" value="nfNodesS"/>
                                    <att name="_kind" value="3"/>
                                    <att name="grouped" value="1"/>
                                    <att name="ecl" value="SORT(wi, id, number);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, id)"/>
                                    <att name="metaGrouping" value="wi, id"/>
                                    <att name="metaGroupSortOrder" value="wi, id, number"/>
                                    <att name="recordSize" value="22"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="315" label="Rollup Group">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(538,5)"/>
                                    <att name="name" value="nodes"/>
                                    <att name="_kind" value="97"/>
                                    <att name="grouped" value="1"/>
                                    <att name="ecl" value="ROLLUP(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...));&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="54"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="316" label="Split">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(538,14)"/>
                                    <att name="_kind" value="6"/>
                                    <att name="ecl" value="nodes;&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="54"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="317" label="Sort">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(97,1)"/>
                                    <att name="name" value="tn"/>
                                    <att name="_kind" value="3"/>
                                    <att name="ecl" value="SORT(wi, treeid, level, nodeid, number, depend);&#10;"/>
                                    <att name="metaDistribution" value="sorted(wi, treeid, level, nodeid, number, depend)"/>
                                    <att name="metaGlobalSortOrder" value="wi, treeid, level, nodeid, number, depend"/>
                                    <att name="metaLocalSortOrder" value="wi, treeid, level, nodeid, number, depend"/>
                                    <att name="recordSize" value="54"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="318" label="Project">
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="NEWTABLE({ unsigned2 wi := wi, unsigned2 level := level, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned8 parentid := parentid, boolean isleft := isleft, unsigned8 id := 0, unsigned4 number := number, real8 value := value, real8 depend := depend, unsigned8 support := support, boolean isordinal := isordinal });&#10;"/>
                                    <att name="metaDistribution" value="sorted(wi, treeid, level, nodeid, number, depend)"/>
                                    <att name="metaGlobalSortOrder" value="wi, treeid, level, nodeid, number, depend"/>
                                    <att name="metaLocalSortOrder" value="wi, treeid, level, nodeid, number, depend"/>
                                    <att name="recordSize" value="62"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="319" label="Output&#10;&apos;Tree&apos;">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(98,1)"/>
                                    <att name="_kind" value="16"/>
                                    <att name="ecl" value="OUTPUT(..., , named(&apos;Tree&apos;), workunit);&#10;"/>
                                    <att name="recordSize" value="62"/>
                                </node>
                                <node id="320" label="Project">
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10;  unsigned2 level;&#10;... END,...));&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="20"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="321" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::G&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="20"/>
                                    <att name="_fileName" value="~spill::G"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="322">
                        <att>
                            <graph>
                                <edge id="323_0" source="323" target="324"/>
                                <edge id="324_0" source="324" target="325"/>
                                <edge id="325_0" source="325" target="326"/>
                                <edge id="326_0" source="326" target="327"/>
                                <edge id="327_0" source="327" target="328"/>
                                <node id="323" label="Projected&#10;Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(538,5)"/>
                                    <att name="name" value="nodes"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::G&apos;, RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10;  unsigned2 level;&#10;... END, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="_fileName" value="~spill::G"/>
                                    <att name="_isSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="324" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(637,18)"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid, internal));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="325" label="Local Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(637,18)"/>
                                    <att name="_kind" value="3"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="SORT(wi, treeid, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                    <att name="metaLocalSortOrder" value="wi, treeid"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="326" label="Local Group">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(637,18)"/>
                                    <att name="_kind" value="15"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="GROUP(wi, treeid, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                    <att name="metaGrouping" value="wi, treeid"/>
                                    <att name="metaLocalSortOrder" value="wi, treeid"/>
                                    <att name="recordSize" value="8"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="327" label="Grouped Aggregate">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(637,5)"/>
                                    <att name="name" value="treeStats"/>
                                    <att name="_kind" value="10"/>
                                    <att name="grouped" value="1"/>
                                    <att name="ecl" value="TABLE({ unsigned2 wi := wi, integer8 nodecount := COUNT(group), unsigned2 depth := MAX(group, level) });&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="12"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="328" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::H&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="12"/>
                                    <att name="_fileName" value="~spill::H"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="329">
                        <att>
                            <graph>
                                <edge id="330_0" source="330" target="331"/>
                                <edge id="331_0" source="331" target="332"/>
                                <edge id="332_0" source="332" target="333"/>
                                <edge id="333_0" source="333" target="334"/>
                                <edge id="334_0" source="334" target="335"/>
                                <node id="330" label="Filtered&#10;Projected&#10;Spill Read">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,24)"/>
                                    <att name="_kind" value="195"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::G&apos;, RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10;  unsigned2 level;&#10;... END, THOR, __compressed__);&#10;FILTER(number = 0);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="16"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(538,5)"/>
                                    <att name="name" value="nodes"/>
                                    <att name="_fileName" value="~spill::G"/>
                                    <att name="_isTransformSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="331" label="Hash Distribute">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,18)"/>
                                    <att name="_kind" value="19"/>
                                    <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid, internal));&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                    <att name="recordSize" value="16"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="332" label="Local Sort">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,18)"/>
                                    <att name="_kind" value="3"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="SORT(wi, treeid, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                    <att name="metaLocalSortOrder" value="wi, treeid"/>
                                    <att name="recordSize" value="16"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="333" label="Local Group">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,18)"/>
                                    <att name="_kind" value="15"/>
                                    <att name="local" value="1"/>
                                    <att name="ecl" value="GROUP(wi, treeid, local);&#10;"/>
                                    <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                    <att name="metaGrouping" value="wi, treeid"/>
                                    <att name="metaLocalSortOrder" value="wi, treeid"/>
                                    <att name="recordSize" value="16"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="334" label="Grouped Aggregate">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,18)"/>
                                    <att name="_kind" value="10"/>
                                    <att name="grouped" value="1"/>
                                    <att name="ecl" value="TABLE({ unsigned2 wi := wi, integer8 nodecount := COUNT(group), integer8 _agg_3 := SUM(group, level), unsigned8 totsupt := SUM(group, support), unsigned8 maxsupt := MAX(group, support), unsigned2 mindepth := MIN(group, level) });&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="36"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="335" label="Spill Write">
                                    <att name="_kind" value="196"/>
                                    <att name="_internal" value="1"/>
                                    <att name="ecl" value="OUTPUT(..., , &apos;~spill::I&apos;, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="metaLocalSortOrder" value="wi"/>
                                    <att name="recordSize" value="36"/>
                                    <att name="_fileName" value="~spill::I"/>
                                    <att name="_isSpill" value="1"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                    <node id="336">
                        <att>
                            <graph>
                                <att name="rootGraph" value="1"/>
                                <edge id="337_0" source="337" target="338"/>
                                <edge id="339_0" source="339" target="340"/>
                                <edge id="338_0"
                                      label="LEFT"
                                      source="338"
                                      target="341"/>
                                <edge id="340_0"
                                      label="RIGHT"
                                      source="340"
                                      target="341">
                                    <att name="_targetIndex" value="1"/>
                                </edge>
                                <edge id="341_0" source="341" target="342"/>
                                <node id="337" label="Disk Grouped Aggregate&#10;Spill">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(643,17)"/>
                                    <att name="_kind" value="75"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::H&apos;, { unsigned2 wi, integer8 nodecount, unsigned2 depth }, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="46"/>
                                    <att name="predictedCount" value="0..?[few]"/>
                                    <att name="_fileName" value="~spill::H"/>
                                    <att name="_isTransformSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="338" label="Project">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(643,5)"/>
                                    <att name="name" value="treeSumm"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="NEWTABLE({ unsigned2 wi := wi, integer8 treecount := treecount, unsigned2 mintreedepth := mintreedepth, unsigned2 maxtreedepth := maxtreedepth, real8 avgtreedepth := (_agg_4 / treecount), integer8 mintreenodes := mintreenodes, integer8 maxtreenodes := maxtreenodes, real8 avgtreenodes := (_agg_7 / treecount), integer8 totalnodes := _agg_7 });&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="54"/>
                                    <att name="predictedCount" value="0..?[few]"/>
                                </node>
                                <node id="339" label="Disk Grouped Aggregate&#10;Spill">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(652,17)"/>
                                    <att name="_kind" value="75"/>
                                    <att name="ecl" value="DATASET(&apos;~spill::I&apos;, RECORD&#10;  unsigned2 wi;&#10;  integer8 nodecount;&#10;  integer8 _agg_3;&#10;  unsigned8 totsupt;&#10;... END, THOR, __compressed__);&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="60"/>
                                    <att name="predictedCount" value="0..?[few]"/>
                                    <att name="_fileName" value="~spill::I"/>
                                    <att name="_isTransformSpill" value="1"/>
                                    <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                    <att name="signedBy" value="hpcc"/>
                                </node>
                                <node id="340" label="Project">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(652,5)"/>
                                    <att name="name" value="leafSumm"/>
                                    <att name="_kind" value="7"/>
                                    <att name="ecl" value="NEWTABLE({ unsigned2 wi := wi, unsigned8 minsupport := minsupport, unsigned8 maxsupport := maxsupport, real8 avgsupport := (_agg_3 / _agg_4), real8 avgsupportperleaf := (_agg_3 / _agg_5), unsigned8 maxsupportperleaf := maxsupportperleaf, real8 avgleafdepth := (_agg_7 / _agg_4), unsigned2 minleafdepth := minleafdepth });&#10;"/>
                                    <att name="metaDistribution" value="unknown"/>
                                    <att name="recordSize" value="52"/>
                                    <att name="predictedCount" value="0..?[few]"/>
                                </node>
                                <node id="341" label="Join">
                                    <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(661,5)"/>
                                    <att name="name" value="allStats"/>
                                    <att name="_kind" value="155"/>
                                    <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned8 treecount;&#10;  unsigned8 mintreedepth;&#10;  unsigned8 maxtreedepth;&#10;... END,...));&#10;"/>
                                    <att name="recordSize" value="130"/>
                                    <att name="predictedCount" value="0..?[disk]"/>
                                </node>
                                <node id="342" label="Output&#10;&apos;ModelStats&apos;">
                                    <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(95,1)"/>
                                    <att name="_kind" value="16"/>
                                    <att name="ecl" value="OUTPUT(..., , named(&apos;ModelStats&apos;), workunit);&#10;"/>
                                    <att name="recordSize" value="130"/>
                                </node>
                            </graph>
                        </att>
                    </node>
                </graph>
            </xgmml>
        </Graph>
    </Graphs>
    <Process>
        <EclAgent>
            <myeclagent log="//10.0.0.209/var/log/HPCCSystems/myeclagent/eclagent.2021_06_29.log" pid="6199"/>
        </EclAgent>
    </Process>
    <Query fetchEntire="1" hasArchive="1" isArchive="1">
        <Associated>
            <File desc="Compiler log"
                  filename="/var/lib/HPCCSystems/myeclccserver/W20210629-061748.eclcc.log"
                  ip="10.0.0.209"
                  type="log"/>
            <File crc="-1719638775"
                  desc="Workunit DLL"
                  filename="/var/lib/HPCCSystems/myeclccserver/libW20210629-061748.so"
                  ip="10.0.0.209"
                  type="dll"/>
        </Associated>
        <ShortText>IMPORT LearningTrees AS LT;
            IMPORT ML_Core.Types AS CTypes;
            IMPORT LT.LT_Types AS Types;

            NumericField := CTypes.NumericField;
            DiscreteField := CTypes.DiscreteField;
            errorProb := 0;
            wiCount := 1;
            numTrainingRecs := 1000;
            numTestRecs := 1000;
            numTrees := 20;
            numVarsPerTree := 0;

            // Return TRUE with probability p
            prob(REAL p) := FUNCTION
            rnd := RANDOM() % 1000000 + 1;
            isTrue := IF(rnd / 1000000 &lt;= p, TRUE, FALSE);
            RETURN isTrue;
            END;

            // Test Pattern -- Ordinal variable X1 determines OP(X2, X3) =&gt; Y
            //                 OP (OR, AND, XOR, NOR), is determined as follows:
            //                 X1 &lt; -50 =&gt; OR(X2, X3); -50 &lt;= X1 &lt; 0 =&gt; AND(X2, X3);
            //                 0 &lt; X1 &lt;= 50 =&gt; XOR(X2, X3); X1 &gt;= 50 =&gt; NOR(X2, X3);

            dsRec := {UNSIGNED id, REAL X1, UNSIGNED X2, UNSIGNED X3, UNSIGNED Y};
            dsRec0 := {UNSIGNED id, UNSIGNED X1, UNSIGNED X2, UNSIGNED X3, UNSIGNED Y};
            dummy := DATASET([{0, 0, 0, 0, 0}], dsRec);
            dsRec make_data0(dsRec d, UNSIGNED c) := TRANSFORM
            SELF.id := c;
            // Pick random X1:  -100 &lt; X1 &lt; 100
            r1 := __COMMON__(RANDOM());
            r2 := __COMMON__(RANDOM());
            r3 := __COMMON__(RANDOM());
            SELF.X1 := r1%4;
            // Pick random X2 and X3: Choose val between 0 and 1 and round to 0 or 1.
            SELF.X2 := ROUND(r2%1000000 / 1000000);
            BOOLEAN x2B := SELF.X2=1;
            SELF.X3 := ROUND(r3%1000000 / 1000000);
            BOOLEAN x3B := SELF.X3=1;
            BOOLEAN y := MAP(SELF.X1 = 0 =&gt; x2B OR x3B, // OR
            SELF.X1 = 1 =&gt; x2B AND x3B, // AND
            SELF.X1 = 2 =&gt; (x2B OR x3B) AND (NOT (x2B AND x3B)), // XOR
            (NOT (x2B OR x3B)));  // NOR
            SELF.Y := IF(y, 1, 0);
            END;
            dsRec make_data(dsRec d, UNSIGNED c) := TRANSFORM
            SELF.id := c;
            // Pick random X1:  -100 &lt; X1 &lt; 100
            r1 := __COMMON__(RANDOM());
            r2 := __COMMON__(RANDOM());
            r3 := __COMMON__(RANDOM());
            SELF.X1 := ROUND(r1%1000000 / 10000 * 2 - 100);
            // Pick random X2 and X3: Choose val between 0 and 1 and round to 0 or 1.
            SELF.X2 := ROUND(r2%1000000 / 1000000);
            BOOLEAN x2B := SELF.X2=1;
            SELF.X3 := ROUND(r3%1000000 / 1000000);
            BOOLEAN x3B := SELF.X3=1;
            BOOLEAN y := MAP(SELF.X1 &lt; -50 =&gt; x2B OR x3B, // OR
            SELF.X1 &gt;= -50 AND SELF.X1 &lt; 0 =&gt; x2B AND x3B, // AND
            SELF.X1 &gt;= 0 AND SELF.X1 &lt; 50 =&gt; (x2B OR x3B) AND (NOT (x2B AND x3B)), // XOR
            (NOT (x2B OR x3B)));  // NOR
            SELF.Y := IF(y, 1, 0);
            END;
            ds := NORMALIZE(dummy, numTrainingRecs, make_data(LEFT, COUNTER));
            OUTPUT(ds, NAMED(&apos;TrainingData&apos;));

            X1 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 1,
            SELF.value := LEFT.X1));
            X2 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 2,
            SELF.value := LEFT.X2));
            X3 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 3,
            SELF.value := LEFT.X3));
            // Add noise to Y by randomly flipping the value according to PROBABILITY(errorProb).
            Y := PROJECT(ds, TRANSFORM(DiscreteField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 1,
            SELF.value := IF(prob(errorProb), (LEFT.Y + 1)%2, LEFT.Y)));
            nominals := [];
            X := X1 + X2 + X3;

            // Expand to number of work items
            Xe := NORMALIZE(X, wiCount, TRANSFORM(NumericField, SELF.wi := COUNTER, SELF := LEFT));
            Ye := NORMALIZE(Y, wiCount, TRANSFORM(DiscreteField, SELF.wi := COUNTER, SELF := LEFT));

            OUTPUT(Ye, NAMED(&apos;Y_train&apos;));

            F := LT.ClassificationForest(numTrees, numVarsPerTree);

            mod := F.GetModel(Xe, Ye);

            // With this line it runs fine.
            //mod := F.GetModel(X, Y, nominals);

            OUTPUT(mod, NAMED(&apos;Model&apos;));
            modStats := F.GetModelStats(mod);
            OUTPUT(modStats, NAMED(&apos;ModelStats&apos;));
            tn0 := F.Model2Nodes(mod);
            tn := SORT(tn0, wi, treeId, level, nodeid, id, number, depend);
            OUTPUT(tn, {wi, level, treeId, nodeId, parentId, isLeft, id, number, value, depend, support, isOrdinal},NAMED(&apos;Tree&apos;));

            //IMPORT ML_Core;
            //IMPORT ML_Core.Types;
            //IMPORT ML_Core.ModelOps2 as ModelOps2;
            //IMPORT LearningTrees as LT;
            //
            //classifications := DATASET(
            //       [{1, 1, 1, 0}, {1, 1, 2, 1},
            //        {1, 2, 1, 0}, {1, 2, 2, 1},
            //        {1, 3, 1, 0}, {1, 3, 2, 1},
            //        {1, 4, 1, 0}, {1, 4, 2, 1},
            //        {1, 5, 1, 0}, {1, 5, 2, 1},
            //        {1, 6, 1, 0}, {1, 6, 2, 1},
            //        {1, 7, 1, 1}, {1, 7, 2, 0},
            //        {1, 8, 1, 1}, {1, 8, 2, 0},
            //        {1, 9, 1, 1}, {1, 9, 2, 0},
            //        {2, 1, 1, 0}, {2, 1, 2, 1}, {2, 1, 3, 0},
            //        {2, 2, 1, 0}, {2, 2, 2, 1}, {2, 2, 3, 0},
            //        {2, 3, 1, 0}, {2, 3, 2, 1}, {2, 3, 3, 0},
            //        {2, 4, 1, 0}, {2, 4, 2, 0}, {2, 4, 3, 1},
            //        {2, 5, 1, 0}, {2, 5, 2, 0}, {2, 5, 3, 1},
            //        {2, 6, 1, 0}, {2, 6, 2, 0}, {2, 6, 3, 1},
            //        {2, 7, 1, 1}, {2, 7, 2, 0}, {2, 7, 3, 0},
            //        {2, 8, 1, 1}, {2, 8, 2, 0}, {2, 8, 3, 0},
            //        {2, 9, 1, 1}, {2, 9, 2, 0}, {2, 9, 3, 0},
            //        {3, 1, 1, 0},
            //        {3, 2, 1, 0},
            //        {3, 3, 1, 0},
            //        {3, 4, 1, 0},
            //        {3, 5, 1, 0},
            //        {3, 6, 1, 0},
            //        {3, 7, 1, 1},
            //        {3, 8, 1, 1},
            //        {3, 9, 1, 1}], Types.DiscreteField);
            //observations := DATASET(
            //    [{1, 1, 1, .6}, {1, 1, 2, .7}, {1, 1, 3, .8},
            //     {1, 2, 1, .8}, {1, 2, 2, .7}, {1, 2, 3, .7},
            //     {1, 3, 1, .7}, {1, 3, 2, .8}, {1, 3, 3, .6},
            //     {1, 4, 1, .9}, {1, 4, 2, .7}, {1, 4, 3, .9},
            //     {1, 5, 1, .8}, {1, 5, 2, .9}, {1, 5, 3, .6},
            //     {1, 6, 1, .8}, {1, 6, 2, .5}, {1, 6, 3, .8},
            //     {1, 7, 1, .2}, {1, 7, 2,  0}, {1, 7, 3, .3},
            //     {1, 8, 1, .3}, {1, 8, 2, .4}, {1, 8, 3, .4},
            //     {1, 9, 1, .4}, {1, 9, 2, .7}, {1, 9, 3,  0},
            //     {2, 1, 1, .9}, {2, 1, 2, .7}, {2, 1, 3, .8},
            //     {2, 2, 1, .8}, {2, 2, 2, .7}, {2, 2, 3, .7},
            //     {2, 3, 1, .7}, {2, 3, 2, .8}, {2, 3, 3, .9},
            //     {2, 4, 1, .6}, {2, 4, 2, .5}, {2, 4, 3, .6},
            //     {2, 5, 1, .6}, {2, 5, 2, .6}, {2, 5, 3, .6},
            //     {2, 6, 1, .6}, {2, 6, 2, .5}, {2, 6, 3, .5},
            //     {2, 7, 1, .2}, {2, 7, 2, .1}, {2, 7, 3, .3},
            //     {2, 8, 1, .3}, {2, 8, 2, .4}, {2, 8, 3, .4},
            //     {2, 9, 1, .4}, {2, 9, 2, .7}, {2, 9, 3, .3},
            //     {3, 1, 1, .6}, {3, 1, 2, .7}, {3, 1, 3, .8},
            //     {3, 2, 1, .8}, {3, 2, 2, .7}, {3, 2, 3, .7},
            //     {3, 3, 1, .7}, {3, 3, 2, .8}, {3, 3, 3, .6},
            //     {3, 4, 1, .9}, {3, 4, 2, .7}, {3, 4, 3, .9},
            //     {3, 5, 1, .8}, {3, 5, 2, .9}, {3, 5, 3, .6},
            //     {3, 6, 1, .8}, {3, 6, 2, .5}, {3, 6, 3, .8},
            //     {3, 7, 1, .2}, {3, 7, 2, .1}, {3, 7, 3, .3},
            //     {3, 8, 1, .3}, {3, 8, 2, .4}, {3, 8, 3, .4},
            //     {3, 9, 1, .4}, {3, 9, 2, .7}, {3, 9, 3, .3}], Types.NumericField);
            //
            //testData := DATASET([
            //    {1, 1, 1, .2},
            //    {1, 1, 2, .87}], Types.NumericField);
            //
            //
            //CF := LT.ClassificationForest().GetModel(observations, classifications);
            //
            //OUTPUT(&apos;ClassificationForest&apos;);
            //OUTPUT(CF);
            //OUTPUT(LR.LogitPredict(betas, testData));

            //matrix := DATASET([{1, 1, 1, 5},
            //    {1, 1, 2, 1},
            //    {1, 1, 3, 4},
            //    {1, 1, 4, 1},
            //    {1, 1, 5, 2},
            //    {1, 1, 6, 4},
            //    {1, 1, 7, 8}], Types.NumericField);
            //OUTPUT(linearRegression.Predict(matrix, model));</ShortText>
        <Text>&lt;Archive build=&quot;community_8.0.14-1&quot;
            eclVersion=&quot;8.0.14&quot;
            legacyImport=&quot;0&quot;
            legacyWhen=&quot;0&quot;&gt;
            &lt;Query attributePath=&quot;ECLDir.tmp_exec&quot;/&gt;
            &lt;Module key=&quot;ecldir&quot; name=&quot;ECLDir&quot;&gt;
            &lt;Attribute key=&quot;tmp_exec&quot;
            name=&quot;tmp_exec&quot;
            sourcePath=&quot;/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl&quot;
            ts=&quot;1624947466000000&quot;&gt;
            IMPORT LearningTrees AS LT;
            IMPORT ML_Core.Types AS CTypes;
            IMPORT LT.LT_Types AS Types;

            NumericField := CTypes.NumericField;
            DiscreteField := CTypes.DiscreteField;
            errorProb := 0;
            wiCount := 1;
            numTrainingRecs := 1000;
            numTestRecs := 1000;
            numTrees := 20;
            numVarsPerTree := 0;

            // Return TRUE with probability p
            prob(REAL p) := FUNCTION
            rnd := RANDOM() % 1000000 + 1;
            isTrue := IF(rnd / 1000000 &amp;lt;= p, TRUE, FALSE);
            RETURN isTrue;
            END;

            // Test Pattern -- Ordinal variable X1 determines OP(X2, X3) =&amp;gt; Y
            //                 OP (OR, AND, XOR, NOR), is determined as follows:
            //                 X1 &amp;lt; -50 =&amp;gt; OR(X2, X3); -50 &amp;lt;= X1 &amp;lt; 0 =&amp;gt; AND(X2, X3);
            //                 0 &amp;lt; X1 &amp;lt;= 50 =&amp;gt; XOR(X2, X3); X1 &amp;gt;= 50 =&amp;gt; NOR(X2, X3);

            dsRec := {UNSIGNED id, REAL X1, UNSIGNED X2, UNSIGNED X3, UNSIGNED Y};
            dsRec0 := {UNSIGNED id, UNSIGNED X1, UNSIGNED X2, UNSIGNED X3, UNSIGNED Y};
            dummy := DATASET([{0, 0, 0, 0, 0}], dsRec);
            dsRec make_data0(dsRec d, UNSIGNED c) := TRANSFORM
            SELF.id := c;
            // Pick random X1:  -100 &amp;lt; X1 &amp;lt; 100
            r1 := __COMMON__(RANDOM());
            r2 := __COMMON__(RANDOM());
            r3 := __COMMON__(RANDOM());
            SELF.X1 := r1%4;
            // Pick random X2 and X3: Choose val between 0 and 1 and round to 0 or 1.
            SELF.X2 := ROUND(r2%1000000 / 1000000);
            BOOLEAN x2B := SELF.X2=1;
            SELF.X3 := ROUND(r3%1000000 / 1000000);
            BOOLEAN x3B := SELF.X3=1;
            BOOLEAN y := MAP(SELF.X1 = 0 =&amp;gt; x2B OR x3B, // OR
            SELF.X1 = 1 =&amp;gt; x2B AND x3B, // AND
            SELF.X1 = 2 =&amp;gt; (x2B OR x3B) AND (NOT (x2B AND x3B)), // XOR
            (NOT (x2B OR x3B)));  // NOR
            SELF.Y := IF(y, 1, 0);
            END;
            dsRec make_data(dsRec d, UNSIGNED c) := TRANSFORM
            SELF.id := c;
            // Pick random X1:  -100 &amp;lt; X1 &amp;lt; 100
            r1 := __COMMON__(RANDOM());
            r2 := __COMMON__(RANDOM());
            r3 := __COMMON__(RANDOM());
            SELF.X1 := ROUND(r1%1000000 / 10000 * 2 - 100);
            // Pick random X2 and X3: Choose val between 0 and 1 and round to 0 or 1.
            SELF.X2 := ROUND(r2%1000000 / 1000000);
            BOOLEAN x2B := SELF.X2=1;
            SELF.X3 := ROUND(r3%1000000 / 1000000);
            BOOLEAN x3B := SELF.X3=1;
            BOOLEAN y := MAP(SELF.X1 &amp;lt; -50 =&amp;gt; x2B OR x3B, // OR
            SELF.X1 &amp;gt;= -50 AND SELF.X1 &amp;lt; 0 =&amp;gt; x2B AND x3B, // AND
            SELF.X1 &amp;gt;= 0 AND SELF.X1 &amp;lt; 50 =&amp;gt; (x2B OR x3B) AND (NOT (x2B AND x3B)), // XOR
            (NOT (x2B OR x3B)));  // NOR
            SELF.Y := IF(y, 1, 0);
            END;
            ds := NORMALIZE(dummy, numTrainingRecs, make_data(LEFT, COUNTER));
            OUTPUT(ds, NAMED(&amp;apos;TrainingData&amp;apos;));

            X1 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 1,
            SELF.value := LEFT.X1));
            X2 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 2,
            SELF.value := LEFT.X2));
            X3 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 3,
            SELF.value := LEFT.X3));
            // Add noise to Y by randomly flipping the value according to PROBABILITY(errorProb).
            Y := PROJECT(ds, TRANSFORM(DiscreteField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 1,
            SELF.value := IF(prob(errorProb), (LEFT.Y + 1)%2, LEFT.Y)));
            nominals := [];
            X := X1 + X2 + X3;

            // Expand to number of work items
            Xe := NORMALIZE(X, wiCount, TRANSFORM(NumericField, SELF.wi := COUNTER, SELF := LEFT));
            Ye := NORMALIZE(Y, wiCount, TRANSFORM(DiscreteField, SELF.wi := COUNTER, SELF := LEFT));

            OUTPUT(Ye, NAMED(&amp;apos;Y_train&amp;apos;));

            F := LT.ClassificationForest(numTrees, numVarsPerTree);

            mod := F.GetModel(Xe, Ye);

            // With this line it runs fine.
            //mod := F.GetModel(X, Y, nominals);

            OUTPUT(mod, NAMED(&amp;apos;Model&amp;apos;));
            modStats := F.GetModelStats(mod);
            OUTPUT(modStats, NAMED(&amp;apos;ModelStats&amp;apos;));
            tn0 := F.Model2Nodes(mod);
            tn := SORT(tn0, wi, treeId, level, nodeid, id, number, depend);
            OUTPUT(tn, {wi, level, treeId, nodeId, parentId, isLeft, id, number, value, depend, support, isOrdinal},NAMED(&amp;apos;Tree&amp;apos;));

            //IMPORT ML_Core;
            //IMPORT ML_Core.Types;
            //IMPORT ML_Core.ModelOps2 as ModelOps2;
            //IMPORT LearningTrees as LT;
            //
            //classifications := DATASET(
            //       [{1, 1, 1, 0}, {1, 1, 2, 1},
            //        {1, 2, 1, 0}, {1, 2, 2, 1},
            //        {1, 3, 1, 0}, {1, 3, 2, 1},
            //        {1, 4, 1, 0}, {1, 4, 2, 1},
            //        {1, 5, 1, 0}, {1, 5, 2, 1},
            //        {1, 6, 1, 0}, {1, 6, 2, 1},
            //        {1, 7, 1, 1}, {1, 7, 2, 0},
            //        {1, 8, 1, 1}, {1, 8, 2, 0},
            //        {1, 9, 1, 1}, {1, 9, 2, 0},
            //        {2, 1, 1, 0}, {2, 1, 2, 1}, {2, 1, 3, 0},
            //        {2, 2, 1, 0}, {2, 2, 2, 1}, {2, 2, 3, 0},
            //        {2, 3, 1, 0}, {2, 3, 2, 1}, {2, 3, 3, 0},
            //        {2, 4, 1, 0}, {2, 4, 2, 0}, {2, 4, 3, 1},
            //        {2, 5, 1, 0}, {2, 5, 2, 0}, {2, 5, 3, 1},
            //        {2, 6, 1, 0}, {2, 6, 2, 0}, {2, 6, 3, 1},
            //        {2, 7, 1, 1}, {2, 7, 2, 0}, {2, 7, 3, 0},
            //        {2, 8, 1, 1}, {2, 8, 2, 0}, {2, 8, 3, 0},
            //        {2, 9, 1, 1}, {2, 9, 2, 0}, {2, 9, 3, 0},
            //        {3, 1, 1, 0},
            //        {3, 2, 1, 0},
            //        {3, 3, 1, 0},
            //        {3, 4, 1, 0},
            //        {3, 5, 1, 0},
            //        {3, 6, 1, 0},
            //        {3, 7, 1, 1},
            //        {3, 8, 1, 1},
            //        {3, 9, 1, 1}], Types.DiscreteField);
            //observations := DATASET(
            //    [{1, 1, 1, .6}, {1, 1, 2, .7}, {1, 1, 3, .8},
            //     {1, 2, 1, .8}, {1, 2, 2, .7}, {1, 2, 3, .7},
            //     {1, 3, 1, .7}, {1, 3, 2, .8}, {1, 3, 3, .6},
            //     {1, 4, 1, .9}, {1, 4, 2, .7}, {1, 4, 3, .9},
            //     {1, 5, 1, .8}, {1, 5, 2, .9}, {1, 5, 3, .6},
            //     {1, 6, 1, .8}, {1, 6, 2, .5}, {1, 6, 3, .8},
            //     {1, 7, 1, .2}, {1, 7, 2,  0}, {1, 7, 3, .3},
            //     {1, 8, 1, .3}, {1, 8, 2, .4}, {1, 8, 3, .4},
            //     {1, 9, 1, .4}, {1, 9, 2, .7}, {1, 9, 3,  0},
            //     {2, 1, 1, .9}, {2, 1, 2, .7}, {2, 1, 3, .8},
            //     {2, 2, 1, .8}, {2, 2, 2, .7}, {2, 2, 3, .7},
            //     {2, 3, 1, .7}, {2, 3, 2, .8}, {2, 3, 3, .9},
            //     {2, 4, 1, .6}, {2, 4, 2, .5}, {2, 4, 3, .6},
            //     {2, 5, 1, .6}, {2, 5, 2, .6}, {2, 5, 3, .6},
            //     {2, 6, 1, .6}, {2, 6, 2, .5}, {2, 6, 3, .5},
            //     {2, 7, 1, .2}, {2, 7, 2, .1}, {2, 7, 3, .3},
            //     {2, 8, 1, .3}, {2, 8, 2, .4}, {2, 8, 3, .4},
            //     {2, 9, 1, .4}, {2, 9, 2, .7}, {2, 9, 3, .3},
            //     {3, 1, 1, .6}, {3, 1, 2, .7}, {3, 1, 3, .8},
            //     {3, 2, 1, .8}, {3, 2, 2, .7}, {3, 2, 3, .7},
            //     {3, 3, 1, .7}, {3, 3, 2, .8}, {3, 3, 3, .6},
            //     {3, 4, 1, .9}, {3, 4, 2, .7}, {3, 4, 3, .9},
            //     {3, 5, 1, .8}, {3, 5, 2, .9}, {3, 5, 3, .6},
            //     {3, 6, 1, .8}, {3, 6, 2, .5}, {3, 6, 3, .8},
            //     {3, 7, 1, .2}, {3, 7, 2, .1}, {3, 7, 3, .3},
            //     {3, 8, 1, .3}, {3, 8, 2, .4}, {3, 8, 3, .4},
            //     {3, 9, 1, .4}, {3, 9, 2, .7}, {3, 9, 3, .3}], Types.NumericField);
            //
            //testData := DATASET([
            //    {1, 1, 1, .2},
            //    {1, 1, 2, .87}], Types.NumericField);
            //
            //
            //CF := LT.ClassificationForest().GetModel(observations, classifications);
            //
            //OUTPUT(&amp;apos;ClassificationForest&amp;apos;);
            //OUTPUT(CF);
            //OUTPUT(LR.LogitPredict(betas, testData));

            //matrix := DATASET([{1, 1, 1, 5},
            //    {1, 1, 2, 1},
            //    {1, 1, 3, 4},
            //    {1, 1, 4, 1},
            //    {1, 1, 5, 2},
            //    {1, 1, 6, 4},
            //    {1, 1, 7, 8}], Types.NumericField);
            //OUTPUT(linearRegression.Predict(matrix, model));
            &lt;/Attribute&gt;
            &lt;/Module&gt;
            &lt;Module key=&quot;&quot; name=&quot;&quot;&gt;
            &lt;Attribute key=&quot;learningtrees&quot;
            name=&quot;LearningTrees&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/LearningTrees.ecl&quot;
            ts=&quot;1621960364000000&quot;&gt;
            IMPORT _versions.LearningTrees.V1_1_1.LearningTrees as _LearningTrees; EXPORT LearningTrees := _LearningTrees;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;ml_core&quot;
            name=&quot;ML_Core&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/ML_Core.ecl&quot;
            ts=&quot;1621960337000000&quot;&gt;
            IMPORT _versions.ML_Core.V3_2_2.ML_Core as _ML_Core; EXPORT ML_Core := _ML_Core;
            &lt;/Attribute&gt;
            &lt;/Module&gt;
            &lt;Module key=&quot;_versions&quot; name=&quot;_versions&quot;/&gt;
            &lt;Module key=&quot;_versions.learningtrees&quot; name=&quot;_versions.LearningTrees&quot;/&gt;
            &lt;Module key=&quot;_versions.learningtrees.v1_1_1&quot; name=&quot;_versions.LearningTrees.V1_1_1&quot;/&gt;
            &lt;Module key=&quot;_versions.learningtrees.v1_1_1.learningtrees&quot; name=&quot;_versions.LearningTrees.V1_1_1.LearningTrees&quot;&gt;
            &lt;Attribute key=&quot;lt_types&quot;
            name=&quot;LT_Types&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LT_Types.ecl&quot;
            ts=&quot;1621960363000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
            ############################################################################## */
            IMPORT $ AS LT;
            IMPORT ML_core;
            IMPORT ML_core.Types as CTypes;

            t_Work_Item := CTypes.t_Work_Item;
            t_Count := CTypes.t_Count;
            t_RecordId := CTypes.t_RecordID;
            t_FieldNumber := CTypes.t_FieldNumber;
            t_FieldReal := CTypes.t_FieldReal;
            t_Discrete := CTypes.t_Discrete;
            t_TreeId := t_FieldNumber;
            Layout_Model := CTypes.Layout_Model;
            DiscreteField := CTypes.DiscreteField;
            NumericField := CTypes.NumericField;
            Field_Mapping := CTypes.Field_Mapping;
            t_index := CTypes.t_index;

            /**
            * Type definition module for Learning Trees.
            */
            EXPORT LT_Types := MODULE
            /**
            * Type definition for the node id field representing a tree node&amp;apos;s id
            */
            EXPORT t_NodeId := UNSIGNED8;
            /**
            * Definition of the meaning of the indexes of the Forest Model variables.
            * &amp;lt;p&amp;gt;Ind1 enumerates the first index, which
            * is used to determine which type of data is stored:&amp;lt;ul&amp;gt;
            * &amp;lt;li&amp;gt;nodes stores the list of tree nodes that describes the forest.
            *         The second index is just the sequential number of the node
            *         The third index is enumerated below (see Ind3_nodes).&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;samples stores the set of sample indexes (i.e. ids) associated
            *         with each treeId.
            *         The second index represents the treeId.  The third index
            *         represents the sample number. The value is the id of the
            *         sample in the original training dataset.
            *         {samples, treeId, sampleNum} -&amp;gt; origId.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;classWeights (ClassificationForest only) stores the weights associated
            *         with each class label.  The second index represents the class
            *         label.  The value is the weight.  {classWeights, classLabel} -&amp;gt; weight.
            *         Class weights are only stored for Classification Forests.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
            */
            EXPORT Forest_Model := MODULE
            /**
            * Index 1 represents the category of data within the model
            *
            * @value reserved = 1.  Reserved for future use.
            * @value nodes = 2.  The set of tree nodes within the model.
            * @value samples = 3. The particular record ids that are included in tree&amp;apos;s sample .
            * @value classWeights = 4.  The weights assigned to each class (for ClassificationForest only).
            */
            EXPORT Ind1 := MODULE
            EXPORT t_index reserved := 1; // Reserved for future use
            EXPORT t_index nodes := 2;
            EXPORT t_index samples := 3;
            EXPORT t_index classWeights := 4;
            END;
            /**
            * For tree node data (i.e. Ind1 = nodes), the following
            * constant definitions are used for the different fields
            * of the tree-node.
            * Note that Ind1 indicates tree nodes, Ind2 represents the different nodes
            * and Ind3 defines the different fields.  For example, the treeId for the
            * first node would be stored at [2,1,1].  These correspond to the persisted
            * fields of TreeNodeDat with similar names.
            *
            * @value treeID = 1.  The tree identifier.
            * @value level = 2.  The level of the node within the tree.
            * @value nodeId = 3.  The nodeId of this node within the tree.
            * @value parentId = 4.  The parent node&amp;apos;s nodeId.
            * @value isLeft = 5.  Left / Right indicator of this node within it&amp;apos;s parent&amp;apos;s chilren.
            * @value number = 6.  The field number to split on.
            * @value value = 7.  The value to compare against.
            * @value isOrd = 8.  Indicator of ordered vs categorical data.
            * @value depend = 9.  The value to predict for samples in this leaf.
            * @value support = 10.  The number of datapoints from the training data that reached
            *                       this node.
            * @value if = 11.  The &amp;apos;impurity reduction&amp;apos; achieved by this branch.
            *
            */
            EXPORT Ind3_Nodes := MODULE
            EXPORT t_index treeId := 1;
            EXPORT t_index level := 2;
            EXPORT t_index nodeId := 3;
            EXPORT t_index parentId := 4;
            EXPORT t_index isLeft := 5;
            EXPORT t_index number := 6;
            EXPORT t_index value := 7;
            EXPORT t_index isOrd := 8;
            EXPORT t_index depend := 9;
            EXPORT t_index support := 10;
            EXPORT t_index ir := 11;
            END;
            END;

            /**
            * Definition of the meaning of the indexes of the Gradient Boosting Model variables.
            * &amp;lt;p&amp;gt;Ind1 enumerates the first index, which
            * is used to determine which type of data is stored:&amp;lt;ul&amp;gt;
            * &amp;lt;li&amp;gt;fModels stores the list of forest models that comprise the boosting
            *         hierarchy.  Each of these models can be decomposed by the Forest
            *         learning modules.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;Other values are reserved for future use.
            */
            EXPORT Bf_Model := MODULE
            /**
            * Index 1 represents the category of data within the model
            *
            * @value reserved = 1.  Reserved for future use.
            * @value fModels = 2.  The set of forest models that comprise the boosting
            *                       hierarchy.
            */
            EXPORT Ind1 := MODULE
            EXPORT t_index reserved := 1; // Reserved for future use
            EXPORT t_index fModels := 2;
            END;
            END;

            /**
            * GenField extends NumericField by adding an isOrdinal field.  This
            * allows both Ordered and Nominal (Categorical) data to be held by the same record type.
            *
            * @field wi The work-item identifier for this cell.
            * @field id The record-identifier for this cell.
            * @field number The field number (i.e. featureId) of this cell.
            * @field value The numerical value of this cell.
            * @field isOrdinal TRUE if this field represents ordered data.  FALSE if it is categorical.
            * @see ML_Core.Types.NumericField.
            */
            EXPORT GenField := RECORD(NumericField)
            Boolean isOrdinal;
            END;


            /**
            * &amp;lt;p&amp;gt;This is the major working structure for building the forest.
            * &amp;lt;p&amp;gt;For efficiency and uniformity, this record structure serves several purposes
            * as the forest is built:
            * &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;It represents all of the X,Y data associated with each tree and node as the
            *   forest is being built.  This case is recognized by id &amp;gt; 0 (i.e. it is a data point).
            *   wi, treeId, level, and NodeId represent the work-item and tree node with which the data is currently
            *         associated.
            *         All data in a tree&amp;apos;s sample is originally assigned to the tree&amp;apos;s root node (level = 1, nodeId = 1).
            *   &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;id is the sample index in this trees data bootstrap sample.&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;origId is the sample index in the original Independent(X) data.&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;number is the field number from the X data.&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;isOrdinal indicates whether this data is Ordinal (true) or Nominal (false).&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;value is the data value of this data point.&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;depend is the Dependent (Y) value associated with this data point.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;It represents the skeleton of the tree as the tree is built from the root down
            *   and the data points are subsumed (summarized) by the evolving tree structure.
            *   These cases can be identified by id = 0.&amp;lt;ul&amp;gt;
            *   &amp;lt;li&amp;gt;It represents branch (split) nodes:&amp;lt;ul&amp;gt;
            *       &amp;lt;li&amp;gt;id = 0 -- All data was subsumed.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;number &amp;gt; 0 -- The original field number of the Independent(X) variable on which to split.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;value -- the value on which to split&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;parentId -- The nodeId of the branch at the previous level that leads to this
            *                   node.  Zero only for root.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;level -- The distance from the root (root = 1).&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;support -- The number of data points that reach this node.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;ir -- The impurity reduction for this split.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;It represents leaf nodes:&amp;lt;ul&amp;gt;
            *       &amp;lt;li&amp;gt;id = 0 -- All data was subsumed.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;number = 0 -- This discriminates a leaf from a branch node.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;depend has the Y value for that leaf.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;parentId has the nodeId of the branch node at the previous level.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;support has the count of samples that reached this leaf.&amp;lt;/li&amp;gt;
            *       &amp;lt;li&amp;gt;level -- The depth of the node in the tree (root = 1).&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
            * &amp;lt;p&amp;gt;Each tree starts with all sampled data points assigned to the root node (i.e. level = 1, nodeId = 1)
            * As the trees grow, data points are assigned to deeper branches, and eventually to leaf nodes, where
            * they are ultimately subsumed (summarized) and removed from the dataset.
            * &amp;lt;p&amp;gt;At the end of the forest growing process only the tree skeleton remains -- all the datapoints having
            * been summarized by the resulting branch and leaf nodes.
            * @field treeId The unique id of the tree in the forest.
            * @field nodeId The id of this node within the tree.
            * @field parentId The node id of this node&amp;apos;s parent.
            * @field isLeft Indicates whether this node is the left child or the right child of the parent.
            * @field wi The work item with which this record is associated.
            * @field id The record id of the sample during tree construction.  Will be zero once the record has
            *           been replaced by a skeleton node (i.e. branch or leaf).
            * @field number The field number on which the branch splits
            * @field value The value of the data field, or the splitValue for a branch node.
            * @field level The level of the node within its tree.  Root is 1.
            * @field origId The sample index (id) of the original X data that this sample came from.
            * @field depend The dependent value associated with this id.
            * @field support The number of data samples subsumed by this node.
            * @field ir The &amp;apos;impurity&amp;apos; reduction achieved by this branch.
            * @field observWeight The observation weight associated with this observation.
            */
            EXPORT TreeNodeDat := RECORD
            t_TreeID treeId;
            t_NodeID nodeId;
            t_NodeID parentId;
            BOOLEAN  isLeft;             // If true, this is the parent&amp;apos;s left split
            GenField;                    // Instance Independent Data - one attribute
            UNSIGNED2     level;         // Level of the node in tree.  Root is 1.
            t_Discrete    origId;        // The sample index (id) of the original X data that this sample came from
            t_FieldReal   depend;        // Instance Dependent value
            t_RecordId   support:=0;    // Number of data samples subsumed by this node
            t_FieldReal  ir:=0;            // Impurity reduction at this node (branches only)
            t_FieldReal  observWeight:=1; // Weight assigned to this observation
            END;

            /**
            * Main data structure for processing Boosted Forest.
            * &amp;lt;p&amp;gt;The structure is the same as for random forests, but with an extra
            * field gbLevel that represents the level of the gradient boosted forest
            * nodes within the boosting hierarchy.
            * &amp;lt;p&amp;gt;Each set of nodes representing a forest is organized hierarchically based
            * on that field.
            * &amp;lt;p&amp;gt;Each level of the Boosted Forest contains a random forest.  The
            * results from each random forest are added together to get the final result
            * for the GBF.
            */
            EXPORT BfTreeNodeDat := RECORD(TreeNodeDat)
            UNSIGNED2 bfLevel;
            END;
            /**
            * The probability that a given sample is of a given class
            *
            * @field wi The work-item identifier.
            * @field id The record-id of the sample.
            * @field class The class label.
            * @field cnt The number of trees that predicted this class label.
            * @field prob The percentage of trees that assigned this class label,
            *             which is a rough stand-in for the probability that the label
            *             is correct.
            */
            EXPORT ClassProbs := RECORD
            t_Work_Item wi;  // Work-item id
            t_RecordID id;  // Sample identifier
            t_Discrete class; // The class label
            t_Discrete cnt; // The number of trees that assigned this class label
            t_FieldReal prob; // The percentage of trees that assigned this class label
            // which is a rough stand-in for the probability that the
            // label is correct.
            END;

            /**
            * NodeSummary provides information to identify a given tree node
            *
            * @field wi The work-item id for this node.
            * @field treeId The tree identifier within this work-item.
            * @field nodeId The node within the tree and work-item.
            * @field parentId The nodeId of this nodes parent node.
            * @field isLeft Boolean indicator of whether this is the Left child (TRUE) or
            *         Right child (FALSE) of the parent.
            * @field support The number of data samples that reached this node.
            */
            EXPORT NodeSummary := RECORD
            t_Work_Item wi;
            t_TreeID treeId;
            t_NodeID nodeId;
            t_NodeID parentId;     // Note that for any given (wi, treeId, nodeId), parentId and isLeft
            //   will be constant, but we need to carry them through to maintain
            //   the integrity of the nodes&amp;apos; relationships.
            BOOLEAN isLeft:=True;
            t_RecordId support;   // The number of data samples reaching this node.
            END;
            /**
            * SplitDat is used to hold information about a potential split.
            * It is based on the NodeSummary record type above.  It adds the following fields
            *
            * @field number The field number of the Independent data that is being used to split.
            * @field splitVal The value by which to split the data.
            * @field isOrdinal TRUE indicates that it is an ordered value and will use a
            *                  greater-than-or-equal split (i.e. value &amp;gt;= splitVal).
            *                  FALSE indicates that the values are nominal
            *                  (i.e. categorical) and will use an equal-to split (i.e. value = splitVal)
            */
            EXPORT SplitDat := RECORD(NodeSummary)
            t_FieldNumber number;  // This is the field number that is being split
            t_FieldReal splitVal;  // This is the value at which to split &amp;lt;= splitval =&amp;gt; LEFT &amp;gt;splitval
            // =&amp;gt; right
            BOOLEAN isOrdinal;     // We need to carry this along
            t_FieldReal ir;        // Impurity reduction at this split
            END;

            /**
            * NodeImpurity carries identifying information for a node as well as its impurity level
            * It is based on the NodeSummary record type above, but includes an assessment of the
            * &amp;apos;impurity&amp;apos; of the data at this node (i.e. GINI, Variance, Entropy).
            *
            * @field impurity The level of impurity at the given node.  Zero is most pure.
            */
            EXPORT NodeImpurity := RECORD(NodeSummary)
            t_FieldReal impurity;  // The level of impurity of the given node.  Zero is most pure.
            END;

            /**
            * Provides a summary of each work item for use in building the forest.
            *
            * @field wi The work-item identifier.
            * @field numSamples The number of samples within this work-item
            * @field numFeatures The number of features (i.e. number fields in the Independent
            *                    data for this work-item.
            * @field featuresPerNode The number of features to be randomly chosen at each level
            *                         of tree building.  It is a function of, the user parameter
            *                         &amp;apos;featuresPerNode&amp;apos; and the number of features in the work-item
            *                         numFeatures.
            */
            EXPORT wiInfo := RECORD
            t_Work_Item   wi;               // Work-item Id
            t_RecordId    numSamples;       // Number of samples for this wi&amp;apos;s data
            t_FieldNumber numFeatures;      // Number of features for this wi&amp;apos;s data
            t_Count       featuresPerNode;  // Features per node may be different for each work-item
            //   because it is based on numFeatures as well as the
            //   featuresPerNodeIn parameter to the module.
            END;
            /**
            * Model Statistics Record
            *
            * Provides descriptive information about a Model
            *
            * @field wi The work-item whose model is described
            * @field treeCount The number of trees in the forest
            * @field minTreeDepth The depth of the shallowest tree
            * @field maxTreeDepth The depth of the deepest tree
            * @field avgTreeDepth The average depth of all trees
            * @field minTreeNodes The number of nodes in the smallest tree
            * @field maxTreeNodes The number of nodes in the biggest tree
            * @field avgTreeNodes The average number of nodes for all trees
            * @field totalNodes The number of nodes in the forest
            * @field minSupport The minimum sum of support for all trees.
            *                   Support indicates the number of training datapoints
            *                   that arrived at a given leaf node
            * @field maxSupport The maximum sum of support for all trees
            * @field agvSupport The average sum of support for all trees
            * @field avgSupportPerLeaf The average number of data points per
            *                     leaf across the forest
            * @field maxSupportPerLeaf The maximum data points at any single
            *                     leaf across the forest
            * @field avgLeafDepth The average depth for all leaf nodes
            *                     for all trees
            * @field minLeafDepth The minimum depth for all leaf nodes
            *                     for all trees
            */
            EXPORT ModelStats := RECORD
            t_Work_Item wi;
            UNSIGNED treeCount;
            UNSIGNED minTreeDepth;
            UNSIGNED maxTreeDepth;
            REAL avgTreeDepth;
            UNSIGNED minTreeNodes;
            UNSIGNED maxTreeNodes;
            REAL avgTreeNodes;
            UNSIGNED totalNodes;
            UNSIGNED minSupport;
            UNSIGNED maxSupport;
            REAL avgSupport;
            REAL avgSupportPerLeaf;
            UNSIGNED maxSupportPerLeaf;
            REAL avgLeafDepth;
            UNSIGNED minLeafDepth;
            UNSIGNED bfLevel := 1;
            END; // ModelStats
            /**
            * Feature Importance Record
            * describes the importance of each feature.
            * @field wi The work-item associated with this information.
            * @field number The feature number.
            * @field importance The &amp;apos;importance&amp;apos; metric.  Higher value is more
            *                   important.
            * @field uses The number of times the feature was used in the forest.
            */
            EXPORT FeatureImportanceRec := RECORD
            t_Work_Item wi;
            t_FieldNumber number;
            t_FieldReal importance;
            UNSIGNED uses;
            END;

            /**
            * ClassWeightsRecord holds the weights associated with each
            * class label.
            *
            * @field wi The work-item.
            * @field classLabel The subject class label.
            * @field weight The weight associated with this class label.
            **/
            EXPORT ClassWeightsRec := RECORD
            t_work_item wi;
            t_Discrete classLabel;
            t_FieldReal weight;
            END;

            /**
            * Structure used to describe the Scorecards for LUCI format export.
            *
            * For a single scorecard model, a single LUCI_Scorecard record is used.
            * For multiple scorecards, one record is required per scorecard.
            * One L2SC or L2FO record will be generated per scorecard, and additionally
            * One L2SE record will be generated for each scorecard with a non-blank
            * &amp;apos;filter_expr&amp;apos;.
            *
            * @field wi_num The work-item number on which to base this scorecard or &amp;apos;1&amp;apos; if only one
            *               work-item / scorecard us used.
            * @field scorecard_name The LUCI name for this scorecard.
            * @field filter_expr Optional -- An expression on the LUCI input dataset layout that selects
            *                    the records to be included in this scorecard (e.g. &amp;apos;state_id = 2&amp;apos;).
            *                    If the expression contains strings, the single-quotes must be preceded
            *                    by a backslash escape character (e.g. &amp;apos;state = \&amp;apos;NY\&amp;apos;&amp;apos;).
            *                    The filter expression must follow ECL Boolean expression syntax.
            *                    It should be blank if all records are to be used.  See L2SE LUCI
            *                    record format, Scorecard-Election-Criteria for more details.
            * @field fieldMap    A DATASET(Field_Mapping) as returned from the FromField macro that maps the Field Names
            *                    (as used in the LUCI definition) to the field numbers (as used in the ML model).
            *                    Note: must be the same set of fields used in training the forest for this work item.
            */
            EXPORT LUCI_Scorecard := RECORD
            UNSIGNED wi_num := 1;
            STRING scorecard_name;
            STRING filter_expr := &amp;apos;&amp;apos;;
            DATASET(Field_Mapping) fieldMap;
            END;
            END; // LT_Types&amp;#10;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;classificationforest&quot;
            name=&quot;ClassificationForest&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/ClassificationForest.ecl&quot;
            ts=&quot;1621960363000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
            ############################################################################## */
            IMPORT $ AS LT;
            IMPORT LT.LT_Types AS Types;
            IMPORT ML_Core;
            IMPORT ML_Core.Types as CTypes;
            IMPORT ML_Core.interfaces AS Interfaces;
            IMPORT LT.internal AS int;

            NumericField := CTypes.NumericField;
            DiscreteField := CTypes.DiscreteField;
            Layout_Model2 := CTypes.Layout_Model2;
            TreeNodeDat := Types.TreeNodeDat;
            t_Discrete := CTypes.t_Discrete;
            t_Work_Item := CTypes.t_Work_Item;
            t_RecordID := CTypes.t_RecordId;
            ClassProbs := Types.ClassProbs;
            IClassify2 := Interfaces.IClassify2;


            /**
            * Classification using Random Forest algorithm.
            * &amp;lt;p&amp;gt;This module implements Random Forest classification as described by
            * Breiman, 2001 with extensions.
            * (see https://www.stat.berkeley.edu/~breiman/randomforest2001.pdf)
            *
            * &amp;lt;p&amp;gt;Random Forests provide a very effective method for classification
            * with few assumptions about the nature of the data.  They are known
            * to be one of the best out-of-the-box methods as there are few assumptions
            * made regarding the nature of the data or its relationship to classes.
            * Random Forests can effectively manage large numbers
            * of features, and will automatically choose the most relevant features.
            * Random Forests inherently support multi-class problems.  Any number of
            * class labels can be used.
            *
            * &amp;lt;p&amp;gt;This implementation supports both Numeric (discrete or continuous) and
            * Nominal (unordered categorical values) for the independent (X) features.
            * There is therefore, no need to one-hot encode categorical features.
            * Nominal features should be identified by including their feature &amp;apos;number&amp;apos;
            * in the set of &amp;apos;nominalFields&amp;apos; in GetModel.
            *
            * &amp;lt;p&amp;gt;RegressionForest supports the Myriad interface meaning that multiple
            * independent models can be computed with a single call (see ML_Core.Types
            * for information on using the Myriad feature).
            *
            * &amp;lt;p&amp;gt;Notes on use of NumericField and DiscreteField layouts:
            * &amp;lt;ul&amp;gt;
            * &amp;lt;li&amp;gt;Work-item ids (&amp;apos;wi&amp;apos; field) are not required to be sequential, though they must be positive
            *   numbers.  It is a good practice to assign wi = 1 when only one work-item is used.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;Record Ids (&amp;apos;id&amp;apos; field) are not required to be sequential, though slightly faster performance
            *   will result if they are sequential (i.e. 1 .. numRecords) for each work-item.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;Feature numbers (&amp;apos;number&amp;apos; field) are not required to be sequential, though slightly faster
            *   performance will result if they are (i.e. 1 .. numFeatures) for each work-item.&amp;lt;/li&amp;gt;
            * &amp;lt;/ul&amp;gt;
            *
            * @param numTrees The number of trees to create in the forest for each work-item.
            *                 This defaults to 100, which is adequate for most cases.  Increasing
            *                 this parameter generally results in less variance in accuracy between
            *                 runs, at the expense of greater run time.
            * @param featuresPerNode The number of features to choose among at each split in
            *                 each tree.  This number of features will be chosen at random
            *                 from the full set of features.  The default (0) uses the square
            *                 root of the number of features provided, which works well
            *                 for most cases.
            * @param maxDepth The deepest to grow any tree in the forest.  The default is
            *                 100, which is adequate for most purposes.  Increasing this value
            *                 for very large and complex problems my provide slightly greater
            *                 accuracy at the expense of much greater runtime.
            * @param nominalFields An optional set of field &amp;apos;numbers&amp;apos; that represent Nominal (i.e. unordered,
            *                      categorical) values.  Specifying the nominal fields improves run-time
            *                      performance on these fields and may improve accuracy as well.  Binary fields
            *                      (fields with only two values) need not be included here as they can be
            *                      considered either ordinal or nominal.  The default is to treat all fields as
            *                      ordered.
            *                      Note that this feature should only be used if all of the independent
            *                      data for all work-items use the same record format, and therefore have the same
            *                      set of nominal fields.
            * @param balanceClasses An optional Boolean parameter.  If true, it indicates that the voting among
            *                       trees should be biased inversely to the frequency of the class for which it
            *                       is voting.  This may help in scenarios where there are far more samples of
            *                       certain classes than of others.  The default is to not balance (i.e. FALSE).
            */
            EXPORT ClassificationForest(UNSIGNED numTrees=100,
            UNSIGNED featuresPerNode=0,
            UNSIGNED maxDepth=100,
            SET OF UNSIGNED nominalFields=[],
            BOOLEAN balanceClasses=FALSE) := MODULE(LT.LearningForest(numTrees, featuresPerNode, maxDepth), IClassify2)
            /**
            * Fit and return a model that maps independent data (X) to its predicted class (Y).
            *
            * @param independents  The set of independent data in NumericField format.
            * @param dependents The set of classes in DiscreteField format that correspond to the independent data
            *           i.e. same &amp;apos;id&amp;apos;.
            * @param nominalFields An optional set of field &amp;apos;numbers&amp;apos; that represent Nominal (i.e. unordered,
            *                      categorical) values.  Specifying the nominal fields improves run-time
            *                      performance on these fields and my improve accuracy as well.  Binary fields
            *                      (fields with only two values) need not be listed here as they can be
            *                      considered either ordinal or nominal.  Example: [3,5,7].
            * @return Model in Layout_Model2 format describing the fitted forest.
            * @see ML_Core.Types.NumericField, ML_Core.Types.DiscreteField, ML_Core.Types.Layout_Model2
            */
            EXPORT DATASET(Layout_Model2) GetModel(DATASET(NumericField) independents, DATASET(DiscreteField) dependents) := FUNCTION
            genX := NF2GenField(independents, nominalFields);
            genY := DF2GenField(dependents);
            myRF := int.RF_Classification(genX, genY, numTrees, featuresPerNode, maxDepth);
            model := myRF.GetModel;
            RETURN model;
            END;
            /**
            * Classify a set of data points using a previously fitted model
            *
            * @param model A model previously returned by GetModel in Layout_Model2 format.
            * @param observations The set of independent data to classify in NumericField format.
            * @return A DiscreteField dataset that indicates the predicted class of each item
            * in observations.
            */
            EXPORT DATASET(DiscreteField) Classify(DATASET(Layout_Model2) model, DATASET(NumericField) observations) := FUNCTION
            genX := NF2GenField(observations);
            myRF := int.RF_Classification();
            classes := myRF.Classify(genX, model, balanceClasses);
            RETURN classes;
            END;

            /**
            * Calculate the &amp;apos;probability&amp;apos; that each data point is in each class.
            * &amp;lt;p&amp;gt;Probability is approximated by computing the proportion of trees that
            * voted for each class for each data point, so should not be treated
            * as a reliable measure of true probability.
            *
            * @param model A model previously returned by GetModel in Layout_Model2 format.
            * @param observations The set of independent data to classify in NumericField format.
            * @return DATASET(ClassProbs), one record per datapoint (i.e. id) per class
            *         label.  Class labels with zero votes are omitted.
            * @see LT_Types.ClassProbs
            *
            */
            EXPORT DATASET(ClassProbs) GetClassProbs(DATASET(Layout_Model2) model, DATASET(NumericField) observations) := FUNCTION
            genX := NF2GenField(observations);
            myRF := int.RF_Classification();
            probs := myRF.GetClassProbs(genX, model, balanceClasses);
            probsS := SORT(probs, wi, id, class); // Global sort
            RETURN probsS;
            END;

            /**
            * Extract the set of class weights from the model.
            * &amp;lt;p&amp;gt;Classes are weighted inversely proportional to their frequency in the
            * training data.  &amp;lt;p&amp;gt;Note that the class weights are based on a non-linear
            * &amp;apos;proportion&amp;apos; to avoid excess weight for classes with very low frequency.
            * &amp;lt;p&amp;gt;These weights are only used when the &amp;apos;balanceClasses&amp;apos; option is TRUE.
            *
            * @param mod A model as returned from GetModel.
            * @return DATASET(ClassWeightRec) representing weight for each class label.
            * @see LT_Types.ClassWeightRec
            */
            EXPORT  Model2ClassWeights(DATASET(Layout_Model2) mod) := FUNCTION
            myRF := int.RF_Classification();
            cw := myRF.Model2ClassWeights(mod);
            RETURN cw;
            END;
            END;&amp;#10;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;learningforest&quot;
            name=&quot;LearningForest&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl&quot;
            ts=&quot;1621960363000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
            ############################################################################## */

            IMPORT $ AS LT;
            IMPORT LT.LT_Types AS Types;
            IMPORT ML_Core;
            IMPORT ML_Core.Types as CTypes;
            IMPORT $ as LT;
            IMPORT LT.internal AS int;

            GenField := Types.GenField;
            DiscreteField := CTypes.DiscreteField;
            NumericField := CTypes.NumericField;
            Layout_Model2 := CTypes.Layout_Model2;
            ModelStats := Types.ModelStats;
            TreeNodeDat := Types.TreeNodeDat;

            /**
            * This is the base module for Random Forests.
            * It implements the Random Forest algorithms as described by Breiman, 2001
            * (see https://www.stat.berkeley.edu/~breiman/randomforest2001.pdf).
            *
            * @param numTrees The number of trees to create as the forest for each work-item.
            *                 This defaults to 100, which is adequate for most cases.
            * @param featuresPerNode The number of features to choose among at each split in
            *                 each tree.  This number of features will be chosen at random
            *                 from the full set of features.  The default is the square
            *                 root of the number of features provided, which works well
            *                 for most cases.
            * @param maxDepth The deepest to grow any tree in the forest.  The default is
            *                 100, which is adequate for most purposes.  Increasing this value
            *                 for very large and complex problems my provide slightly greater
            *                 accuracy at the expense of much greater runtime.
            */
            EXPORT LearningForest(UNSIGNED numTrees=100,
            UNSIGNED featuresPerNode=0,
            UNSIGNED maxDepth=100) := MODULE
            // Map a NumericField dataset to GenField dataset
            SHARED DATASET(GenField) NF2GenField(DATASET(NumericField) ds, SET OF UNSIGNED nominalFields=[]) := FUNCTION
            dsOut := PROJECT(ds, TRANSFORM(GenField, SELF.isOrdinal := LEFT.number NOT IN nominalFields, SELF := LEFT));
            RETURN dsOut;
            END;
            // Map a DiscreteField dataset to GenField dataset
            SHARED DATASET(GenField) DF2GenField(DATASET(DiscreteField) ds) := FUNCTION
            dsOut := PROJECT(ds, TRANSFORM(GenField, SELF.isOrdinal := TRUE, SELF := LEFT));
            RETURN dsOut;
            END;
            /**
            * Get summary statistical information about the model.
            *
            * @param mod A model previously returned from GetModel.
            * @return A single ModelStats record per work-item, containing information about the model
            *         for that work-item.
            * @see LT_Types.ModelStats
            */
            EXPORT DATASET(ModelStats) GetModelStats(DATASET(Layout_Model2) mod) := FUNCTION
            myRF := int.RF_Base();
            RETURN myRF.GetModelStats(mod);
            END;
            /**
            * Extract the set of tree nodes from a model.
            *
            * @param mod A model as returned from GetModel.
            * @return Set of tree nodes representing the fitted forest in
            *         DATASET(TreeNodeDat) format.
            * @see LT_Types.TreeNodeDat
            */
            EXPORT DATASET(TreeNodeDat) Model2Nodes(DATASET(Layout_Model2) mod) := FUNCTION
            myRF := int.RF_Base();
            nodes0 := myRF.Model2Nodes(mod);
            nodes := SORT(nodes0, wi, treeId, level, nodeId, LOCAL);
            RETURN nodes;
            END;
            /**
            * &amp;lt;p&amp;gt;Determine the relative importance of features in the decision process of
            * the model.
            * Calculate feature importance using the Mean Decrease Impurity (MDI) method
            * from &amp;quot;Understanding Random Forests: by Gilles Loupe (https://arxiv.org/pdf/1407.7502.pdf)
            * and due to Breiman [2001, 2002].
            *
            * &amp;lt;p&amp;gt;Each feature is ranked by:
            * &amp;lt;pre&amp;gt;  SUM for each branch node in which feature appears (across all trees):
            *     (impurity_reduction * number of nodes split) / numTrees.&amp;lt;/pre&amp;gt;
            * @param mod The model to use for ranking of feature importance.
            * @return DATASET(FeatureImportanceRec), one per feature per wi.
            * @see LT_Types.FeatureImportanceRec
            */
            EXPORT FeatureImportance(DATASET(Layout_Model2) mod) := FUNCTION
            myRF := int.RF_Base();
            fi := myRF.FeatureImportance(mod);
            RETURN fi;
            END;
            SHARED empty_data := DATASET([], NumericField);
            /**
            * &amp;lt;p&amp;gt;Calculate a matrix of distances between data points in Random Forest Decision Space (RFDS).
            * This is an experimental method and may not
            * scale to large numbers of data point combinations.
            * Two sets of data points X1 and X2 are taken as parameters.  A
            * Decision Distance will be returned for every point in X1 to every
            * point in X2.  Therefore, if X1 has N points and X2 has M points, an
            * N x M matrix of results will be produced.  X2 may be omitted, in which
            * case, an N x N matrix will be produced with a Decision Distance for
            * every pair of points in X1.
            *
            * &amp;lt;p&amp;gt;This metric represents a distance measure in the RFDS.
            * As such, it provides a continuous measure of distance in a space that is
            * highly non-linear and discontinuous relative to the training data.
            * Distances in RFDS can be thought of as the number of binary decisions
            * that separate two points in the tree.  DD, however is a normalized
            * metric 0 &amp;lt;= DD &amp;lt; 1 that incorporates the depth of the decision tree.
            * It is also averaged over all of the trees in the forest.
            * It can possibly be viewed as an approximation of the relative Hamming Distances
            * between points.
            *
            * @param mod The Random Forest model on which to base the distances.
            * @param X1 DATASET(NumericField) of &amp;quot;from&amp;quot; points.
            * @param X2 (Optional) DATASET(NumericField) of &amp;quot;to&amp;quot; points.  If this
            *             parameter is omitted, the X1 will be used as both &amp;quot;to&amp;quot; and
            *             &amp;quot;from&amp;quot; points.
            * @return DATASET(NumericField) matrix where &amp;apos;id&amp;apos; is the id of the &amp;quot;from&amp;quot;
            *               point and &amp;apos;number&amp;apos; is the id of the &amp;quot;to&amp;quot; point.
            *               &amp;apos;value&amp;apos; contains the DD metric between &amp;quot;from&amp;quot; and &amp;quot;to&amp;quot; points.
            *               Note that if the same point is in X1 and X2, there will be
            *               redundant metrics, since DD is a symmetric measure (i.e.
            *               DD(x1, x2) = DD(x2, x1).
            */
            EXPORT DecisionDistanceMatrix(DATASET(Layout_Model2) mod, DATASET(NumericField) X1,
            DATASET(NumericField) X2=empty_data) := FUNCTION
            myRF := int.RF_Base();
            ddm := myRF.DecisionDistanceMatrix(mod, NF2GenField(X1), NF2GenField(X2));
            RETURN DDM;
            END;
            /**
            *
            * Uniqueness Factor is an experimental metric that determines how far a given point
            * is (in Random Forest Decision Distance) from a set of other points.
            * It may not scale to large numbers of data points.
            *
            * Uniqueness Factor looks at the Decision Distance from each point to every other
            * point in a set.
            *
            * It is similar to Decision Distance (above), but rather than providing a distance of
            * each &amp;quot;from&amp;quot; point to every &amp;quot;to&amp;quot; point, it provides the average distance of each &amp;quot;from&amp;quot;
            * point to all of the &amp;quot;to&amp;quot; points.
            *
            * Like Decision Distance, UF lies on the interval: 0 &amp;lt;= UF &amp;lt; 1.
            *
            * A high value of UF may indicate an anomolous data point, while a low value may indicate
            * &amp;quot;typicalness&amp;quot; of a data point.  It may therefore have utility for anomaly detection
            * or conversely, for the identification of class prototypes (e.g. the members of a class
            * with the lowest UF).  In a two-step process one could potentially compute class prototypes
            * and then look at the distance of a point from all class prototypes.  This could result
            * in a way to detect anomalies with respect to e.g., known usage patterns.
            *
            * @param mod The Random Forest model on which to base the distances.
            * @param X1 DATASET(NumericField) of &amp;quot;from&amp;quot; points.
            * @param X2 (Optional) DATASET(NumericField) of &amp;quot;to&amp;quot; points.  If this
            *             parameter is omitted, the X1 will be used as both &amp;quot;to&amp;quot; and
            *             &amp;quot;from&amp;quot; points.
            * @return DATASET(NumericField) matrix where &amp;apos;id&amp;apos; is the id of the &amp;quot;from&amp;quot;
            *               point and &amp;apos;value&amp;apos; contains the UF metric for the point.
            *               I.e. the average DD of the &amp;quot;from&amp;quot; point to all &amp;quot;to&amp;quot; points.
            *               The &amp;apos;number&amp;apos; field is not used and is set to 1.
            */
            EXPORT UniquenessFactor(DATASET(Layout_Model2) mod, DATASET(NumericField) X1, DATASET(NumericField) X2=empty_data) := FUNCTION
            myRF := int.RF_Base();
            uf := myRF.UniquenessFactor(mod, NF2GenField(X1), NF2GenField(X2));
            RETURN uf;
            END;

            /**
            * Compress and cleanup the model
            *
            * This function is provided to reduce the size of a model by compressing out
            * branches with only one child.  These branches are a result of the RF algorithm,
            * and do not affect the results of the model.
            * This is an expensive operation, which is why it is not done as a matter of
            * course.  It reduces the size of the model somewhat, and therefore slightly speeds
            * up any processing that uses the model, and reduces storage size.
            * You may want to compress the model if storage is at a premium, or if the model
            * is to be used many times (so that the slight performance gain is multiplied).
            * This also makes the model somewhat more readable, and could
            * be useful when analyzing the tree or converting it to another system
            * (e.g. LUCI) for processing.
            *
            * @param mod Model as returned from GetModel in Layout_Model2 format.
            * @return The Compressed Model.
            * @see ML_Core.Types.Layout_Model2
            *
            */
            EXPORT CompressModel(DATASET(Layout_Model2) mod) := FUNCTION
            myRF := int.RF_Base();
            cMod := myRF.CompressModel(mod);
            RETURN cMod;
            END;
            END;&amp;#10;
            &lt;/Attribute&gt;
            &lt;/Module&gt;
            &lt;Module key=&quot;_versions.ml_core&quot; name=&quot;_versions.ML_Core&quot;/&gt;
            &lt;Module key=&quot;_versions.ml_core.v3_2_2&quot; name=&quot;_versions.ML_Core.V3_2_2&quot;/&gt;
            &lt;Module key=&quot;_versions.ml_core.v3_2_2.ml_core&quot; name=&quot;_versions.ML_Core.V3_2_2.ML_Core&quot;&gt;
            &lt;Attribute key=&quot;types&quot;
            name=&quot;Types&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Types.ecl&quot;
            ts=&quot;1621960335000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2018 HPCC Systems®.  All rights reserved.
            ############################################################################## */
            //IMPORT $ AS ML_Core;
            //NamingTree := ML_Core.NamingTree;

            /**
            * This module provides the major data type definitions for use with the various
            * ML Bundles
            *
            */
            EXPORT Types := MODULE
            // The t_RecordID and t_FieldNumber are native nominal types of the ML
            // libraries and they currently allow for 2**64 rows with 2**32
            // features.
            //
            // If your needs are lower, then making these two smaller
            // will improve performance. In particular an unsigned4 for t_RecordID
            // supports 2**32 (more than 4 billion) rows and an unsigned2 for
            // t_FieldNumber allows 64K features.
            //
            // Some ML modules will use dense matrix operations form PBblas and
            // support only 4 billion (2**32) rows.
            //
            // The structures are also used for the myriad interface support.
            // The notion is to support a myriad of small problems that need the
            // steps applied.  Sort of a logical Single Instruction Multiple Data
            // parallel machine approach.  The work_item is used to group the
            // problem data.  If you have just one problem, the field should be
            // set to some positive constant like 1.
            //
            EXPORT t_RecordID := UNSIGNED8;
            EXPORT t_FieldNumber := UNSIGNED4;
            EXPORT t_FieldReal := REAL8;
            EXPORT t_FieldSign := INTEGER1;
            EXPORT t_Discrete := INTEGER4;
            EXPORT t_Item := UNSIGNED4; // Currently allows up to 4B different elements
            EXPORT t_Count := t_RecordID; // Possible to count every record
            EXPORT t_Work_Item := UNSIGNED2;  //TODO: change to be PBblas.Types.work_item_t
            EXPORT t_index := UNSIGNED4;  // Type of each index value (see Layout_Model2)
            EXPORT t_indexes := SET OF t_index; // Definition of the indexes field for Layout_Model2

            // Base record for Numeric and Discrete Fields
            EXPORT AnyField     := RECORD
            t_Work_Item wi; // Work-item id
            t_RecordID id;  // Observation identifier (i.e. row id for X and Y) -- 1 based
            t_FieldNumber number; // Feature number (i.e. column number) -- 1 based
            END;

            /**
            * The NumericField layout defines a matrix of Real valued data-points.
            * It acts as the primary Dataset layout for interacting with most ML Functions.
            * Each record represents a single cell in a matrix.  It is most often used
            * to represent a set of data-samples or observations, with the &amp;apos;id&amp;apos; field representing
            * the data-sample or observation, and the &amp;apos;number&amp;apos; field representing the
            * various fields within the observation.
            *
            * @field wi The work-item id, supporting the Myriad style interface.  This allows
            *           multiple independent matrixes to be contained within a single dataset,
            *           supporting independent ML activities to be processed in parallel.
            * @field id This field represents the row-number of this cell of the matrix.  It
            *           is also considered the record-id for observations / data-samples.
            * @field number This field represents the matrix column number for this cell.  It
            *               is also considered the field number of the observation
            * @field value The value of this cell in the matrix.
            *
            */
            EXPORT NumericField := RECORD(AnyField)
            t_FieldReal value;
            END;

            /**
            * The Discrete Field layout defines a matrix of Integer valued data-points.
            * It is similar to the NumericField layout above, except for only containing
            * discrete (integer) values.
            * It is typically used to convey the class-labels for classification algorithms.
            *
            * @field wi The work-item id, supporting the Myriad style interface.  This allows
            *           multiple independent matrixes to be contained within a single dataset,
            *           supporting independent ML activities to be processed in parallel.
            * @field id This field represents the row-number of this cell of the matrix.  It
            *           is also considered the record-id for observations / data-samples.
            * @field number This field represents the matrix column number for this cell.  It
            *               is also considered the field number of the observation
            * @field value The value of this cell in the matrix.
            *
            */
            EXPORT DiscreteField := RECORD(AnyField)
            t_Discrete value;
            END;

            /**
            * Layout for Model dataset (version 2)
            *
            * Generic Layout describing the model &amp;apos;learned&amp;apos; by a Machine Learning algorithm.
            *
            * Models for all new ML bundles are stored in this format.
            * Some older bundles may still use the Layout_Model (version 1)
            * layout.
            *
            * Models are thought of as opaque data structures.  They are
            * not designed to be understandable except to the bundle that
            * produced them.  Most bundles contain mechanisms to extract
            * useful information from the model.
            *
            * This version of the model is based on a Naming-Tree paradigm.
            * This provides a flexible generic mechanism for storage and
            * manipulation of models.
            *
            * For bundle developers (or the curious), the file modelOps2
            * provides a detailed description of
            * the theory and usage of this model layout as well as a set of
            * functions to manipulate models for use by bundle developers.
            *
            * @field wi The work-item-id
            * @field value The value of the cell
            * @field indexes The identifier for the cell -- a set of unsigned integers
            *                e.g., [1,2,1,3]
            */
            EXPORT Layout_Model2 := RECORD
            t_work_item wi;
            t_fieldReal value;
            t_indexes indexes;
            END;

            // Note: Layout_Model has been deprecated in favor of Layout_Model2, which
            // should be used as the basis of the model for new Bundles or Bundles
            // undergoing major revision.
            // Generic Layout describing the model &amp;apos;learned&amp;apos; by a Machine Learning algorithm.
            EXPORT Layout_Model := RECORD
            t_Work_Item wi;       // Work-item of the model
            t_RecordID  id;       // Identifies the component type within the model
            t_FieldNumber number; // meaning varies by ID
            t_FieldReal value;    // The model parameter value
            END;

            // Generic Layout describing the model &amp;apos;learned&amp;apos; by a Machine Learning algorithm.
            // See NamingTree.ecl for details on using this format.
            //EXPORT Layout_Model2 := NamingTree.ntNumeric;

            // Classification definitions
            EXPORT Classify_Result := RECORD(DiscreteField)
            REAL8 conf;  // Confidence - high is good
            END;
            EXPORT l_result := Classify_Result : DEPRECATED(&amp;apos;Use Classify_Result&amp;apos;);

            // Result structures for the common analytic methods (see Analysis.ecl)
            /**
            * Class_Stats
            *
            * Layout for data returned from Analysis.Regression.ClassStats
            *
            * @field wi Work-item identifier
            * @field classifier The field number associated with this dependent variable, for
            *                   multi-variate classification.  Otherwise 1.
            * @field class The class label associated with this record
            * @field classCount The number of times the class was seen in the data
            * @field classPct The percent of records with this class.
            */
            EXPORT Class_Stats := RECORD
            t_Work_Item wi;
            t_FieldNumber classifier; // Dependent column identifier for multi-variate
            t_Discrete class;
            t_Discrete classCount;
            t_FieldReal classPct;
            END;
            /**
            * Confusion_Detail
            *
            * Layout for storage of the confusion matrix for ML Classifiers
            * Each row represents a pairing of a predicted class and an actual class
            *
            * @field wi Work item identifier
            * @field classifier The field number associated with this dependent variable, for
            *                   multi-variate.  Otherwise 1.
            * @field actual_class The target class number -- the expected result.
            * @field predict_class The class number predicted by the ML algorithm
            * @field occurs The number of times this pairing of (actual / predicted) classes occurred
            * @field correct Boolean indicating if this represents a correct prediction (i.e.
            *                predicted = actual)
            * @field pctActual The percent of items that were actually of &amp;lt;actual_class&amp;gt; that
            *                  were predicted as &amp;lt;predict_class&amp;gt;.
            * @field pctPred Indicates the percent of items that were predicted as &amp;lt;predict_class&amp;gt;
            *                that were actually of &amp;lt;actual_class&amp;gt;.
            */
            EXPORT Confusion_Detail := RECORD
            t_work_item wi;
            t_FieldNumber classifier;   // Dependent column identifier
            t_Discrete actual_class;
            t_Discrete predict_class;
            UNSIGNED4 occurs;
            BOOLEAN correct;
            t_FieldReal pctActual := 0;
            t_FieldReal pctPred := 0;
            END;
            /** Classification_Accuracy
            *
            * Results layout for Analysis.Classification/Accuracy
            * @field wi Work item identifier
            * @field classifier The field number associated with this dependent variable, for
            *                   multi-variate.  Otherwise 1.
            * @field errCnt The number of errors (i.e. predicted &amp;lt;&amp;gt; actual)
            * @field recCnt The total number or records in the test set
            * @field Raw_Accuracy The percentage of samples properly classified (0.0 - 1.0)
            * @field PoD Power of Discrimination.  Indicates how this classification performed
            *           relative to a random guess of class.  Zero or negative indicates that
            *           the classification was no better than a random guess.  1.0 indicates a
            *           perfect classification.  For example if there are two equi-probable classes,
            *           then a random guess would be right about 50% of the time.  If this
            *           classification had a Raw Accuracy of 75%, then its PoD would be .5
            *           (half way between a random guess and perfection).
            * @field PoDE Power of Discrimination Extended.  Indicates how this classification
            *           performed relative to guessing the most frequent class (i.e. the trivial
            *           solution).  Zero or negative indicates that this classification is no
            *           better than the trivial solution.  1.0 indicates perfect classification.
            *           For example, if 95% of the samples were of class 1, then the trivial
            *           solution would be right 95% of the time.  If this classification had a
            *           raw accuracy of 97.5%, its PoDE would be .5 (i.e. half way between
            *           trivial solution and perfection).
            * @field Hamming_Loss Hamming loss. The percentage of records misclassified.
            *           Useful for multilabel classification. It is equal to 1 - Raw_Accuracy.
            *
            */
            EXPORT Classification_Accuracy := RECORD
            t_Work_Item wi;
            t_FieldNumber classifier;
            UNSIGNED recCnt;
            UNSIGNED errCnt;
            REAL Raw_Accuracy;
            REAL PoD;
            REAL PoDE;
            REAL Hamming_Loss;
            END;
            /**
            * Class_Accuracy
            *
            * Results layout for Analysis.Classification.AccuracyByClass
            * See https://en.wikipedia.org/wiki/Precision_and_recall for a more detailed
            * explanation.
            *
            * @field wi Work item identifier
            * @field classifier The field number associated with this dependent variable, for
            *                   multi-variate.  Otherwise 1.
            * @field class The class to which the analytics apply
            * @field precision The precision of the classification for this class
            *                  (i.e. True Positives / (True Positives + FalsePositives)).
            *                  What percentage of the items that we predicted as being
            *                  in this class are actually of this class?
            * @field recall The completeness of recall for this class
            *                  (i.e. True Positives / (True Positives + False Negatives))
            *                  What percentage of the items that are actually in this class
            *                  did we correctly predict as this class?
            * @field FPR The false positive rate for this class
            *                  (i.e. False Positives / (False Positives + True Negatives))
            *                  What percentage of the items not in this class did we falsely
            *                  predict as this class?
            * @field f_score The balanced F-score for this class
            *                  (i.e. 2 * (precision * recall) / (precision + recall))
            *                  The harmonic mean of precision and recall. Higher values are better.
            *
            */
            EXPORT Class_Accuracy := RECORD
            t_Work_Item wi;
            t_FieldNumber classifier;
            t_Discrete class;
            REAL precision;
            REAL recall;
            REAL FPR;
            REAL f_score;
            END;
            /**
            * AUC_Result
            *
            * Result layout for Analysis.Classification.AUC.
            *
            * Provides the area under the Receiver Operating Characteristic curve for the given
            * given data. This area is a measure of the classifier&amp;apos;s ability to distinguish between
            * classes.
            *
            * @field wi Work item identifier
            * @field classifier The field number associated with this dependent variable, for
            *                   multi-variate.  Otherwise 1.
            * @field class The class to which the analytics apply.
            * @field AUC The value of the Area Under the Receiver Operating Characteristic curve
            *            for this class. This value ranges between 0 and 1. A higher value is an
            *            indication of a better classifier.
            */
            EXPORT AUC_Result := RECORD
            t_Work_Item wi;
            t_FieldNumber classifier;
            t_Discrete class;
            t_FieldReal AUC;
            END;
            /**
            * Regression_Accuracy
            *
            * Results layout for Analysis.Regression.Accuracy
            *
            * @field wi Work item identifier
            * @field regressor The field number associated with this dependent variable, for
            *                   multi-variate.  Otherwise 1.
            * @field R2 The R-Squared value (Coefficient of Determination) for the regression.
            *           R-squared of zero or negative indicates that the regression has no predictive
            *           value.  R2 of 1 would indicate a perfect regression.
            * @field MSE Mean Squared Error = SUM((predicted - actual)^2) / N (number of datapoints)
            * @field RMSE Root Mean Squared Error = MSE^.5 (Square root of MSE)
            *
            */
            EXPORT Regression_Accuracy := RECORD
            t_Work_Item wi;
            t_FieldNumber regressor;
            t_FieldReal R2;
            t_FieldReal MSE;
            t_FieldReal RMSE;
            END;
            /**
            * Contingency_Table
            *
            * Contains the contingency table for every combination of feature and classifier.
            * Result layout for Analysis.FeatureSelection.Contingency
            *
            * @field wi Work item identifier
            * @field fnumber The feature number
            * @field snumber The sample number or the classifier number
            * @field fclass The feature label / class
            * @field sclass The sample (classifier) label / class
            * @field cnt The number of samples with feature label fclass and classifier label sclass
            *            Does not contain entries for combinations with no members.
            *
            */
            EXPORT Contingency_Table := RECORD
            t_Work_Item wi;
            t_FieldNumber fnumber;
            t_FieldNumber snumber;
            t_Discrete fclass;
            t_Discrete sclass;
            INTEGER cnt := COUNT(GROUP);
            END;
            /**
            * Chi2_Result
            *
            * Result layout for Analysis.FeatureSelection.Chi2
            * Contains chi2 value for every combination of feature and classifier per work item,
            * and its corresponding p value.
            *
            * @field wi Work item identifier
            * @field fnumber Feature number
            * @field snumber Sample number / number of classifier
            * @field dof The number of degrees of freedom
            * @field x2 The chi2 value for this combination. Higher values indicate more closely
            related variables
            * @field p The p-value, which is the area under the chi-square probability density function
            *          curve to the right of the specified x2 value. The probability that the variables
            *          are not closely related
            *
            */
            EXPORT Chi2_Result := RECORD
            t_Work_Item wi;
            t_FieldNumber fnumber;
            t_FieldNumber snumber;
            INTEGER dof;
            t_FieldReal x2;
            t_FieldReal p;
            END;
            /**
            * ARI_Result
            *
            * Result layout for Analysis.Clustering.ARI
            *
            * Contains the Adjusted Rand Index for each work item.
            *
            * @field wi Work item identifier
            * @field value The ARI for the model
            *
            */
            EXPORT ARI_Result := RECORD
            t_Work_Item wi;
            t_FieldReal value;
            END;
            /**
            * SampleSilhouette_Result
            *
            * Result layout for Analysis.Clustering.SampleSilhouetteScore
            *
            * Contains the silhouette score for each sample datapoint.
            *
            * @field wi Work item identifier
            * @field id Sample datapoint identifier
            * @field value Silhouette score
            *
            */
            EXPORT SampleSilhouette_Result := RECORD
            t_Work_Item wi;
            t_RecordID id;
            t_FieldReal value;
            END;
            /**
            * Silhouette_Result
            *
            * Result layout for Analysis.Clustering.SilhouetteScore
            *
            * Contains the silhouette score for each work item.
            *
            * @field wi Work item identifier
            * @field score Silhouette score
            *
            */
            EXPORT Silhouette_Result := RECORD
            t_Work_Item wi;
            t_FieldReal score;
            END;
            // End Analytic result structures

            // Clustering structures required by cluster analysis methods (See Analysis.ecl)
            /**
            * ClusterLabels format defines the distance space where
            * each cluster defined by a center and its closest samples.
            * It is the same as KMeans.Types.KMeans_Model.Labels.
            *
            * @field  wi      The model identifier.
            * @field  id      The sample identifier.
            * @field  label   The identifier of the closest center to the sample.
            */
            EXPORT ClusterLabels := RECORD
            t_Work_Item wi;      // Model Identifier
            t_RecordID  id;      // Sample Identifier
            t_RecordID  label;   // Center Identifier
            END;
            // End Clustering structures

            // Data diagnostic definition
            EXPORT Data_Diagnostic := RECORD
            t_work_item wi;
            BOOLEAN valid;                 // Flag indicating failure of ANY diagnostic tests for wi
            SET OF VARSTRING message_text; // List of failed diagnostic tests for a wi
            END;

            /**
            * Field_Mapping is the format produced by ToField for field-name mapping.
            *
            * @field orig_name The name of the field in the original layout
            * @field assigned_name The integer field number used in the ML algorithm stored as a STRING
            *
            */
            EXPORT Field_Mapping := RECORD
            STRING orig_name;      // The name of the field in the original layout
            STRING assigned_name;  // The integer field number used in the ML algorithm
            END;
            /**
            * LUCI Record -- A dataset of lines each containing a string
            * This is the DATASET format in which ML algorithm export LUCI files.
            *
            * @field line A single line in the LUCI csv file
            *
            */
            EXPORT LUCI_Rec := RECORD
            STRING line;
            END;
            /**
            * Classification_Scores
            *
            * The probability or confidence, per class, that a sample belongs to that class.
            *
            * @field wi The work-item identifier.
            * @field id The record-id of the sample.
            * @field classifier The field number associated with this dependent variable, for
            *                   multi-variate. Otherwise 1.
            * @field class The class label.
            * @field prob The percentage of trees that assigned this class label,
            *             which is a rough stand-in for the probability that the label
            *             is correct.
            */
            EXPORT Classification_Scores := RECORD
            t_Work_Item wi;
            t_RecordID id;
            t_FieldNumber classifier;
            t_Discrete class;
            t_FieldReal prob;
            END;
            END;&amp;#10;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;analysis&quot;
            name=&quot;Analysis&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Analysis.ecl&quot;
            ts=&quot;1621960335000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2018 HPCC Systems®.  All rights reserved.
            ############################################################################## */
            IMPORT $ AS ML_Core;
            IMPORT ML_Core.Types;
            IMPORT ML_Core.Math;

            DiscreteField := Types.DiscreteField;
            NumericField := Types.NumericField;
            t_Work_Item := Types.t_Work_Item;
            t_RecordId := Types.t_RecordId;
            t_FieldNumber := Types.t_FieldNumber;
            t_FieldReal := Types.t_FieldReal;
            t_Discrete := Types.t_Discrete;
            Class_Stats := Types.Class_Stats;
            Confusion_Detail := Types.Confusion_Detail;
            Classification_Accuracy := Types.Classification_Accuracy; // Return structure for
            // Classification.Accuracy
            Class_Accuracy := Types.Class_Accuracy; // Return structure for Classification.AccuracyByClass
            Regression_Accuracy := Types.Regression_Accuracy; // Return structure for Regression.Accuracy
            Contingency_Table := Types.Contingency_Table; // Return structure for FeatureSelection.Contingency
            Chi2_Result := Types.Chi2_Result; // Return structure for FeatureSelection.Chi2
            ClusterLabels := Types.ClusterLabels; // Parameter structure for Clustering.ARI
            ARI_Result := Types.ARI_Result; // Return structure for Clustering.ARI
            SampleSilhouette_Result := Types.SampleSilhouette_Result; // Return structure for Clustering.SampleSilhouetteScore
            Silhouette_Result := Types.Silhouette_Result; // Return structure for Clustering.SilhouetteScore
            AUC_Result := Types.AUC_Result; // Return structure for Classification.AUC
            Classification_Scores := Types.Classification_Scores; // Parameter structure for Classification.AUC

            /**
            * Analyze and assess the effectiveness of a Machine
            * Learning model.
            * &amp;lt;p&amp;gt;Sub-modules provide support for both Classification and Regression.
            *
            * &amp;lt;p&amp;gt;Each of the functions in this module support multi-work-item (i.e. Myriad interface) data, as well as
            * multi-variate data (supported by some ML bundles).  The number field, which is usually
            * = 1 for uni-variate data is used to distinguish multiple regressors in the case of multi-
            * variate models.
            *
            **/
            EXPORT Analysis := MODULE
            /**
            * This sub-module provides functions for analyzing and assessing the effectiveness of
            * an ML Classification model.  It can be used with any ML Bundle that supports classification.
            */
            EXPORT Classification := MODULE
            /**
            * Given a set of expected dependent values, assess the number and percentage of records that
            * were of each class.
            *
            * @param actual The set of training-data or test-data dependent values in DATASET(DiscreteField)
            *               format.
            * @return DATASET(Class_Stats), one record per work-item, per classifier (i.e. number field) per
            *         class.
            * @see ML_Core.Types.Class_Stats
            **/
            EXPORT DATASET(Class_Stats) ClassStats(DATASET(DiscreteField) actual) := FUNCTION
            // Returns for each class: label, count, pct
            recStats := TABLE(actual, {wi, number, cnt := COUNT(GROUP)}, wi, number);
            cStats := TABLE(actual, {wi, number, value, cnt := COUNT(GROUP)}, wi, number, value);
            outStats := JOIN(cStats, recStats, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number,
            TRANSFORM(Class_Stats,
            SELF.classifier := LEFT.number,
            SELF.class := LEFT.value,
            SELF.classCount := LEFT.cnt,
            SELF.classPct := LEFT.cnt / RIGHT.cnt,
            SELF := LEFT), LOOKUP);
            RETURN outStats;
            END; // ClassStats
            // Function to compare predicted and actual values and include them in a record set containing both,
            // as well as a &amp;apos;correct&amp;apos; indicator, which is TRUE whenever the two match.
            SHARED CompareClasses(DATASET(DiscreteField) predicted, DATASET(DiscreteField) actual) := FUNCTION
            // Distribute predicted and actual by HASH32(wi, id)
            predD := DISTRIBUTE(predicted, HASH32(wi, id));
            actD := DISTRIBUTE(actual, HASH32(wi, id));
            cmp := JOIN(predD, actD, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number AND LEFT.id = RIGHT.id,
            TRANSFORM({t_Work_Item wi, t_FieldNumber number, t_Discrete pred, t_discrete actual, BOOLEAN correct},
            SELF.pred := LEFT.value,
            SELF.actual := RIGHT.value,
            SELF.correct := LEFT.value = RIGHT.value,
            SELF := LEFT), LOCAL);
            // cmp is distributed by HASH32(wi, id)
            RETURN cmp;
            END; // CompareClasses
            /**
            * Returns the Confusion Matrix, counting the number of cases for each combination of predicted Class and
            * actual Class.
            *
            * @param predicted The predicted values for each id in DATASET(DiscreteField) format.
            * @param actual The actual (i.e. expected) values for each id in DATASET(DiscreteField) format.
            * @return DATASET(Confusion_Detail).  One record for each combination of work-item, number (i.e. classifier),
            *         predicted class, and actual class.
            * @see ML_Core.Types.Confusion_Detail
            *
            **/
            EXPORT DATASET(Confusion_Detail) ConfusionMatrix(DATASET(DiscreteField) predicted, DATASET(DiscreteField) actual) := FUNCTION
            cmp := CompareClasses(predicted, actual);
            // Count the number of samples that were actually of each class
            actualClassTots := TABLE(cmp, {wi, number, actual, tot := COUNT(GROUP)}, wi, number, actual);
            // Count the number of samples that were predicted for each class
            predClassTots := TABLE(cmp, {wi, number, pred, tot := COUNT(GROUP)}, wi, number, pred);
            // Count the number of samples for each combination of actual and predicted
            cm0 := TABLE(cmp, {wi, t_FieldNumber classifier := number,
            t_Discrete actual_class := actual, t_Discrete predict_class := pred,
            UNSIGNED4 occurs := COUNT(GROUP), BOOLEAN correct := pred = actual}, wi, number, actual, pred);
            // Now calculate the proportions (of both actual and predicted values for each combination)
            cm1 := JOIN(cm0, actualClassTots, LEFT.wi = RIGHT.wi AND LEFT.classifier = RIGHT.number
            AND LEFT.actual_class = RIGHT.actual,
            TRANSFORM({RECORDOF(LEFT), t_FieldReal pctActual},
            SELF.pctActual := LEFT.occurs / RIGHT.tot,
            SELF := LEFT), LOOKUP);
            cm2 := JOIN(cm1, predClassTots, LEFT.wi = RIGHT.wi AND LEFT.classifier = RIGHT.number
            AND LEFT.predict_class = RIGHT.pred,
            TRANSFORM({RECORDOF(LEFT), t_FieldReal pctPred},
            SELF.pctPred := LEFT.occurs / RIGHT.tot,
            SELF := LEFT), LOOKUP);
            cm := PROJECT(cm2, Confusion_Detail);
            RETURN cm;
            END; // ConfusionMatrix
            /**
            * Assess the overall accuracy of the classification predictions.
            *
            * &amp;lt;p&amp;gt;ML_Core.Types.Classification_Accuracy provides a detailed description of the return values.
            *
            * @param predicted The predicted values for each id in DATASET(DiscreteField) format.
            * @param actual The actual (i.e. expected) values for each id in DATASET(DiscreteField) format.
            * @return DATASET(Classification_Accuracy).  One record for each combination of work-item, and
            *         number (i.e. classifier).
            * @see ML_Core.Types.Classification_Accuracy
            *
            **/
            EXPORT DATASET(Classification_Accuracy) Accuracy(DATASET(DiscreteField) predicted, DATASET(DiscreteField) actual) := FUNCTION
            // Returns Raw, PoD, PoDE
            cStats := ClassStats(actual);
            numClasses := TABLE(cStats, {wi, classifier, UNSIGNED4 num_classes := COUNT(GROUP)}, wi, classifier);
            mostCommon0 := SORT(cStats, wi, classifier, -classCount);
            mostCommon := DEDUP(mostCommon0, wi, classifier);
            globStats := JOIN(numClasses, mostCommon, LEFT.wi = RIGHT.wi AND LEFT.classifier = RIGHT.classifier,
            TRANSFORM({numClasses, UNSIGNED4 highestCnt},
            SELF.highestCnt := RIGHT.classCount,
            SELF := LEFT));
            cmp := CompareClasses(predicted, actual);
            cmpStats := TABLE(cmp, {wi, number, UNSIGNED4 corrCnt := COUNT(GROUP, correct), UNSIGNED4 totCnt := COUNT(GROUP)}, wi, number);
            outStats := JOIN(cmpStats, globStats, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.classifier,
            TRANSFORM(Classification_Accuracy,
            SELF.classifier := LEFT.number,
            SELF.errCnt := LEFT.totCnt - LEFT.corrCnt,
            SELF.recCnt := LEFT.totCnt,
            SELF.Raw_accuracy := LEFT.corrCnt / LEFT.totCnt,
            SELF.PoD := (LEFT.corrCnt -  LEFT.totCnt / RIGHT.num_classes) /
            (LEFT.totCnt - LEFT.totCnt / RIGHT.num_classes),
            SELF.PoDE := (LEFT.corrCnt - RIGHT.highestCnt) /
            (LEFT.totCnt - RIGHT.highestCnt),
            SELF.Hamming_Loss := SELF.errCnt / LEFT.totCnt,
            SELF := LEFT), LOOKUP);
            RETURN outStats;
            END; // Accuracy
            /**
            * Provides per class accuracy / relevance statistics (e.g. Precision / Recall,
            * False-positive Rate).
            *
            * &amp;lt;p&amp;gt;ML_Core.Types.Class_Accuracy provides a detailed description of the return values.
            *
            * @param predicted The predicted values for each id in DATASET(DiscreteField) format.
            * @param actual The actual (i.e. expected) values for each id in DATASET(DiscreteField) format.
            * @return DATASET(Class_Accuracy).  One record for each combination of work-item, number (i.e. classifier),
            *         and class.
            * @see ML_Core.Types.Class_Accuracy
            *
            **/
            EXPORT DATASET(Class_Accuracy) AccuracyByClass(DATASET(DiscreteField) predicted, DATASET(DiscreteField) actual) := FUNCTION
            // Returns Precision, Recall, False Positive Rate(FPR)
            allClasses0 := SORT(actual, wi, number, value);
            allClasses := DEDUP(actual, wi, number, value);
            cmp := CompareClasses(predicted, actual);
            // For each class, replicate all of the items not of that class so that we can analyze that class
            // with respect to its non-members (i.e. negatives).
            allClassPts := JOIN(cmp, allClasses, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number,
            TRANSFORM({cmp, UNSIGNED class},
            SELF.class := RIGHT.value,
            SELF := LEFT), MANY, LOOKUP);
            allClassSumm := TABLE(allClassPts, {wi, number, class,
            UNSIGNED4 precDenom := COUNT(GROUP, pred = class),
            UNSIGNED4 TP := COUNT(GROUP, pred = class AND actual = class),
            UNSIGNED4 FP := COUNT(GROUP, pred = class AND actual != class),
            UNSIGNED4 recallDenom := COUNT(GROUP, actual = class),
            UNSIGNED4 TN := COUNT(GROUP, actual != class AND pred != class),
            UNSIGNED4 FN := COUNT(GROUP, actual = class AND pred != class),
            }, wi, number, class);
            cStats := PROJECT(allClassSumm, TRANSFORM(Class_Accuracy,
            SELF.classifier := LEFT.number,
            SELF.precision := LEFT.TP / (LEFT.TP + LEFT.FP),
            SELF.recall := LEFT.TP / (LEFT.TP + LEFT.FN),
            SELF.FPR := LEFT.FP / (LEFT.FP + LEFT.TN),
            SELF.f_score := 2 * (SELF.precision * SELF.recall) / (SELF.precision + SELF.recall),
            SELF := LEFT));
            RETURN cStats;
            END; // AccuracyByClass
            /**
            * AUC
            *
            * Area under the Receiver Operating Characteristics (ROC) curve, is a measure of
            * how well a classifier is able to distinguish between classes. The ROC curve is
            * a plot of the true positive rate vs. the false positive rate with varying threshold
            * values.
            *
            * The value of this metric ranges from 0 to 1. Higher values are an indication of better
            * classifiers.
            *
            * @param scores The probability or confidence per class that a sample belongs to that class in
            *               DATASET(Classification_Scores) format
            * @param actual The actual class to which a sample belongs in DATASET(DiscreteField) format
            * @return DATASET(AUC_Result) The AUC score, per class, per classifier, per work item
            * @see ML_Core.Types.AUC_Result, ML_Core.Types.Classification_Score
            *
            **/
            EXPORT DATASET(AUC_Result) AUC(DATASET(Classification_Scores) scores, DATASET(DiscreteField) actual) := FUNCTION
            // Create a set of all classes (per classifier, per work item)
            classes := TABLE(actual, {wi, number, value}, wi, number, value);
            // Combine the actual labels and their probabilities
            // The actual labels are joined with a set of all classes, where each sample is matched with all classes
            // in which the selected label is marked isTrue, and the probabilities are obtained from scores. When a
            // score is not available, its probability is taken as 0.
            combined := JOIN(actual, classes,
            LEFT.wi = RIGHT.wi and
            LEFT.number = RIGHT.number,
            TRANSFORM({RECORDOF(scores), BOOLEAN isTrue},
            SELF.wi := LEFT.wi,
            SELF.id := LEFT.id,
            SELF.classifier := LEFT.number,
            SELF.class := RIGHT.value,
            SELF.prob := 0,
            SELF.isTrue := IF(LEFT.value=RIGHT.value, TRUE, FALSE)));
            // Combining with scores to populate the probability field. LEFT OUTER is used in the JOIN condition to
            // ensure that all classes are included.
            combined2 := JOIN(combined, scores,
            LEFT.wi = RIGHT.wi and
            LEFT.classifier = RIGHT.classifier and
            LEFT.id = RIGHT.id and
            LEFT.class = RIGHT.class,
            TRANSFORM({RECORDOF(combined)},
            SELF.prob := RIGHT.prob,
            SELF := LEFT), LEFT OUTER);
            // Dataset of all pairs of positive and negative points per, class, per classifier, per work item.
            // Only positive samples are taken from the left set and negative samples are taken from the right.
            // If the score of the left sample is greater than the right sample, it is considered correct
            // and hence marked 1. If the left score is smaller than that of the right, it is considered
            // incorrect and marked 0. It they are equal, it is marked 0.5.
            pairs := JOIN(combined2, combined2,
            LEFT.wi=RIGHT.wi and
            LEFT.classifier=RIGHT.classifier and
            LEFT.class=RIGHT.class and
            LEFT.isTrue = TRUE and
            RIGHT.isTrue = FALSE,
            TRANSFORM({t_Work_Item wi, t_FieldNumber classifier, t_Discrete class, REAL value},
            SELF.wi := LEFT.wi,
            SELF.classifier := LEFT.classifier,
            SELF.class := LEFT.class,
            SELF.value := IF(LEFT.prob = RIGHT.prob, 0.5, IF(LEFT.prob &amp;gt; RIGHT.prob, 1, 0))));
            // The average of these marked scores gives the probability that a random positive sample is scored
            // higher than a random negative sample which is equal to AUC
            RETURN TABLE(pairs,{wi,classifier,class,auc:=AVE(GROUP,value)},wi,classifier,class);
            END; // AUC
            END; // Classification
            /**
            * This sub-module provides functions for analyzing and assessing the effectiveness of
            * an ML Regression model.  It can be used with any ML Bundle that supports regression.
            *
            */
            EXPORT Regression := MODULE
            /**
            * Assess the overall accuracy of the regression predictions.
            *
            * &amp;lt;p&amp;gt;ML_Core.Types.Regression_Accuracy provides a detailed description of the return values.
            *
            * @param predicted The predicted values for each id in DATASET(DiscreteField) format.
            * @param actual The actual (i.e. expected) values for each id in DATASET(DiscreteField) format.
            * @return DATASET(Regression_Accuracy).  One record for each combination of work-item, and
            *         number (i.e. regressor).
            * @see ML_Core.Types.Regression_Accuracy
            *
            **/
            EXPORT DATASET(Regression_Accuracy) Accuracy(DATASET(NumericField) predicted, DATASET(NumericField) actual) := FUNCTION
            // Returns R-squared, MSE, RMSE
            meanAct := TABLE(actual, {wi, number, REAL mean := AVE(GROUP, value), cnt := COUNT(GROUP)}, wi, number);
            cmp := JOIN(actual, predicted, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number AND LEFT.id = RIGHT.id,
            TRANSFORM({t_Work_Item wi, t_FieldNumber number, t_FieldReal actual, t_FieldReal pred},
            SELF.actual := LEFT.value,
            SELF.pred := RIGHT.value,
            SELF := LEFT));
            calc0 := JOIN(cmp, meanAct, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number,
            TRANSFORM({cmp, REAL ts, REAL rs},
            SELF.ts := POWER(LEFT.actual - RIGHT.mean, 2), // Total squared
            SELF.rs := POWER(LEFT.actual - LEFT.pred, 2),  // Residual squared
            SELF := LEFT), LOOKUP);
            // R2 := 1 - (Residual Sum of Squares / Total Sum of Squares)
            calc1 := TABLE(calc0, {wi, number, R2 := 1 - SUM(GROUP, rs) / SUM(GROUP, ts), RSS := SUM(GROUP, rs)}, wi, number);
            result := JOIN(calc1, meanAct, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number,
            TRANSFORM(Regression_Accuracy,
            SELF.MSE := LEFT.RSS / RIGHT.cnt,
            SELF.RMSE := POWER(SELF.MSE, .5),
            SELF.regressor := LEFT.number,
            SELF := LEFT), LOOKUP);
            RETURN result;
            END; // Accuracy
            END; // Regression
            /**
            * This sub module provides functions for assessing the features of a
            * dataset, to perform feature selection.
            */
            EXPORT FeatureSelection := MODULE
            /**
            * Contingency
            *
            * Provides the contingency table for each combination of feature and sample (classifier).
            * The contingency table represents the number of samples present in the data for each
            * combination of sample category and feature category. Can only be used when both
            * classifier and feature are discrete.
            *
            * The sets provided need not be sample / feature sets. They can be any two discrete
            * fields whose contingency table is needed.
            *
            * @param samples The samples or dependent values in DATASET(DiscreteField) format
            * @param features The features or independent values in DATASET(DiscreteField) format
            * @return DATASET(Contingency_Table) The contingency table for each combination of
            *         sample (classifier) and feature, per work item
            * @see ML_Core.Types.Contingency_Table
            *
            */
            EXPORT DATASET(Contingency_Table) Contingency(DATASET(DiscreteField) samples, DATASET(DiscreteField) features) := FUNCTION
            // To obtain the contingency tables, the samples and features are first combined into a
            // single table, with every feature mapped to every classifier
            combined := JOIN(samples, features,
            LEFT.wi=RIGHT.wi and LEFT.id=RIGHT.id,
            TRANSFORM({t_Work_Item wi, t_RecordId id, t_FieldNumber fnumber,
            t_FieldNumber snumber, t_Discrete fclass, t_Discrete sclass},
            SELF.wi := LEFT.wi,
            SELF.id := LEFT.id,
            SELF.fnumber := RIGHT.number,
            SELF.snumber := LEFT.number,
            SELF.fclass := RIGHT.value,
            SELF.sclass := LEFT.value));
            // This combined data is then grouped to obtain the contingency tables
            result := TABLE(combined, {wi,fnumber,snumber,fclass,sclass,cnt:=COUNT(GROUP)},
            wi,fnumber,snumber,fclass,sclass);
            RETURN result;
            END; //Contingency
            /**
            * Chi2
            *
            * Provides Chi2 coefficient and number of degrees of freedom for each combination
            * of feature and classifier.
            *
            * Chi squared test is a statistical measure that helps establish the dependence of
            * two categorical variables. In machine learning, it can be used to determine whether
            * a classifier is dependent on a certain feature, and thus helps in feature selection.
            * This test can only be used when both variables are categorical.
            *
            * @param samples The samples or dependent values in DATASET(DiscreteField) format
            * @param features The features or independent values in DATASET(DiscreteField) format
            * @return DATASET(Chi2_Result) Chi square values and degrees of freedom for each
            *         combination of feature and classifier, per work item.
            * @see ML_Core.Types.Chi2_Result
            *
            **/
            EXPORT DATASET(Chi2_Result) Chi2(DATASET(DiscreteField) features, DATASET(DiscreteField) samples) := FUNCTION
            ct := Contingency(samples, features);
            // Sums of rows
            featureSums := TABLE(ct, {wi,fnumber,snumber,fclass,c:=SUM(GROUP,cnt)},wi,fnumber,snumber,fclass);
            // Sums of columns
            sampleSums := TABLE(ct, {wi,fnumber,snumber,sclass,c:=SUM(GROUP,cnt)},wi,fnumber,snumber,sclass);
            // Total sum
            allSum := TABLE(ct, {wi,fnumber,snumber,c:=SUM(GROUP,cnt)},wi,fnumber,snumber);
            // The expected contingency table from the above sums (1)
            ex1 := JOIN(featureSums, sampleSums,
            LEFT.wi=RIGHT.wi and LEFT.fnumber=RIGHT.fnumber and LEFT.snumber=RIGHT.snumber,
            TRANSFORM({t_Work_Item wi, t_FieldNumber fnumber, t_FieldNumber snumber,
            t_Discrete fclass, t_Discrete sclass, REAL8 value},
            SELF.wi := LEFT.wi,
            SELF.value := LEFT.c * RIGHT.c,
            SELF.fnumber := LEFT.fnumber,
            SELF.snumber := LEFT.snumber,
            SELF.fclass := LEFT.fclass,
            SELF.sclass := RIGHT.sclass));
            // The expected contingency table from the above sums (2)
            ex2 := JOIN(ex1, allSum,
            LEFT.wi=RIGHT.wi and LEFT.fnumber=RIGHT.fnumber and LEFT.snumber=RIGHT.snumber,
            TRANSFORM(RECORDOF(ex1),
            SELF.value := LEFT.value/RIGHT.c,
            SELF := LEFT));
            // Degrees of freedom calculation dof = (ROWS - 1)*(COLS - 1)
            // Number of rows
            dof1 := TABLE(featureSums, {wi,fnumber,snumber,dof:=COUNT(GROUP)-1}, wi, fnumber,snumber);
            // Number of cols
            dof2 := TABLE(sampleSums, {wi,fnumber,snumber,dof:=COUNT(GROUP)-1}, wi, fnumber,snumber);
            // DOF
            dof3 := JOIN(dof1,dof2,
            LEFT.wi=RIGHT.wi and
            LEFT.fnumber=RIGHT.fnumber and
            LEFT.snumber=RIGHT.snumber,
            TRANSFORM(RECORDOF(dof1),
            SELF.dof := LEFT.dof*RIGHT.dof,
            SELF := LEFT));
            // Chi square calculation from expected and observed contingency tables.
            // LEFT OUTER JOIN flag is used as the contingency table does not contain entries for
            // combinations where no samples are available. The expected contingency table contains
            // entries for all combinations of sample and feature classes, hence the OUTER condition
            // is used to produce entries for all combinations of sample and feature classes.
            chi2_1 := JOIN(ex2, ct,
            LEFT.wi=RIGHT.wi and
            LEFT.fnumber=RIGHT.fnumber and
            LEFT.snumber=RIGHT.snumber and
            LEFT.fclass=RIGHT.fclass and
            LEFT.sclass=RIGHT.sclass,
            TRANSFORM(RECORDOF(ex2),
            SELF.value := POWER(RIGHT.cnt-LEFT.value,2)/LEFT.value,
            SELF := LEFT), LEFT OUTER);
            // Group by wi, fnumber, snumner
            chi2_2 := TABLE(chi2_1, {wi,fnumber,snumber,x2:=SUM(GROUP,value)},wi,fnumber,snumber);
            // Combine with calculated dof
            result := JOIN(chi2_2, dof3,
            LEFT.wi=RIGHT.wi and
            LEFT.fnumber=RIGHT.fnumber and
            LEFT.snumber=RIGHT.snumber,
            TRANSFORM(Chi2_Result,
            SELF.wi := LEFT.wi,
            SELF.fnumber := LEFT.fnumber,
            SELF.snumber := LEFT.snumber,
            SELF.dof := RIGHT.dof,
            SELF.x2 := LEFT.x2,
            SELF.p := 1 - Math.Distributions.Chi2_CDF(LEFT.x2, RIGHT.dof)));
            RETURN result;
            END; //Chi2
            END; // FeatureSelection
            /**
            * This sub module provides various tests that help evaluate the effectiveness of clustering
            * algorithms.
            */
            EXPORT Clustering := MODULE
            /**
            * ARI
            *
            * The Rand index is a measure of the similarity between
            * two data clusterings. Adjusted Rand Index (ARI) is a
            * version of rand index which is corrected for chance.
            * This measure assumes values between -1 and 1. It produces values close to zero
            * for random clusterings, values close to 1 for good clusterings
            * and values close to -1 for clusterings that are worse than random guesses.
            *
            * @param predicted The labels predicted by the model in DATASET(ClusteringLabels) Format
            * @param actual The actual labels, or the &amp;apos;Ground Truth&amp;apos; in DATASET(ClusteringLabels) Format
            * @return DATASET(ARI_Result) The adjusted rand index per work item
            * @see ML_Core.Types.ClusterLabels, ML_Core.Types.ARI_Result
            *
            **/
            EXPORT DATASET(ARI_Result) ARI(DATASET(ClusterLabels) predicted, DATASET(ClusterLabels) actual) := FUNCTION
            // Convert input parameter to DiscreteField to use as input for contingency
            conv1 := PROJECT(predicted, TRANSFORM(Types.DiscreteField,
            SELF.wi := LEFT.wi,
            SELF.number := 1,
            SELF.id := LEFT.id,
            SELF.value := LEFT.label));

            conv2 := PROJECT(actual, TRANSFORM(Types.DiscreteField,
            SELF.wi := LEFT.wi,
            SELF.number := 1,
            SELF.id := LEFT.id,
            SELF.value := LEFT.label));
            // Get contingency table
            ct := FeatureSelection.contingency(conv1, conv2);
            // Produce the sums required for computation of ARI
            // Row sums choose 2 (Number of pair combinations i.e nC2)
            rowSumsC2 := TABLE(ct, {wi, fclass, c:=SUM(GROUP,cnt)*(SUM(GROUP,cnt)-1)/2}, wi, fclass);
            // Column sums choose 2
            colSumsC2 := TABLE(ct, {wi, sclass, c:=SUM(GROUP,cnt)*(SUM(GROUP,cnt)-1)/2}, wi, sclass);
            // Total sum choose 2
            allSumC2 := TABLE(ct, {wi, REAL8 value:=SUM(GROUP,cnt)*(SUM(GROUP,cnt)-1)/2}, wi);
            // Sum of obtained row sums
            a := TABLE(rowSumsC2, {wi, REAL8 value:=SUM(GROUP,c)}, wi);
            // Sum of obtained column sums
            b := TABLE(colSumsC2, {wi, REAL8 value:=SUM(GROUP,c)}, wi);
            // Convert all items &amp;apos;n&amp;apos; of contingency table to &amp;apos;nC2&amp;apos;
            ct1 := PROJECT(ct, TRANSFORM(RECORDOF(ct),
            SELF.cnt := LEFT.cnt*(LEFT.cnt-1)/2,
            SELF := LEFT));
            // Sums of combinations of diagonal elements, obtained from above
            nij := TABLE(ct1, {wi, REAL8 value:=SUM(GROUP,cnt)}, wi);
            // Check for trivial cases for each work item
            n_samples := TABLE(ct, {wi, INTEGER value:=SUM(GROUP,cnt)});
            n_classes0 := TABLE(actual, {wi, label}, wi, label);
            n_classes := TABLE(n_classes0, {wi, INTEGER value:=COUNT(GROUP)}, wi);
            n_clusters0 := TABLE(predicted, {wi, label}, wi, label);
            n_clusters := TABLE(n_clusters0, {wi, INTEGER value:=COUNT(GROUP)}, wi);
            // Criterion for checking --
            // n_classess = n_clusters = 1 or
            // n_classess = n_clusters = 0 or
            // n_classess = n_clusters = n_samples
            isTrivial := JOIN(n_classes, n_clusters,
            LEFT.wi = RIGHT.wi,
            TRANSFORM({t_Work_Item wi, INTEGER a, INTEGER b,
            INTEGER c, BOOLEAN value},
            SELF.wi := LEFT.wi,
            SELF.a := n_samples(wi = SELF.wi)[1].value,
            SELF.b := LEFT.value,
            SELF.c := RIGHT.value,
            SELF.value := IF(((SELF.b = SELF.c AND
            (SELF.b = 1 OR SELF.b = 0)) OR
            (SELF.b = SELF.c AND
            SELF.c = SELF.a)),
            TRUE, FALSE)));
            // Compute ARI using information obtained
            ari := JOIN([a,b,nij,allSumC2],
            LEFT.wi = RIGHT.wi,
            TRANSFORM({t_Work_Item wi, INTEGER a, INTEGER b,
            INTEGER nij, INTEGER n, t_FieldReal value},
            SELF.wi := LEFT.wi,
            SELF.a := ROWS(LEFT)[1].value,
            SELF.b := ROWS(LEFT)[2].value,
            SELF.nij := ROWS(LEFT)[3].value,
            SELF.n := ROWS(LEFT)[4].value,
            SELF.value := IF(isTrivial(wi = SELF.wi)[1].value, 1,
            (SELF.nij - SELF.a*SELF.b/SELF.n)/
            (0.5*(SELF.a + SELF.b) - SELF.a*SELF.b/SELF.n))),
            SORTED(wi));
            // Remove unnecessary fields
            ari1 := TABLE(ari,{wi,value});
            RETURN ari1;
            END; // ARI
            /**
            * SampleSilhouetteScore
            *
            * Silhouette analysis measures the closeness of a point, both with its assigned cluster
            * and with other clusters. It provides an easy way of finding the optimum value for
            * k during k-means clustering. Silhouette values lie in the range of (-1, 1). A value of +1
            * indicates that the sample point is far away from its neighboring cluster and very
            * close to the cluster to which it is assigned.
            *
            * The euclidian distance metric is used to measure the distances between points.
            *
            * @param samples The datapoints / independent data in DATASET(NumericField) format
            * @param labels The labels assigned to these datapoints in DATASET(ClusterLabels) format
            * @result DATASET(SampleSilhouette_Result) The silhouette coefficient per sample, per work item
            * @see ML_Core.Types.SampleSilhouette_Result
            *
            */
            EXPORT DATASET(SampleSilhouette_Result) SampleSilhouetteScore(DATASET(NumericField) samples,
            DATASET(ClusterLabels) labels) := FUNCTION
            // Combine labels and samples
            points := JOIN(samples, labels,LEFT.wi = RIGHT.wi and LEFT.id = RIGHT.id);
            // Finding a values
            // Create all pairs of points with same cluster
            // ( Also calculate squared distance between their individual features as a
            //   step to calculate the distance between them )
            a1 := JOIN(points,points,
            LEFT.wi=RIGHT.wi and
            LEFT.number=RIGHT.number and
            LEFT.id &amp;lt;&amp;gt; RIGHT.id and
            LEFT.label=RIGHT.label,
            TRANSFORM({t_Work_Item wi, t_RecordId id1, t_RecordId id2,
            t_RecordId number, t_RecordId label, t_FieldReal sq_diff},
            SELF.wi := LEFT.wi,
            SELF.id1 := LEFT.id,
            SELF.id2 := RIGHT.id,
            SELF.number := LEFT.number,
            SELF.label := LEFT.label,
            SELF.sq_diff := POWER(LEFT.value-RIGHT.value,2)));
            // Find distance between these points
            a2 := TABLE(a1, {wi,id1,id2,label,dist:=SQRT(SUM(GROUP,sq_diff))},wi,id1,id2,label);
            // Find average distance for each point
            a3 := TABLE(a2, {wi, id:=id1, label,value:=AVE(GROUP,dist)}, wi,id1,label);
            // Finding b values
            // Form all pairs of points from different clusters
            // (Also calculate the squared difference between individual features)
            b1 := JOIN(points,points,
            LEFT.wi=RIGHT.wi and
            LEFT.number=RIGHT.number and
            LEFT.id &amp;lt;&amp;gt; RIGHT.id and
            LEFT.label &amp;lt;&amp;gt; RIGHT.label,
            TRANSFORM({t_Work_Item wi, t_RecordId id1, t_RecordId id2, t_RecordId Llabel,
            t_RecordId number, t_RecordId Rlabel, t_FieldReal sq_diff},
            SELF.wi := LEFT.wi,
            SELF.id1 := LEFT.id,
            SELF.id2 := RIGHT.id,
            SELF.number := LEFT.number,
            SELF.Llabel := LEFT.label,
            SELF.Rlabel := RIGHT.label,
            SELF.sq_diff := POWER(LEFT.value-RIGHT.value,2)));
            // Find distance between these pairs
            b2 := TABLE(b1,
            {wi,id1,id2,Llabel,Rlabel,dist:=SQRT(SUM(GROUP,sq_diff))},
            wi,id1,id2,Llabel,Rlabel);
            // Average these to find average distance of each point from every cluster
            b3 := TABLE(b2,
            {wi,id:=id1,Llabel,Rlabel,avgDist:=AVE(GROUP,dist)},
            wi,id1,Llabel,Rlabel);
            // Find minimum to get the minimum average distance to another cluster
            // for each point, which is the b value
            b4 := TABLE(b3,
            {wi,id,label:=Llabel,value:=MIN(GROUP,avgDist)},
            wi,id,Llabel);
            // The Silhouette coefficient / score for each sample datapoint
            sampleCoeffs := JOIN(a3,b4,
            LEFT.id=RIGHT.id and LEFT.wi=RIGHT.wi,
            TRANSFORM({t_Work_Item wi, t_RecordId id, t_RecordId label, t_FieldReal value},
            SELF.wi := LEFT.wi,
            SELF.id := LEFT.id,
            SELF.label := LEFT.label,
            SELF.value := (RIGHT.value-LEFT.value)/MAX(RIGHT.value,LEFT.value)));
            // Remove unnecessary fields
            sampleCoeffs2 := TABLE(sampleCoeffs,{wi,id,value});
            // Find single clusters
            singleClusters := TABLE(points,{wi, label, cnt:=COUNT(GROUP)}, wi,label)(cnt=1);
            // Silhouette coefficients for these clusters = 1
            singleCoeffs := JOIN(points, singleClusters,
            LEFT.wi=RIGHT.wi and
            LEFT.label=RIGHT.label,
            TRANSFORM({t_Work_Item wi, t_RecordId id, t_FieldReal value},
            SELF.wi := LEFT.wi,
            SELF.id := LEFT.id,
            SELF.value := 1));
            // Combine all scores
            result := MERGE([sampleCoeffs2, singleCoeffs], SORTED(wi,id,value));
            RETURN result;
            END; // SampleSilhouetteScore
            /**
            * SilhouetteScore
            *
            * Silhouette analysis measures the closeness of a point, both with its assigned cluster
            * and with other clusters. It provides an easy way of finding the optimum value for
            * k during k-means clustering. Silhouette values lie in the range of (-1, 1). A value of +1
            * indicates that the sample point is far away from its neighboring cluster and very
            * close to the cluster to which it is assigned.
            *
            * The euclidian distance metric is used to measure the distances between points.
            *
            * This function produces an average over SampleSilhouetteScore
            *
            * @param samples The datapoints / independent data in DATASET(NumericField) format
            * @param labels The labels assigned to these datapoints in DATASET(ClusterLabels) format
            * @result DATASET(Silhouette_Result) The silhouette coefficient per work item
            * @see ML_Core.Types.SampleSilhouette_Result, ML_Core.Analysis.SampleSilhouetteScore
            *
            */
            EXPORT DATASET(Silhouette_Result) SilhouetteScore(DATASET(NumericField) samples, DATASET(ClusterLabels) labels) := FUNCTION
            sampleCoeffs := SampleSilhouetteScore(samples,labels);
            totalCoeffs := TABLE(sampleCoeffs, {wi,score:=AVE(GROUP,value)}, wi);
            RETURN totalCoeffs;
            END; // SilhouetteScore
            END; // Clustering
            END; // Analysis&amp;#10;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;constants&quot;
            name=&quot;Constants&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Constants.ecl&quot;
            ts=&quot;1621960335000000&quot;&gt;
            /**
            * Useful constants used in ML.
            */
            EXPORT Constants := MODULE
            /**
            * Constant PI
            */
            EXPORT Pi := 3.1415926535897932384626433;
            /**
            * Constant square root of 2
            */
            EXPORT Root_2 := 1.4142135623730950488016887;

            END;&amp;#10;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;modelops2&quot;
            name=&quot;ModelOps2&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl&quot;
            ts=&quot;1621960335000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
            ############################################################################## */
            IMPORT $ AS ML_Core;
            IMPORT ML_Core.Types;

            NumericField := Types.NumericField;
            Layout_Model2 := Types.Layout_Model2;
            t_indexes := Types.t_indexes;
            t_Work_Item := Types.t_Work_Item;
            t_FieldReal := Types.t_FieldReal;

            /**
            * This module provides a set of operations to provide manipulation of machine
            * learning models (version 2) in the Types.Layout_Model2 format.
            *
            * &amp;lt;p&amp;gt;Layout_Model2 defines a flexible structure that allows storage of model information for
            * any Machine Learning algorithm.
            *
            * &amp;lt;p&amp;gt;The model is based on a &amp;quot;Naming Tree&amp;quot; paradigm.
            *
            * &amp;lt;p&amp;gt;The naming tree is a data structure that allows a hierarchical name (e.g.
            * object-id) to be attached to each data-cell.  Examples of naming-trees are
            * OID trees such as those used in various network identifiers such as MIBs.
            *
            * &amp;lt;p&amp;gt;This structure is used within ML to store model information.  It is a
            * useful format for several reasons:&amp;lt;ul&amp;gt;
            * &amp;lt;li&amp;gt;It has the flexibility to store complex sets of data in a generic way.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;It easily stores scalar as well as matrix oriented data.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;It allows a model to contain data elements within scopes that are
            *   defined at different level.  For example, part of the model may be defined
            *   globally, another may be common for a bundle, while another section is
            *   specific to a given module.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;It readily allows composite models to be created by encapsulating
            *   entire complex models (or sets of models) within branches of another model.
            *   The individual models can then be extracted from the composite model, and
            *   passed to the modules that created them.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
            *
            * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Theory of Operation&amp;lt;/b&amp;gt;
            *
            * &amp;lt;p&amp;gt;The naming tree (NT) is conceptually simple.  Each cell is identified by a
            * hierarchical numbering scheme of arbitrary depth.  Take, for example, the following
            * NT:
            *&amp;lt;pre&amp;gt;
            * 1
            *   1.1
            *     1.1.1
            *     1.1.2
            *   1.2
            *     1.2.1
            *     1.2.2
            * 2
            *&amp;lt;/pre&amp;gt;
            * This tree defines the following leaf (scalar) elements: 1.1.1, 1.1.2, 1.2.1, 1.2.2, 2.
            * &amp;lt;p&amp;gt;Note that the deepest node on any branch is considered a leaf, and branches can be of
            * variable depth.  Note also that there is no explicit creation of branch nodes.  The
            * branches are implicitly defined by the ids of the leafs.
            * &amp;lt;p&amp;gt;In this example, node 1.1 can be thought as representing an array, thought it could
            * also be thought of as a structure of two distinct scalars, depending on whether the user
            * expects a variable length list under 1.1 (i.e. 1.1.1 - 1.1.N) or a fixed set of cells.
            * &amp;lt;p&amp;gt;Likewise node 1 can be thought of as a matrix (1.r.c, where r is the row index and c
            * is the column index), in cases where r and c are of variable size.
            *
            * &amp;lt;p&amp;gt;This naming tree also supports the myriad interface, allowing multiple independent
            * work-items to be represented, each of which may duplicate the same structure.
            *
            * &amp;lt;p&amp;gt;The id is represented by an ECL SET of Unsigned identifiers (e.g. [1,2,1] represents the OID 1.2.1).
            *
            * &amp;lt;p&amp;gt;Each cell is defined by three fields: wi (work-item-id), value (the cell contents) and
            * indexes (the id).
            * &amp;lt;p&amp;gt;A naming tree can be constructed as an inline dataset.  For example, the following
            * creates the tree in the example above:
            &amp;lt;pre&amp;gt;
            *   DATASET([{1, 3.2, [1,1,1]},
            *            {1, .0297, [1,1,2]},
            *            {1, 2.0, [1,2,1]},
            *            {1, 1550, [1,2,2]},
            *            {1, 8.1, [2]}], Layout_Model2);
            * &amp;lt;/pre&amp;gt;
            * &amp;lt;p&amp;gt;There are attributes in this module to assist with manipulation of naming trees:&amp;lt;ul&amp;gt;
            * &amp;lt;li&amp;gt;Creating a NT from a NumericField matrix.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;Extracting a NumericField matrix from an NT branch.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;Inserting an NT onto a branch of another NT.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;Extracting an NT from a branch of an NT.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
            *
            * @see Types.Layout_Model2
            */
            EXPORT ModelOps2 := MODULE
            SHARED empty_array := DATASET([], Layout_Model2);
            /**
            * Extract an inner sub-tree from an existing model.
            * &amp;lt;p&amp;gt;Work-item = 0 (default) will extract all work-items
            * &amp;lt;p&amp;gt;This is the opposite of Insert.
            *
            * For example:
            * &amp;lt;pre&amp;gt;
            * If I have a tree:
            *  1
            *  2
            *  3
            *   3.1
            *   3.2
            * &amp;lt;/pre&amp;gt;
            * and I extract from index 3, it will return the Naming Tree:
            * &amp;lt;pre&amp;gt;
            *  1
            *  2
            * &amp;lt;/pre&amp;gt;
            * &amp;lt;p&amp;gt;containing the two sub-cells of the original index 3
            *
            * @param mod The model from which to extract the sub-tree.
            * @param fromIndx The index from which to extract the subtree.
            * @param fromWi The work-item to extract or 0 to extract the same
            *               sub-tree from all work-items.
            * @return A model containing all of the sub-cells below fromIndx
            *         with the indexes adjusted to the top of the tree.
            *
            */
            EXPORT DATASET(Layout_Model2) Extract(DATASET(Layout_Model2) mod,
            t_indexes fromIndx, t_work_item fromWi=0) := FUNCTION
            Layout_Model2 extract_indexes(Layout_Model2 a, UNSIGNED prefixSize) := TRANSFORM
            outIndex := a.indexes[prefixSize+1.. ];
            SELF.indexes := outIndex;
            SELF         := a;
            END;
            prefixSize := COUNT(fromIndx);
            filter := mod.indexes[..prefixSize] = fromIndx AND (fromWi = 0 OR mod.wi = fromWi);
            outMod    := PROJECT(mod(filter), extract_indexes(LEFT, prefixSize));
            return outMod;
            END;
            /**
            * Extend the indices of a model to fit within a deeper model.
            *
            * &amp;lt;p&amp;gt;For example, a cell with index [1,2] could be moved to index [1,2,3,1,2]
            * by using atIndex := [1,2,3].
            *
            * @param mod The model whose indexes are to be extended.
            * @param atIndex The prefix indexes to be prepended to the indexes of each cell
            *                in mod.
            * @return A model with extended indexes.
            *
            */
            EXPORT DATASET(Layout_Model2) ExtendIndices(DATASET(Layout_Model2) mod, t_indexes atIndex) := FUNCTION
            Layout_Model2 extend_indexes(Layout_Model2 t) := TRANSFORM
            indxs := atIndex + t.indexes;
            SELF.indexes := indxs;
            SELF         := t;
            END;
            outMod := PROJECT(mod, extend_indexes(LEFT));
            return outMod;
            END;
            /**
            * Insert a model into a sub-tree of an existing model.
            *
            * &amp;lt;p&amp;gt;Extends the indexes of the provided model to fit onto a branch
            * of another model, and concatenates the two models. This is the opposite of
            * extract.
            * For example:
            * &amp;lt;pre&amp;gt;
            * If I have a model:
            * 1
            * 2
            * and a second model:
            * 1
            * 2
            * 3
            * That I would like to insert into the first tree at index 3, I would
            * end up with the tree:
            * 1
            * 2
            * 3
            *  3.1
            *  3.2
            *  3.3
            * &amp;lt;/pre&amp;gt;
            * Example code:
            * &amp;lt;pre&amp;gt;
            * mod3 := Insert(mod1, mod2, [3]);
            * &amp;lt;/pre&amp;gt;
            * @param mod1 The first (base) model.
            * @param mod2 The sub-model that is to be inserted into mod1.
            * @param atIndx The index prefix (in mod1) that will contain the cells from mod2.
            * @return a new model containing the cells from both models.
            *
            */
            EXPORT DATASET(Layout_Model2) Insert(DATASET(Layout_Model2) mod1, DATASET(Layout_Model2) mod2, t_indexes atIndx) := FUNCTION
            mod2a := ExtendIndices(mod2, atIndx);
            RETURN mod1 + mod2a;
            END;
            /**
            * Convert a two-level model or model sub-tree into a NumericField dataset.
            *
            * &amp;lt;p&amp;gt;The last two indexes of the model subtree are used as the indexes for the NumericField
            * matrix.  The second to last index corresponds to the NF&amp;apos;s id field and the
            * last index corresponds to the NF&amp;apos;s number field.
            *
            * @param mod The model from which to extract the NumericField matrix.
            * @param fromIndx The index from which to extract the matrix. Example: [3,1,5].
            *                  The default is from the top of the tree i.e. [].
            * @return NumericField matrix in DATASET(NumericField) format.
            *
            */
            EXPORT DATASET(NumericField) ToNumericField(DATASET(Layout_Model2) mod, t_indexes fromIndx = []) := FUNCTION
            NumericField mod_to_nf(Layout_Model2 t) := TRANSFORM
            prefixSize := COUNT(fromIndx);
            suffix := t.indexes[prefixSize+1.. ];
            SELF.id := suffix[1];
            SELF.number := suffix[2];
            SELF := t;
            END;
            prefixSize := COUNT(fromIndx);
            filter := mod.indexes[..prefixSize] = fromIndx;
            outCells := ASSERT(mod(filter), COUNT(indexes) = prefixSize + 2, &amp;apos;ModelOps2.ToNumericField: Extracted indexes must be exactly 2 dimensional.  Found &amp;apos;
            + (COUNT(indexes) - prefixSize), FAIL);
            outMod := PROJECT(outCells, mod_to_nf(LEFT));
            return outMod;
            END;
            /**
            * Convert a NumericField dataset to a 2 level model (or model subtree).
            *
            * &amp;lt;p&amp;gt;A two level model is created and appended to atIndex.
            * &amp;lt;p&amp;gt;The first new index will contain the value of the NumericField&amp;apos;s
            * id field, and the second will contain the value of the NumericField&amp;apos;s
            * number field.
            * &amp;lt;p&amp;gt;Example: If I have a NumericField with id=1 and number=3, and I use
            * atIndex = [3,1,5], it will create a Naming Tree cell with indexes:
            * [3,1,5,1,3].
            *
            * @param nf A NumericField dataset to be converted.
            * @param atIndex The index at which to place the new subtree e.g., [3,1,5].
            * @return DATASET(ntNumeric) Naming Tree.
            *
            */
            EXPORT DATASET(Layout_Model2) FromNumericField(DATASET(NumericField) nf, t_indexes atIndex=[]) := FUNCTION
            Layout_Model2 nf_to_mod(NumericField n) := TRANSFORM
            indexes := atIndex + [n.id, n.number];
            SELF.indexes := indexes;
            SELF         := n;
            END;
            outMod := PROJECT(nf, nf_to_mod(LEFT));
            RETURN outMod;
            END;
            /**
            * Get a single record (cell) from a model by index.
            *
            * @param mod The model (DATASET(layout_model2)) from which to extract the cell.
            * @param indxs The id of the cell to extract (e.g. [3,1,5]).
            * @param wi_num The work-item number to extract the cell from, default = 1.
            * @return The model cell (Layout_Model2) or an empty cell (wi=0) if not found.
            *
            */
            EXPORT Layout_Model2 GetItem(DATASET(Layout_Model2) mod, t_indexes indxs, wi_num=1) := FUNCTION
            RETURN mod(indexes=indxs AND wi=wi_num)[1];
            END;
            /**
            * Add a single record (cell) to an model at a given set of coordinates.
            *
            * @param mod The model to which to add a cell.
            * @param wi The work-item associated with the cell.
            * @param indexes The indices for the cell.
            * @param value The value of the cell.
            * @return Model with the added cell.
            *
            */
            EXPORT DATASET(Layout_Model2) SetItem(DATASET(Layout_Model2) mod, t_work_item wi, t_indexes indexes, t_fieldReal value) := FUNCTION
            RETURN mod + DATASET([{wi, value, indexes}], Layout_Model2);
            END;
            END;&amp;#10;
            &lt;/Attribute&gt;
            &lt;/Module&gt;
            &lt;Module key=&quot;_versions.ml_core.v3_2_2.ml_core.interfaces&quot; name=&quot;_versions.ML_Core.V3_2_2.ML_Core.Interfaces&quot;&gt;
            &lt;Attribute key=&quot;iclassify2&quot;
            name=&quot;IClassify2&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Interfaces/IClassify2.ecl&quot;
            ts=&quot;1621960335000000&quot;&gt;
            IMPORT $.^ AS ML_Core;
            IMPORT ML_Core.Types AS Types;

            Layout_Model2 := Types.Layout_Model2;
            Classify_Result := Types.Classify_Result;
            NumericField := Types.NumericField;
            DiscreteField := Types.DiscreteField;
            Confusion_Detail := Types.Confusion_Detail;
            Classification_Accuracy := Types.Classification_Accuracy;
            Class_Accuracy := Types.Class_Accuracy;

            /**
            * Interface definition for Classification (Version 2).
            * Classification learns a function that maps a set of input data
            * to one or more output class-label (i.e. Discrete) variables.
            * The resulting learned function is known as the model.
            * That model can then be used repetitively to predict the class(es)
            * for each sample when presented with new input data.
            * Actual implementation modules will probably take configuration
            * parameters to control the classification process.
            * The Classification modules also expose attributes for assessing
            * the effectiveness of the classification.
            */
            EXPORT IClassify2 := MODULE, VIRTUAL
            /**
            * Calculate the model to fit the independent data to the observed
            * classes (i.e. dependent data).
            * @param indepenedents The observed independent (explanatory) values.
            * @param dependents The observed dependent(class label) values.
            * @return The encoded model.
            * @see Types.Layout_Model2
            * @see Types.NumericField
            * @see Types.DiscreteField
            */
            EXPORT DATASET(Layout_Model2) GetModel(DATASET(NumericField) independents,
            DATASET(DiscreteField) dependents);
            /**
            * Classify the observations using a model.
            * @param model The model, which must be produced by a corresponding
            * getModel function.
            * @param observations New observations (independent data) to be classified.
            * @return Predicted class values.
            *
            */
            EXPORT DATASET(DiscreteField) Classify(DATASET(Layout_Model2) model,
            DATASET(NumericField) observations);
            /**
            * Return accuracy metrics for the given set of test data
            * &amp;lt;p&amp;gt;This is equivalent to calling Predict followed by
            * Analysis.Classification.Accuracy(...).
            *
            * &amp;lt;p&amp;gt;Provides accuracy statistics as follows:&amp;lt;ul&amp;gt;
            * &amp;lt;li&amp;gt;errCount -- The number of misclassified samples.&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;errPct -- The percentage of samples that were misclasified (0.0 - 1.0).&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;RawAccuracy -- The percentage of samples properly classified (0.0 - 1.0).&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;PoD -- Power of Discrimination.  Indicates how this classification performed
            *           relative to a random guess of class.  Zero or negative indicates that
            *           the classification was no better than a random guess.  1.0 indicates a
            *           perfect classification.  For example if there are two equiprobable classes,
            *           then a random guess would be right about 50% of the time.  If this
            *           classification had a Raw Accuracy of 75%, then its PoD would be .5
            *           (half way between a random guess and perfection).&amp;lt;/li&amp;gt;
            * &amp;lt;li&amp;gt;PoDE -- Power of Discrimination Extended.  Indicates how this classification
            *           performed relative to guessing the most frequent class (i.e. the trivial
            *           solution).  Zero or negative indicates that this classification is no
            *           better than the trivial solution.  1.0 indicates perfect classification.
            *           For example, if 95% of the samples were of class 1, then the trivial
            *           solution would be right 95% of the time.  If this classification had a
            *           raw accuracy of 97.5%, its PoDE would be .5 (i.e. half way between
            *           trivial solution and perfection).&amp;lt;/li&amp;gt;
            * &amp;lt;p&amp;gt;Normally, this should be called using data samples that were not included in the
            * training set.  In that case, these statistics are considered Out-of-Sample error
            * statistics.  If it is called with the X and Y from the training set, it provides
            * In-Sample error statistics, which should never be used to rate the classification model.
            *
            *
            * @param model The encoded model as returned from GetModel.
            * @param actuals The actual class values associated with the observations.
            * @param observations The independent (explanatory) values on which to base the test.
            * @return DATSET(Classification_Accuracy), one record per work-item.
            * @see Types.Classification_Accuracy
            *
            */
            EXPORT DATASET(Classification_Accuracy) Accuracy(DATASET(Layout_Model2) model,
            DATASET(DiscreteField) actuals, DATASET(NumericField) observations
            ) := FUNCTION
            predicted := Classify(model, observations);
            RETURN ML_Core.Analysis.Classification.Accuracy(predicted, actuals);
            END;
            /**
            * Return class-level accuracy by class metrics for the given
            * set of test data.
            * &amp;lt;p&amp;gt;This is equivalent to calling Predict followed by
            * Analysis.Classification.AccuracyByClass(...).
            *
            * @param model The encoded model as returned from GetModel.
            * @param actuals The actual class values associated with the observations.
            * @param observations The independent (explanatory) values on which to base the test
            * @return DATASET(Class_Accuracy), one record per work-item per class.
            * @see Types.Class_Accuracy.
            *
            */
            EXPORT DATASET(Class_Accuracy) AccuracyByClass(DATASET(Layout_Model2) model,
            DATASET(DiscreteField) actuals,
            DATASET(NumericField) observations
            ) := FUNCTION
            predicted := Classify(model, observations);
            RETURN ML_Core.Analysis.Classification.AccuracyByClass(predicted, actuals);
            END;
            /**
            * Return the confusion matrix for a set of test data.
            * This is equivalent to calling Predict follwed by
            * Analysis.Classification.ConfusionMatrix(...).
            * &amp;lt;p&amp;gt;The confusion matrix indicates the number of datapoints that were classified correctly or incorrectly
            * for each class label.
            * &amp;lt;p&amp;gt;The matrix is provided as a matrix of size numClasses x numClasses with fields as follows:&amp;lt;ul&amp;gt;
            *   &amp;lt;li&amp;gt;&amp;apos;wi&amp;apos; -- The work item id&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;&amp;apos;pred&amp;apos; -- the predicted class label (from Classify).&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;&amp;apos;actual&amp;apos; -- the actual (target) class label.&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;&amp;apos;samples&amp;apos; -- the count of samples that were predicted as &amp;apos;pred&amp;apos;, but should have been &amp;apos;actual&amp;apos;.&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;&amp;apos;totSamples&amp;apos; -- the total number of samples that were predicted as &amp;apos;pred&amp;apos;.&amp;lt;/li&amp;gt;
            *   &amp;lt;li&amp;gt;&amp;apos;pctSamples&amp;apos; -- the percentage of all samples that were predicted as &amp;apos;pred&amp;apos;, that should
            *                have been &amp;apos;actual&amp;apos; (i.e. samples / totSamples)&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
            *
            * &amp;lt;p&amp;gt;This is a useful tool for understanding how the algorithm achieved the overall accuracy.  For example:
            * were the common classes mostly correct, while less common classes often misclassified?  Which
            * classes were most often confused?
            *
            * This should be called with test data that is independent of the training data in order to understand
            * the out-of-sample (i.e. generalization) performance.
            *
            * @param model The encoded model as returned from GetModel.
            * @param actuals The actual class values.
            * @param observations The independent (explanatory) values.
            * @return DATASET(Confusion_Detail), one record per cell of the confusion matrix.
            * @see Types.Confusion_Detail.
            */
            EXPORT DATASET(Confusion_Detail) ConfusionMatrix(DATASET(Layout_Model2) model,
            DATASET(DiscreteField) actuals, DATASET(NumericField) observations
            ) := FUNCTION
            predicted := Classify(model, observations);
            RETURN ML_Core.Analysis.Classification.ConfusionMatrix(predicted, actuals);
            END;
            END;&amp;#10;
            &lt;/Attribute&gt;
            &lt;/Module&gt;
            &lt;Module key=&quot;_versions.learningtrees.v1_1_1.learningtrees.internal&quot; name=&quot;_versions.LearningTrees.V1_1_1.LearningTrees.internal&quot;&gt;
            &lt;Attribute key=&quot;rf_base&quot;
            name=&quot;RF_Base&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl&quot;
            ts=&quot;1621960363000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
            ############################################################################## */
            IMPORT $.^ AS LT;
            IMPORT LT.Internal AS int;
            IMPORT LT.LT_Types as Types;
            IMPORT ML_Core as ML;
            IMPORT ML.Types AS CTypes;
            IMPORT std.system.Thorlib;
            IMPORT ML_Core.ModelOps2;

            GenField := Types.GenField;
            ModelStats := Types.ModelStats;
            t_Work_Item := CTypes.t_Work_Item;
            t_Count := CTypes.t_Count;
            t_RecordId := CTypes.t_RecordID;
            t_FieldNumber := CTypes.t_FieldNumber;
            t_TreeId := t_FieldNumber;
            Layout_Model := CTypes.Layout_Model;
            wiInfo := Types.wiInfo;
            TreeNodeDat := Types.TreeNodeDat;
            NumericField := CTypes.NumericField;
            DiscreteField := CTypes.DiscreteField;
            Layout_Model2 := CTypes.Layout_Model2;
            FeatureImportanceRec := Types.FeatureImportanceRec;
            nfNull := DATASET([], NumericField);

            /**
            * Base Module for Random Forest algorithms.  Modules for RF Classification or Regression
            * are based on this one.
            * The random forest algorithm used is based on Brieman 2001 with extensions.
            * It provides the attributes to set up the forest as well as storing of the resulting forest
            * in a common model format.  It also provides various analytic methods.
            *
            * Theory of Operation
            *
            * The heart of the random forest algorithm is the building of a forest model (multiple
            * diverse decision trees) by segmenting the training data through binary splits that
            * increase the uniformity of the dependent variable as the tree is developed.
            * In random forest, the trees are developed until the data after the final split is
            * totally pure (i.e. all members have the same value of the dependent variable), or
            * a maximum tree depth is encountered (configurable -- see maxDepth parameter).  If a
            * maximum depth is encountered with an impure group on either or both sides, the remaining
            * points are aggregated through an appropriate means (implementation dependent).
            * When a pure group is obtained (either through purity or aggregation), the data points
            * in that group are summarized by a &amp;quot;leaf node&amp;quot;.  Each tree is therefore composed of
            * split-nodes (i.e. branches) and leaf-nodes.
            * The resulting forest model can then be used to perform predictions of the dependent
            * variable given hitherto unseen samples of the independent variable.  In the case of
            * a Regression Forest, the unobserved dependent variable is predicted as a continuous
            * number.  In the case of a Classification Forest, the dependent variable takes the form
            * of a discrete class identifier, and the prediction method is called &amp;quot;Classify&amp;quot;.
            * This implementation allows the independent variables to be continuous or discrete,
            * and supports both ordered variables (e.g. quantitative -- real-numbers, integers) and
            * categorical (aka &amp;quot;nominal&amp;quot;) variables, which can represent qualitative info such as
            * type, color, state, which are encoded with integer values. These different types of
            * independent variables are encoded using the GenField dataset layout.
            * Once a forest model has been created, new values are predicted by running each
            * datapoint down the tree for each tree in the forest, arriving at a single leaf for
            * each datapoint in each tree.  The final prediction is arrived at by aggregating
            * the leaf value of all the trees in the forest for that point.  Depending on whether
            * we are classifying or predicting a continous value (i.e. regression), a different
            * aggregation method is used.  For classification, a voting method is used.  The most
            * commonly predicted class is the final result.  For regression, the mean of all the
            * trees&amp;apos; predictions is returned as the final result.
            * Each tree can be thought of as an &amp;apos;overfit&amp;apos; model since they will fit to not only
            * the &amp;apos;signal&amp;apos; in the data, but also the &amp;apos;noise&amp;apos;.  The aggregation across the forest
            * averages out most of the noise (due to the diversity of the trees).  This is a
            * key strength of the random forest algorithm as it makes it robust against over-fitting.
            * The diversity of the forest is achieved in a number of ways:
            * 1) Each tree is built using a bootstrap of the original data.  That is, for each
            *    tree, the data is sampled with replacement, resulting in a different set of
            *    points used to create the tree.  On average, aroung 30% of the datapoints will
            *    be missing from each tree due to replication of other points.
            * 2) Each split node is created based on a random subset of features (the best split
            *    for each subset is used).  This randomly eliminates some possible branches
            *    for each split and causes each tree to grow in a unique fashion.
            * 3) Unless auto-binning is disabled, for variables with many values (e.g. continuous)
            *    the possible split points are randomly sampled so that only a smaller set of
            *    points are considered for each split.  This technique provides better performance
            *    while increasing the diversity of the trees in the forest, and is sometimes referred-
            *    to as &amp;quot;extremely randomized foests&amp;quot;.  This is the default mode of operation as it
            *    seems to provide strong benefits without significant down-side.
            * This base module provides the common methods for building and using the forest model,
            * while the derived modules (e.g. ClassificationForest and RegressionForest) overlay
            * virtual attributes that perform work specific to the type of forest.
            * The basic steps in building the tree are:
            * - Organize the input data:
            *   - Identify the work-items and number of training records and features
            *   - Ensure that the record ids are sequential
            *   - Create a map of each of the feature numbers for each work-item
            * - Generate random bootstrap samples for each tree
            * - Create numTree tree root nodes
            * - Replicate the training data bootstraps to each tree root
            * - Build the trees, one layer at a time by:
            *   - Randomly choose the featuresPerNode features to evaluate for a given level
            *   - Evaluate all possible splits on those features to find the feature and split-point
            *     that results in the most pure pair of sub-groups.  The criteria for evaluating
            *     splits is different for the different forest types.
            *   - Choose the best split, and create a split-node (branch) based on that split.
            *   - Create a left and right child node at the next level under the split-node.
            *   - Reallocate the data points from the node to the left or right child nodes.
            *   - If any group is pure (i.e. same dependent value for all members) or we&amp;apos;ve reached
            *     maxDepth, replace all the datapoints in that node with a single leaf node.
            * - At the end of the process, all the datapoints will have been absorbed by leaf nodes,
            *   and the resulting trees will contain only split-nodes and leaf-nodes.
            * - Note that a single common data structure (see LT_Types.TreeNodeData) is used to
            *   represent:
            *   - Data-points that need to be processed for a node (only during tree growing)
            *   - A split-node
            *   - A leaf-node
            * - The resulting tree-nodes representing the forest are converted to a Forest Model
            *   for later use in prediction or analysis.
            */
            EXPORT RF_Base(DATASET(GenField) X_in=DATASET([], GenField),
            DATASET(GenField) Y_In=DATASET([], GenField),
            UNSIGNED numTrees=100,
            UNSIGNED featuresPerNodeIn=0,
            UNSIGNED maxDepth=255,
            DATASET(NumericField) observWeights=nfNull) := MODULE
            SHARED haveObsWeights := EXISTS(observWeights);
            // Resequence ids to go from 1-numRecords.
            SHARED resequenceByWi(DATASET(GenField) dat) := FUNCTION
            // Dat should be evenly distributed at this point
            xGen := RECORD(GenField)
            t_RecordId newId := 0;
            END;
            xDat := PROJECT(dat, TRANSFORM(xGen, SELF := LEFT));
            xGen setNewIds(xGen l, xGen r) := TRANSFORM
            newId := IF(l.wi != r.wi, 1, IF(r.id = l.id, l.newId, l.newId + 1));
            SELF.newId := newId;
            SELF := r;
            END;
            xDatS := SORT(xDat, wi, id);
            xDat2 := ITERATE(xDatS, setNewIds(LEFT, RIGHT));
            outDat0 := PROJECT(xDat2, TRANSFORM(GenField, SELF.id := LEFT.newId, SELF := LEFT));
            outDat := DISTRIBUTE(outDat0, HASH32(wi, id));
            return outDat;
            END;
            SHARED autoBin := TRUE;
            SHARED autobinSize := 10;
            SHARED maxU4 := 4294967295; // Maximum value for an Unsigned 4
            SHARED maxR8 := 1.797693e+308; // Maximum value for a REAL8
            SHARED autobinSizeScald := autobinSize * maxU4; // Scaled auto-bin size for efficiency
            SHARED XD := DISTRIBUTE(X_in, HASH32(wi, id));
            SHARED YD := DISTRIBUTE(Y_in, HASH32(wi, id));
            SHARED XSD := SORT(XD, wi, id, number, LOCAL);
            SHARED YSD := SORT(YD, wi, LOCAL);  // Sort Y by work-item
            SHARED Rand01 := RANDOM()/maxU4; // Random number between zero and one.

            // P log P calculation for entropy.  Note that Shannon entropy uses log base 2 so the division by LN(2) is
            // to convert the base from e to 2.
            SHARED P_Log_P(REAL P) := IF(P=1, 0, -P* LN(P) / LN(2));

            SHARED empty_model := DATASET([], Layout_Model2);
            SHARED empty_data := DATASET([], GenField);
            // Abbreviations for Model Index definitions
            SHARED FM := Types.Forest_Model;
            SHARED FM1 := FM.Ind1;
            SHARED FMN3 := FM.Ind3_nodes;
            // Calculate work-item metadata
            // Each work-item needs its own metadata (i.e. numSamples, numFeatures, .  Construct that here.
            SHARED wiSamples := TABLE(YSD, {wi, numSamples := COUNT(GROUP), maxId := MAX(GROUP, id)}, wi);
            idFeatures := TABLE(XSD, {wi, id, numFeats := COUNT(GROUP), maxFNum := MAX(GROUP, number)}, wi, id, LOCAL);
            SHARED wiFeatures := TABLE(idFeatures, {wi, numFeatures := MAX(GROUP, numFeats), maxNum := MAX(GROUP, maxFNum)}, wi);
            wiMeta0 := JOIN(wiSamples, wiFeatures, LEFT.wi = RIGHT.wi, TRANSFORM({wiSamples, UNSIGNED numFeatures},
            SELF.numFeatures := RIGHT.numFeatures, SELF := LEFT));
            wiInfo makeMeta(wiMeta0 lr) := TRANSFORM
            // If featuresPerNode was passed in as zero (default), use the square root of the number of features,
            // which is a good rule of thumb.  In general, with multiple work-items of different sizes, it is best
            // to default featuresPerNode.
            fpt0 := IF(featuresPerNodeIn &amp;gt; 0, featuresPerNodeIn, TRUNCATE(SQRT(lr.numFeatures)));
            // In no case, let features per tree be greater than the number of features.
            SELF.featuresPerNode := MIN(fpt0, lr.numFeatures);
            SELF := lr;
            END;
            SHARED wiMeta := PROJECT(wiMeta0, makeMeta(LEFT));
            SHARED needsReseqTest := SUM(wiSamples, ABS(numSamples - maxId)) != 0;
            SHARED X := IF(needsReseqTest, resequenceByWi(XSD), XSD);
            SHARED Y := IF(needsReseqTest, resequenceByWi(YSD), YSD);
            // Create a map of feature number -&amp;gt; sequential feature number (1-numFeatures) for each wi.
            // Note: at this point, there has to be a record with id=1 for each work-item.
            // Overload the id field (which is not needed here) with a sequential id (1-numFeatures)
            // so that we can map between the two
            allFeatures := SORT(X(id=1), wi, number);
            allFeaturesG := GROUP(allFeatures, wi);
            featureMap0 := PROJECT(allFeaturesG, TRANSFORM(GenField, SELF.id := COUNTER, SELF := LEFT));
            SHARED featureMap := UNGROUP(featureMap0);
            SHARED needFeatureRenumbering := COUNT(featureMap) != SUM(wiFeatures, maxNum);
            SHARED allowNoProgress := IF(featuresPerNodeIn &amp;lt; MAX(featureMap, id), TRUE, FALSE);
            // If FALSE, tree will terminate when no progess can be made on any
            // feature.  For RF, should be TRUE since it may get a better choice
            // of features at the next level.  Set FALSE if featuresPerNode &amp;gt;= numFeatures,
            // since we will always be choosing from all features.
            // Data structure to hold the sample indexes (i.e Bootstrap Sample) for each treeId
            SHARED sampleIndx := RECORD
            t_TreeID treeId;
            t_RecordId id;     // Id within this tree
            t_RecordId origId; // The id of this sample in the original X,Y
            END;

            // treeSampleIndx has  &amp;lt;samples&amp;gt; sample indexes for each tree, sorted by tree.  This represents
            // the &amp;quot;Bootstrap Sample&amp;quot; for each tree using sampling with replacement.
            // It is used during tree initialization, and is also needed for analytics / validation so that
            // &amp;quot;out-of-bag&amp;quot; (OOB) samples can be created.  Use all cluster nodes to build the index, and
            // leave it distributed by tree-id.

            // Note: The approach is somewhat strange, but done for distributed performance.
            // Start from the samples.  Generate enough samples so that there are enough for the work-item
            // with the most samples.  We&amp;apos;ll use truncations of these samples for the same treeId across work-items.
            // So we only need to create the sampling index once per treeId.
            SHARED maxSampleSize := MAX(wiMeta, numSamples); // maximum samples for any work-item
            SHARED maxfeaturesPerNode := MAX(wiMeta, featuresPerNode); // maximum features for any work-item
            dummy := DATASET([{0,0,0}], sampleIndx);
            // Create one dummy sample per tree
            treeDummy := NORMALIZE(dummy, numTrees, TRANSFORM(sampleIndx, SELF.treeId := COUNTER, SELF := []));
            // Distribute by treeId to create the samples in parallel
            treeDummyD := DISTRIBUTE(treeDummy, treeId);
            // Now generate samples for each treeId in parallel
            // In the event that there is only one tree in the forest, the best result will
            // be gotten by using the full data (i.e. no sampling).
            treeSampleIndxSampled := NORMALIZE(treeDummyD, maxSampleSize, TRANSFORM(sampleIndx,
            SELF.origId := (RANDOM()%maxSampleSize) + 1,
            SELF.id := COUNTER,
            SELF := LEFT));
            treeSampleIndxNonSampled := NORMALIZE(treeDummyD, maxSampleSize, TRANSFORM(sampleIndx,
            SELF.origId := COUNTER,
            SELF.id := COUNTER,
            SELF := LEFT));
            SHARED treeSampleIndx := IF(numTrees &amp;gt; 1, treeSampleIndxSampled, treeSampleIndxNonSampled);
            // Function to randomly select features to use for each level of the tree building.
            // Each node is assigned a random subset of the features.
            SHARED DATASET(TreeNodeDat) SelectVarsForNodes(DATASET(TreeNodeDat) nodeDat) := FUNCTION
            // At this point, nodeDat should have one instance per id per node per tree per wi, distributed by (wi, treeId)
            // Nodes should be sorted by (at least) wi, treeId, nodeId at this point.
            // We are trying to choose featuresPerNode features out of the full set of features for each tree node
            // First, extract the set of treeNodes
            nodes := DEDUP(nodeDat, wi, treeId, nodeId, LOCAL);  // Now we have one record per node
            // Now, extend the the tree data.  Add a random number field and create &amp;lt;features&amp;gt; records for each tree.
            xTreeNodeDat := RECORD(TreeNodeDat)
            UNSIGNED numFeatures;
            UNSIGNED featuresPerNode;
            UNSIGNED rnd;
            END;
            // Note that each work-item may have a different value for numFeatures and featuresPerNode
            xTreeNodeDat makeXNodes(treeNodeDat l, wiInfo r) := TRANSFORM
            SELF.numFeatures := r.numFeatures;
            SELF.featuresPerNode := r.featuresPerNode;
            SELF := l;
            SELF := [];
            END;
            xNodes := JOIN(nodes, wiMeta, LEFT.wi = RIGHT.wi, makeXNodes(LEFT, RIGHT), LOOKUP, FEW);
            xTreeNodeDat getFeatures(xTreeNodeDat l, UNSIGNED c) := TRANSFORM
            // Choose twice as many as we need, so that when we remove duplicates, we will (almost always)
            // have at least the right number.  This is more efficient than enumerating all and picking &amp;lt;featuresPerNode&amp;gt;
            // from that set because numFeatures &amp;gt;&amp;gt; featuresPerNode.  We will occasionally get a tree that
            // has less than &amp;lt;featuresPerNode&amp;gt; variables, but that should only add to the diversity.
            nf := l.numFeatures;
            SELF.number := (RANDOM()%nf) + 1;
            SELF.rnd := RANDOM();
            SELF := l;
            END;
            // Create twice as many features as we need, so that when we remove duplicates, we almost always
            // have at least as many as we need.
            nodeVars0 := NORMALIZE(xNodes, LEFT.featuresPerNode * 2, getFeatures(LEFT, COUNTER));
            nodeVars1 :=  GROUP(nodeVars0, wi, treeId, nodeId, LOCAL);
            nodeVars2 := SORT(nodeVars1, wi, treeId, nodeId, number); // Note: implicitly local because of GROUP
            // Get rid of any duplicate features (we sampled with replacement so may be dupes)
            nodeVars3 := DEDUP(nodeVars2, wi, treeId, nodeId, number);
            // Now we have up to &amp;lt;featuresPerNode&amp;gt; * 2 unique features per node.  We need to whittle it down to
            // no more than &amp;lt;featuresPerNode&amp;gt;.
            nodeVars4 := SORT(nodeVars3, wi, treeId, nodeId, rnd); // Mix up the features
            // Filter out the excess vars and transform back to TreeNodeDat.  Set id (not yet used) just as an excuse
            // to check the count and skip if needed.
            nodeVars5 := UNGROUP(PROJECT(nodeVars4, TRANSFORM(TreeNodeDat,
            SELF.id := IF(COUNTER &amp;lt;= LEFT.featuresPerNode, 0, SKIP),
            SELF := LEFT)));
            // If the user provided features numbers that were not sequential, we need to map these feature numbers
            // (which are sequential) to the actual numbers the user provided.
            renumberFeatures(DATASET(TreeNodeDat) dat) := FUNCTION
            rnDat := JOIN(dat, featureMap, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.id,
            TRANSFORM(TreeNodeDat, SELF.number := RIGHT.number, SELF := LEFT), LOOKUP);
            RETURN rnDat;
            END;
            nodeVars := IF(needFeatureRenumbering, renumberFeatures(nodeVars5), nodeVars5);
            // At this point, we have &amp;lt;featuresPerNode&amp;gt; records for almost every node.  Occasionally one will have less
            // (but at least 1).
            // Now join with original nodeDat (one rec per tree node per id) to create one rec per tree node per id per
            // selected feature.
            nodeVarDat := JOIN(nodeDat, nodeVars, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM(TreeNodeDat, SELF.number := RIGHT.number, SELF := LEFT), LOCAL);
            RETURN nodeVarDat;
            END;

            // Sample with replacement &amp;lt;samples&amp;gt; items from X,Y for each tree
            SHARED DATASET(TreeNodeDat) GetBootstrapForTree(DATASET(TreeNodeDat) trees) := FUNCTION
            // At this point, trees contains one record per tree for each wi
            // Use the bootstrap (treeSampleIndxs) built at the module level

            // Note: At this point, trees and treeSampleIndx are both sorted and distributed by
            // treeId
            // We need to add the sample size from the wi to the dataset in order to filter appropriately
            xtv := RECORD(TreeNodeDat)
            t_RecordId numSamples;
            END;
            xTrees := JOIN(trees, wiMeta, LEFT.wi = RIGHT.wi, TRANSFORM(xtv, SELF.numSamples := RIGHT.numSamples,
            SELF := LEFT), LOOKUP, FEW);
            // Expand the trees to include the sample index for each tree.
            // Size is now &amp;lt;numTrees&amp;gt;  * &amp;lt;maxSamples&amp;gt; per wi
            // Note: this is a many to many join.
            treeDat0 := JOIN(xTrees, treeSampleIndx, LEFT.treeId = RIGHT.treeId,
            TRANSFORM(xtv, SELF.origId := RIGHT.origId, SELF.id := RIGHT.id, SELF := LEFT),
            MANY, LOOKUP);
            // Filter treeDat0 to remove any samples with origId &amp;gt; numSamples for that wi.
            // The number of samples will not (in all cases) be = the desired sample size, but shouldn&amp;apos;t create any bias.
            // This was our only need for numSamples, so we project back to TreeNodeDat format
            treeDat1 := PROJECT(treeDat0(origId &amp;lt;= numSamples), TreeNodeDat);
            // Now redistribute by wi and &amp;lt;origId&amp;gt; to match the Y data
            treeDat1D := DISTRIBUTE(treeDat1, HASH32(wi, origId));

            // Now get the  corresponding Y (dependent) value
            // While we&amp;apos;re at it, assign the data to the root (i.e. nodeId = 1, level = 1)
            treeDat2 := JOIN(treeDat1D, Y, LEFT.wi = RIGHT.wi AND LEFT.origId=RIGHT.id,
            TRANSFORM(TreeNodeDat, SELF.depend := RIGHT.value, SELF.nodeId := 1, SELF.level := 1,
            SELF.observWeight := 1.0, SELF := LEFT),
            LOCAL);
            treeDat2w := JOIN(treeDat2, observWeights, LEFT.wi = RIGHT.wi AND LEFT.origId = RIGHT.id,
            TRANSFORM(RECORDOF(LEFT), SELF.observWeight := IF(RIGHT.value &amp;gt; 0, RIGHT.value, 1.0),
            SELF := LEFT), LEFT OUTER, LOOKUP);
            treeDat := IF(haveObsWeights, treeDat2w, treeDat2);
            // At this point, we have one instance per tree  per sample, for each work-item, and each instance
            // includes the Y values for the selected indexes (i.e. depend)
            // TreeDat is distributed by work-item and sample id.
            RETURN treeDat;
            END;

            // Create the set of tree definitions -- One single node per tree (the root), with all tree samples associated with that root.
            SHARED DATASET(TreeNodeDat) InitTrees := FUNCTION
            // Create an empty tree data instance per work-item
            dummyTrees := PROJECT(wiMeta, TRANSFORM(TreeNodeDat, SELF.wi := LEFT.wi, SELF := []));
            // Use that to create &amp;quot;numTrees&amp;quot; dummy trees -- a dummy (empty) forest per wi
            trees := NORMALIZE(dummyTrees, numTrees, TRANSFORM(TreeNodeDat, SELF.treeId:=COUNTER, SELF.wi := LEFT.wi, SELF:=[]));
            // Distribute by wi and treeId
            treesD := DISTRIBUTE(trees, HASH32(wi, treeId));
            // Now, choose bootstrap sample of X,Y for each tree
            roots := GetBootstrapForTree(treesD);
            // At this point, each tree is fully populated with a single root node(i.e. 1).  All the data is associated with the root node.
            // Roots has each tree&amp;apos;s bootstrap sample of the dependent variable (selected for the tree).
            // Roots is distributed by wi and origId (original sample index)
            RETURN roots;
            END;

            // Grow one layer of the forest.  Virtual method to be overlaid by specific (Classification or Regression)
            // module
            SHARED VIRTUAL DATASET(TreeNodeDat) GrowForestLevel(DATASET(TreeNodeDat) nodeDat, t_Count treeLevel) := FUNCTION
            return DATASET([], TreeNodeDat);
            END;

            // Grow a Classification Forest from a set of roots containing all the data points (X and Y) for each tree.
            SHARED DATASET(TreeNodeDat) GrowForest(DATASET(TreeNodeDat) roots) := FUNCTION
            // Localize all the data by wi and treeId
            rootsD := DISTRIBUTE(roots, HASH32(wi, treeId));
            // Grow the forest one level at a time.
            treeNodes  := LOOP(rootsD, LEFT.id &amp;gt; 0, EXISTS(ROWS(LEFT)(COUNTER &amp;lt;= maxDepth)) , GrowForestLevel(ROWS(LEFT), COUNTER));
            return SORT(treeNodes, wi, treeId, level, nodeId);
            END;

            // Generate all tree nodes for classification
            EXPORT DATASET(TreeNodeDat) GetNodes := FUNCTION
            // First create a set of tree roots, each
            // with a unique bootstrap sample out of X,Y
            roots := InitTrees;
            // We now have a single root node for each tree (level = 1, nodeId = 1).  All of the data is
            // associated with the root for each tree.
            // Now we want to grow each tree by adding nodes, and moving the data
            // points to lower and lower nodes at each split.
            // When we are done, all of the data will be gone and all that will remain
            // is the skeleton of the decision tree with splits and leaf nodes.
            forestNodes := GrowForest(roots);
            // We now just have the structure of the decision trees remaining.  All data
            // is now summarized by the trees&amp;apos; structure into leaf nodes.
            RETURN forestNodes;
            END;

            // Find the corresponding leaf node for each X sample given an expanded forest model (set of tree nodes)
            EXPORT DATASET(TreeNodeDat) GetLeafsForData(DATASET(TreeNodeDat) tNodes, DATASET(GenField) X) := FUNCTION
            // Distribute X by wi and id.
            x_D := SORT(DISTRIBUTE(X, HASH32(wi, id)), wi, id, LOCAL);
            x_ids := DEDUP(x_D, wi, id, LOCAL);
            // Extend each root for each ID in X
            // Leave the extended roots distributed by wi, id.
            roots := tNodes(level = 1);
            rootsExt := JOIN(x_ids, roots, LEFT.wi = RIGHT.wi, TRANSFORM(TreeNodeDat, SELF.id := LEFT.id, SELF := RIGHT),
            MANY, LOOKUP);
            rootBranches := rootsExt(number != 0); // Roots are almost always branch (split) nodes.
            rootLeafs := rootsExt(number = 0); // Unusual but not impossible
            loopBody(DATASET(TreeNodeDat) levelBranches, UNSIGNED tLevel) := FUNCTION
            // At this point, we have one record per node, per id.
            // We extend each id down the tree one level at a time, picking the correct next nodes
            // for that id at each branch.
            // Next nodes are returned -- both leafs and branches.  The leafs are filtered out by the LOOP,
            // while the branches are sent on to the next round.
            // Ultimately, a leaf is returned for each id, which defines our final result.
            // Select the next nodes by combining the selected data field with each node
            // Note that:  1) we retain the id from the previous round, but the field number(number) is derived from the branch
            //             2) &amp;apos;value&amp;apos; in the node is the value to split upon, while value in the data (X) is the value of that datapoint
            //             3) NodeIds at level n + 1 are deterministic.  The child nodes at the next level&amp;apos;s nodeId is 2 * nodeId -1 for the
            //                left node, and 2 * nodeId for the right node.
            branchVals := JOIN(levelBranches, x_D, LEFT.wi = RIGHT.wi AND LEFT.id = RIGHT.id AND LEFT.number = RIGHT.number,
            TRANSFORM({TreeNodeDat, BOOLEAN branchLeft},
            SELF.branchLeft :=  ((LEFT.isOrdinal AND RIGHT.value &amp;lt;= LEFT.value) OR
            ((NOT LEFT.isOrdinal) AND RIGHT.value = LEFT.value)),
            SELF.parentId := LEFT.nodeId, SELF := LEFT),
            LOCAL);
            // Now, nextNode indicates the selected (left or right) nodeId at the next level for each branch
            // Now we use nextNode to select the node for the next round, for each instance
            nextLevelNodes := tNodes(level = tLevel + 1);
            nextLevelSelNodes := JOIN(branchVals, nextLevelNodes, LEFT.wi = RIGHT.wi AND
            LEFT.treeId = RIGHT.treeId AND LEFT.nodeId = RIGHT.parentId AND
            LEFT.branchLeft = RIGHT.isLeft,
            TRANSFORM(TreeNodeDat, SELF.id := LEFT.id, SELF := RIGHT), LOOKUP);
            // Return the selected nodes at the next level.  These nodes may be leafs or branches.
            // Any leafs will be filtered out by the loop.  Any branches will go on to the next round.
            // When there are no more branches to process, we are done.  The selected leafs for each datapoint
            // is returned. All nodes are left distributed by wi, id.
            RETURN nextLevelSelNodes;
            END;
            // The loop will return the deepest leaf node associated with each sample.
            selectedLeafs0 := LOOP(rootBranches, LEFT.number&amp;gt;0, EXISTS(ROWS(LEFT)),
            loopBody(ROWS(LEFT), COUNTER));
            selectedLeafs := selectedLeafs0 + rootLeafs;
            RETURN selectedLeafs;
            END; // GetLeafsForData
            /**
            * During RF training, we will occasionally hit a situation where all of the randomly selected
            * features for a level of the tree are constant for a node.  In this case, we are forced to insert
            * a dummy-split using a random feature from the selected subset in order to continue processing the
            * data.  We should see other useful features in subsequent rounds.  In this case, we set the splitVal
            * to MaxR8 (the maximum value for a REAL8 field) so that all data will take the left path.
            * This function removes such dummy splits and replaces that node with its child nodes, resulting
            * in a smaller tree which should be faster to process for prediction / classification of new points,
            * as well as any analytic operations.
            */
            SHARED DATASET(TreeNodeDat) CompressNodes(DATASET(TreeNodeDat) inNodes) := FUNCTION
            nodesS := SORT(DISTRIBUTE(inNodes, HASH32(wi, treeId)), wi, treeId, level, nodeId, LOCAL);
            // Assign a unique id to each node, independent of level.  We can re-use the id field
            // since it is not used at this point.  Note, these only need to be unique within a
            // tree, but using LOCAL PROJECT is efficient.  It will asssign a unique id to all
            // nodes across trees that are on the node.  Note that tree-nodes are distributed by
            // wi and treeId at this point.
            xNodes0 := PROJECT(nodesS, TRANSFORM(TreeNodeDat,
            SELF.id := COUNTER,
            SELF := LEFT), LOCAL);
            // Now add the parent&amp;apos;s unique ID to each record, so that the parent relationship is now
            // independent of level.
            xNodes := JOIN(xNodes0, xNodes0, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND LEFT.level = RIGHT.level + 1
            AND LEFT.parentId = RIGHT.nodeId,
            TRANSFORM({TreeNodeDat, t_RecordID parentGuid},
            SELF.parentGuid := RIGHT.id;
            SELF := LEFT), LEFT OUTER, LOCAL);
            compressOneLevel(DATASET({xNodes}) cNodes, UNSIGNED tLevel) := FUNCTION
            // Find the nodes that need to be compressed out at this level
            compressNodes := SORT(cNodes(level = tLevel AND value = maxR8 AND number != 0 ), wi, treeId, id, LOCAL);
            // Find the children of the nodes to be compressed, and link them to the compressNode&amp;apos;s parent
            // Note that there should only be one child for each compress node and it should be the left node,
            // but it needs to be also assigned the compressNode&amp;apos;s isLeft.
            childNodes := SORT(cNodes(level = tLevel + 1), wi, treeId, parentGuid, LOCAL);
            replaceNodes := JOIN(compressNodes, childNodes, LEFT.wi = RIGHT.wi AND
            LEFT.treeId = RIGHT.treeId AND LEFT.id = RIGHT.parentGuid,
            TRANSFORM({compressNodes},
            SELF.parentGuid := LEFT.parentGuid,
            SELF.isLeft := LEFT.isLeft,
            SELF := RIGHT), LOCAL);
            // Eliminate the compressNodes and the child nodes and replace with the new child nodes
            outLevelNodes := cNodes(level = tLevel AND (value != maxR8 OR number = 0));
            outNextLevelNodes := JOIN(childNodes, replaceNodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.id = RIGHT.id,
            TRANSFORM(LEFT), LEFT ONLY, LOCAL);
            outNodes := outLevelNodes + replaceNodes + outNextLevelNodes + cNodes(level &amp;gt; tLevel + 1);
            RETURN outNodes;
            END; // CompressOneLevel
            newNodes := LOOP(xNodes, maxDepth, LEFT.level &amp;gt;= COUNTER,
            compressOneLevel(ROWS(LEFT), COUNTER));
            // At this point, we have the correct set of nodes, but their level and local id&amp;apos;s might be messed up.
            // They are linked by the global id, but we need to fix up all the levels and localid&amp;apos;s by traversing
            // the tree from the top down using the global ids.
            fixupOneLevel(DATASET({newNodes}) fNodes, UNSIGNED tLevel) := FUNCTION
            // Start with the nodes for this level.  For the top-level (root), we use a different method
            // (i.e. no parent) in case the root was originally a compressed node and the current root therefore
            // has the level set wrong.
            fNodesS := SORT(fNodes, wi, treeId, parentGuid, -isLeft, LOCAL);
            levelNodes0 := IF(tLevel = 1, fNodesS(parentGuid = 0), fNodesS(level=tLevel));
            // Make sure that the level is set correctly for these items, and re-assign the local id (nodeId).
            levelNodes := PROJECT(levelNodes0, TRANSFORM({levelNodes0},
            SELF.level := tLevel, SELF.nodeId := COUNTER, SELF := LEFT), LOCAL);
            // Now find all the children and set their level to tLevel + 1, and set the local parentId to the parent&amp;apos;s nodeId
            fNodesS2:= SORT(fNodes, wi, treeId, parentGuid, LOCAL);
            nextLevelNodes := JOIN(levelNodes, fNodesS2, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.id = RIGHT.parentGuid,
            TRANSFORM({levelNodes}, SELF.parentId := LEFT.nodeId, SELF.level := tLevel + 1,
            SELF := RIGHT),
            LOCAL);
            outNodes := levelNodes + nextLevelNodes + fNodes(level &amp;gt; tLevel + 1);
            RETURN outNodes;
            END; // fixupOneLevel
            outNodes := LOOP(newNodes, maxDepth, LEFT.level &amp;gt;= COUNTER,
            fixupOneLevel(ROWS(LEFT), COUNTER));
            outNodesS := SORT(outNodes, wi, treeId, level, nodeId, LOCAL);
            RETURN PROJECT(outNodesS, TreeNodeDat);
            END; // CompressNodes
            /**
            * Extract the set of tree nodes from a model
            *
            */
            EXPORT DATASET(TreeNodeDat) Model2Nodes(DATASET(Layout_Model2) mod) := FUNCTION
            // Extract nodes from model as NumericField dataset
            nfNodes := ModelOps2.ToNumericField(mod, [FM1.nodes]);
            // Distribute by wi and id for distributed processing
            nfNodesD := DISTRIBUTE(nfNodes, HASH32(wi, id));
            nfNodesG := GROUP(nfNodesD, wi, id, LOCAL);
            nfNodesS := SORT(nfNodesG, wi, id, number);
            TreeNodeDat makeNodes(NumericField rec, DATASET(NumericField) recs) := TRANSFORM
            SELF.wi := rec.wi;
            SELF.treeId := recs[FMN3.treeId].value;
            SELF.level := recs[FMN3.level].value;
            SELF.nodeId := recs[FMN3.nodeId].value;
            SELF.parentId := recs[FMN3.parentId].value;
            SELF.isLeft := recs[FMN3.isLeft].value = 1;
            SELF.number := recs[FMN3.number].value;
            SELF.value := recs[FMN3.value].value;
            SELF.isOrdinal := recs[FMN3.isOrd].value = 1;
            SELF.depend := recs[FMN3.depend].value;
            SELF.support := recs[FMN3.support].value;
            SELF.ir := recs[FMN3.ir].value;
            SELF := [];
            END;
            // Rollup individual fields into TreeNodeDat records.
            nodes := ROLLUP(nfNodesS, GROUP, makeNodes(LEFT, ROWS(LEFT)));
            // Distribute by wi and TreeId
            //nodes := DISTRIBUTE(nodes0, HASH32(wi, treeId));
            RETURN nodes;
            END;
            /**
            * Extract the set of sample indexes (i.e. bootstrap samples for each tree)
            * from a model
            *
            */
            EXPORT Model2Samples(DATASET(Layout_Model2) mod) := FUNCTION
            nfSamples := ModelOps2.ToNumericField(mod, [FM1.samples]);
            samples := PROJECT(nfSamples, TRANSFORM(sampleIndx, SELF.treeId := LEFT.id,
            SELF.id := LEFT.number,
            SELF.origId := LEFT.value));
            return samples;
            END;
            /**
            * Convert the set of nodes describing the forest to a Model Format
            *
            */
            EXPORT DATASET(Layout_Model2) Nodes2Model(DATASET(TreeNodeDat) nodes) := FUNCTION
            NumericField makeMod({TreeNodeDat, UNSIGNED recordId} d, UNSIGNED c) := TRANSFORM
            SELF.wi := d.wi;
            indx1 := CHOOSE(c, FMN3.treeId, FMN3.level, FMN3.nodeId,
            FMN3.parentId, FMN3.isLeft, FMN3.number,
            FMN3.value, FMN3.isOrd,
            FMN3.depend, FMN3.support, FMN3.ir);
            SELF.value := CHOOSE(c, d.treeId, d.level, d.nodeId, d.parentId,
            (UNSIGNED)d.isLeft, d.number, d.value, (UNSIGNED)d.isOrdinal,
            d.depend, d.support, d.ir);
            SELF.number := indx1;
            SELF.id := d.recordId;
            END;
            // Add a record id to nodes
            nodesExt := PROJECT(nodes, TRANSFORM({TreeNodeDat, UNSIGNED recordId}, SELF.recordId := COUNTER, SELF := LEFT));
            // Make into a NumericField dataset
            nfMod := NORMALIZE(nodesExt, 11, makeMod(LEFT, COUNTER));
            // Insert at position [modInd.nodes] in the ndArray
            mod := ModelOps2.FromNumericField(nfMod, [FM1.nodes]);
            RETURN mod;
            END;
            /**
            * Convert the set of tree sample indexes to a Model Format
            *
            */
            SHARED Indexes2Model := FUNCTION
            nfIndexes := PROJECT(treeSampleIndx, TRANSFORM(NumericField,
            SELF.wi := 0, // Not used
            SELF.id := LEFT.treeId,
            SELF.number := LEFT.id,
            SELF.value := LEFT.origId));
            indexes := ModelOps2.FromNumericField(nfIndexes, [FM1.samples]);
            return indexes;
            END;
            /**
            * Get forest model
            *
            * RF uses the Layout_Model2 format, which is implemented as an N-Dimensional
            * numeric array (i.e. ndArray.NumericArray).
            *
            * See LT_Types for the format of the model
            *
            */
            EXPORT DATASET(Layout_Model2) GetModel := FUNCTION
            nodes := GetNodes;
            mod1 := Nodes2Model(nodes);
            mod2 := Indexes2Model;
            mod := mod1 + mod2;
            RETURN mod;
            END;

            /**
            * Compress and cleanup the model
            *
            * This function is provided to reduce the size of a model by compressing out
            * branches with only one child.  These branches are a result of the RF algorithm,
            * and do not affect the results of the model.
            * This is an expensive operation, which is why it is not done as a matter of
            * course.  It reduces the size of the model somewhat, and therefore slightly speeds
            * up any processing that uses the model, and reduces storage size.
            * You may want to compress the model if storage is at a premium, or if the model
            * is to be used many times (so that the slight performance gain is multiplied).
            * This also makes the model somewhat more readable, and could
            * be useful when analyzing the tree or converting it to another system
            * (e.g. LUCI) for processing.
            *
            */
            EXPORT DATASET(Layout_Model2) CompressModel(DATASET(Layout_Model2) mod) := FUNCTION
            nodes := Model2Nodes(mod);
            cNodes := CompressNodes(nodes);
            remainderMod := mod(indexes[1] != FM1.nodes);
            cMod := Nodes2Model(cNodes) + remainderMod;
            return cMod;
            END;

            // ModelStats
            EXPORT GetModelStats(DATASET(Layout_Model2) mod) := FUNCTION
            nodes := Model2Nodes(mod);
            treeStats := TABLE(nodes, {wi, treeId, nodeCount := COUNT(GROUP), depth := MAX(GROUP, level)},
            wi, treeId);
            leafStats := TABLE(nodes(number=0), {wi, treeId, nodeCount := COUNT(GROUP), depth := AVE(GROUP, level),
            totSupt := SUM(GROUP, support),
            maxSupt := MAX(GROUP, support),
            minDepth := MIN(GROUP, level)}, wi, treeId);
            treeSumm := TABLE(treeStats, {wi,
            treeCount := COUNT(GROUP),
            minTreeDepth := MIN(GROUP, depth),
            maxTreeDepth := MAX(GROUP, depth),
            avgTreeDepth := AVE(GROUP, depth),
            minTreeNodes := MIN(GROUP, nodeCount),
            maxTreeNodes := MAX(GROUP, nodeCount),
            avgTreeNodes := AVE(GROUP, nodeCount),
            totalNodes := SUM(GROUP, nodeCount)}, wi);
            leafSumm := TABLE(leafStats, {wi, treeCount := COUNT(GROUP),
            avgLeafs := AVE(GROUP, nodeCount),
            minSupport := MIN(GROUP, totSupt),
            maxSupport := MAX(GROUP, totSupt),
            avgSupport := AVE(GROUP, totSupt),
            avgSupportPerLeaf := SUM(GROUP, totSupt) / SUM(GROUP, nodeCount),
            maxSupportPerLeaf := MAX(GROUP, maxSupt),
            avgLeafDepth := AVE(GROUP, depth),
            minLeafDepth := MIN(GROUP, minDepth)}, wi);
            allStats := JOIN(treeSumm, leafSumm, LEFT.wi = RIGHT.wi, TRANSFORM(ModelStats,
            SELF := LEFT,
            SELF := RIGHT));
            RETURN allStats;
            END;
            /**
            * Feature Importance (intenal)
            *
            * Computes feature importance based on TreeNodeDat input
            *
            */
            EXPORT FeatureImportanceNodes(DATASET(TreeNodeDat) nodes) := FUNCTION
            treeCount := MAX(nodes, treeId);
            featureStats := TABLE(nodes(number &amp;gt; 0), {wi, number, importance := SUM(GROUP, ir * support)/treeCount,
            uses := COUNT(GROUP)}, wi, number);
            fi := SORT(PROJECT(featureStats, TRANSFORM(FeatureImportanceRec, SELF := LEFT)), wi, -importance);
            RETURN fi;
            END;

            /**
            * Feature Importance
            *
            * Calculate feature importance using the Mean Decrease Impurity (MDI) method
            * from &amp;quot;Understanding Random Forests: by Gilles Loupe (https://arxiv.org/pdf/1407.7502.pdf)
            * and due to Breiman [2001, 2002]
            *
            * Each feature is ranked by:
            *   SUM for each branch node in which feature appears (across all trees):
            *     impurity_reduction * number of nodes split
            *
            */
            EXPORT FeatureImportance(DATASET(Layout_Model2) mod) := FUNCTION
            nodes := Model2Nodes(mod);
            fi := FeatureImportanceNodes(nodes);
            RETURN fi;
            END;
            // Extended tree node record
            SHARED xTreeNodeDat := RECORD(TreeNodeDat)
            SET OF UNSIGNED pathNodes;
            END;
            // Add to nodes a globally unique nodeId (i.e. &amp;apos;id&amp;apos;) as well as a set of ids for each
            // node representing the full path from the root, root and current inclusive.
            // Note that id only needs to be unique within a tree, so we use a LOCAL PROJECT.
            SHARED GetExtendedNodes(DATASET(TreeNodeDat) nodes) := FUNCTION
            nodesS := SORT(DISTRIBUTE(nodes, HASH32(wi, treeId)), wi, treeId, level, nodeId, LOCAL);
            // Calculate the ancestor id&amp;apos;s one layer at a time from the root down.
            // Root just assigns its own id.  Others append their own id to the parent&amp;apos;s id.
            xNodes0 := PROJECT(nodesS, TRANSFORM(xTreeNodeDat,
            SELF.id := COUNTER,
            SELF.pathNodes := [SELF.id],
            SELF := LEFT), LOCAL);
            loopBody(DATASET(xTreeNodeDat) n, UNSIGNED lev) := FUNCTION
            assignNodes := n(level = lev);
            parentNodes := n(level = lev - 1);
            newNodes := JOIN(assignNodes, parentNodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.parentId = RIGHT.nodeId,
            TRANSFORM(xTreeNodeDat,
            SELF.pathNodes := RIGHT.pathNodes + LEFT.pathNodes,
            SELF := LEFT), LEFT OUTER, LOCAL);
            outNodes := n(level != lev) + newNodes;
            RETURN outNodes;
            END;
            maxLevel := MAX(nodesS, level);
            // Loop for each level
            xNodes := LOOP(xNodes0, maxLevel, loopBody(ROWS(LEFT), COUNTER));
            RETURN xNodes;
            END;
            SHARED dPath := RECORD
            t_Work_Item wi;
            t_RecordId id;
            t_TreeId treeId;
            SET OF UNSIGNED4 pathNodes;
            END;
            // Returns a record for each datapoint, for each tree, that includes the path for
            // the datapoint from the root to the leaf that it falls into.
            SHARED GetDecisionPaths(DATASET(TreeNodeDat) nodes, DATASET(GenField) X) := FUNCTION
            leafs := GetLeafsForData(nodes, X);
            xnodes := GetExtendedNodes(nodes);
            dps := JOIN(leafs, xnodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND LEFT.level = RIGHT.level AND
            LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM(dPath,
            SELF.wi := LEFT.wi,
            SELF.id := LEFT.id,
            SELF.treeId := LEFT.treeId,
            SELF.pathNodes := RIGHT.pathNodes), LEFT OUTER);
            return dps;
            END;
            /**
            * Decision Distance Matrix
            *
            * Calculate a Decision Distance (DD) Matrix with one cell for each pair of points in [X1, X2].
            * If X2 is omitted, then the matrix will have one cell per pair of points in X1.
            * If X1 has N ids and X2 has M ids, then N x M records will be produced.
            * If only X1 is provided, then N x N records will be produced
            * This metric provides a number between zero and one, with zero indicating that the points
            * are very similar, and one representing maximal dissimilarity.
            * This is a distance measure within the decision space of the given random forest model.
            * 1 - DD conversely represents a similarity measure known as MeanSimilarityMeasure(MSM)
            *
            * DD(x1, x2) := 1 - MSM(x1, x2)
            * MSM(x1, x2) := MEAN for all trees (SM(tree, x1, x2)
            * SM(tree, x1, x2) := Maximum Level at which Path(tree, X1)
            *                     and Path(tree, X2) are equal / (|Path(tree, X1)| + |Path(tree, X2)| / 2)
            * Path(x) := The set of nodes from the root of the tree to the Leaf(x) inclusive.
            * |Path(x)| := The length of the set Path(x)
            *
            */
            EXPORT DecisionDistanceMatrix(DATASET(Layout_Model2) mod, DATASET(GenField) X1, DATASET(GenField) X2=empty_data) := FUNCTION
            nodes := Model2Nodes(mod);
            paths1 := SORT(GetDecisionPaths(nodes, X1), id);
            paths2 := IF(EXISTS(X2), SORT(GetDecisionPaths(nodes, X2), id), paths1);
            // Form an N x M upper triangular matrix for each tree, with values being the SM.
            sm := JOIN(paths1, paths2, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId,
            TRANSFORM({t_TreeId treeId, NumericField},
            SELF.id := LEFT.id,
            SELF.number := RIGHT.id,
            SELF.value := int.CommonPrefixLen(LEFT.pathNodes, RIGHT.pathNodes) / ((COUNT(LEFT.pathNodes) + COUNT(RIGHT.pathNodes))/2),
            SELF := LEFT));
            // Now average across trees
            // First redistribute by id, so that information for all trees for an id is on one node
            smD := DISTRIBUTE(sm, HASH32(wi, id));
            dd := TABLE(smD, {wi, id, number, REAL8 ddVal := 1 - AVE(GROUP, value)}, wi, id, number, LOCAL);
            // Return as NumericField array.
            ddm := PROJECT(dd, TRANSFORM(NumericField, SELF.value := LEFT.ddVal, SELF := LEFT), LOCAL);
            RETURN ddm;
            END; // DecisionDistanceMatrix
            /**
            * Uniqueness Factor
            *
            * Calculate how isolated each datapoint is in the decision space of the random forest
            * 0 &amp;lt; UF &amp;lt; 1, low values indicate that the datapoint is similar to other datapoints.
            * high values indicate uniqueness.
            *
            * Calculated as: SUM for all other points(Decision Distance) / (Number of Points - 1)
            *
            */
            EXPORT UniquenessFactor(DATASET(Layout_Model2) mod, DATASET(GenField) X1, DATASET(GenField) X2=empty_data) := FUNCTION
            // Get the Decision Distance Matrix
            ddm := DecisionDistanceMatrix(mod, X1, X2);
            ddmD := DISTRIBUTE(ddm, HASH32(wi, id));
            // Sum the distance for each point to every other point
            uf0 := TABLE(ddmD, {wi, id, totVal := AVE(GROUP, value)}, wi, id, LOCAL);
            uf := PROJECT(uf0, TRANSFORM(NumericField,
            SELF.number := 1,
            SELF.value := LEFT.totVal,
            SELF.wi := LEFT.wi,
            SELF.id := LEFT.id));
            RETURN uf;
            END; // Uniqueness Factor
            END; // RF_Base&amp;#10;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;commonprefixlen&quot;
            name=&quot;CommonPrefixLen&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/CommonPrefixLen.ecl&quot;
            ts=&quot;1621960363000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
            ############################################################################## */
            /**
            * Return the the length of the longest common prefix between two id-lists
            *
            * General Function on a list (i.e. ordered set)
            *
            * @param s1 The first list (SET OF UNSIGNED4)
            * @param s2 The second list (SET OF UNSIGNED4)
            *
            * @return The prefix size
            */
            EXPORT UNSIGNED4 CommonPrefixLen(SET OF UNSIGNED4 s1, SET OF UNSIGNED4 s2) := BEGINC++
            #option pure
            uint32_t * st1 = (uint32_t *) s1;
            uint32_t * st2 = (uint32_t *) s2;
            uint32_t i;
            uint32_t maxPrefix = lenS1 &amp;lt; lenS2 ? lenS1 / sizeof(uint32_t) : lenS2 / sizeof(uint32_t);
            for (i=0; i &amp;lt; maxPrefix; i++) {
            if (st1[i] != st2[i]) {
            return i;
            }
            }
            return maxPrefix;
            ENDC++;&amp;#10;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;rf_classification&quot;
            name=&quot;RF_Classification&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl&quot;
            ts=&quot;1621960363000000&quot;&gt;
            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
            ############################################################################## */
            IMPORT $.^ AS LT;
            IMPORT LT.internal AS int;
            IMPORT LT.LT_Types AS Types;
            IMPORT ML_Core as ML;
            IMPORT ML.Types AS CTypes;
            IMPORT std.system.Thorlib;
            IMPORT ML_Core.ModelOps2;

            GenField := Types.GenField;
            TreeNodeDat := Types.TreeNodeDat;
            SplitDat := Types.SplitDat;
            NodeImpurity := Types.NodeImpurity;
            wiInfo := Types.wiInfo;t_Work_Item := CTypes.t_Work_Item;
            t_Count := CTypes.t_Count;
            t_RecordId := CTypes.t_RecordID;
            t_FieldNumber := CTypes.t_FieldNumber;
            t_TreeId := t_FieldNumber;
            t_FieldReal := CTypes.t_FieldReal;
            t_Discrete := CTypes.t_Discrete;
            Layout_Model := CTypes.Layout_Model;
            t_NodeId := Types.t_NodeId;
            DiscreteField := CTypes.DiscreteField;
            NumericField := CTypes.NumericField;
            Layout_Model2 := CTypes.Layout_Model2;
            ClassProbs := Types.ClassProbs;
            ClassWeightsRec := Types.ClassWeightsRec;
            nfNull := DATASET([], NumericField);

            /**
            * Classification Forest Module
            *
            * This module provides a Random Forest Classifier based on Breiman, 2001
            * with extensions.
            *
            * See RF_Base for a description of the Theory of Operation of this module.
            */
            EXPORT RF_Classification(DATASET(GenField) X_in=DATASET([], GenField),
            DATASET(GenField) Y_In=DATASET([], GenField),
            UNSIGNED numTrees=100,
            UNSIGNED featuresPerNode=0,
            UNSIGNED maxDepth=255,
            DATASET(NumericField) observWeights=nfNull)
            := MODULE(int.RF_Base(X_in, Y_in, numTrees,
            featuresPerNode, maxDepth, observWeights))
            SHARED minImpurity := .0000001;   // Nodes with impurity less than this are considered pure.
            SHARED classWeights := FUNCTION
            minClassWeight := .25; // Offset so that no weight can approach zero.
            // The weight of each class is assigned as a logarithmic inverse of the class frequency
            Y_DS := DISTRIBUTE(Y_in, HASH32(wi, value));
            classCounts := TABLE(Y_DS, {wi, value, cnt := COUNT(GROUP)}, wi, value);
            // Calculate the weights as classWeight(class) := -LN(&amp;lt;proportion of records of class&amp;gt;) + minClassWeight
            classWeights := JOIN(classCounts, wiMeta, LEFT.wi = RIGHT.wi, TRANSFORM(classWeightsRec,
            SELF.wi := LEFT.wi,
            SELF.classLabel := LEFT.value,
            SELF.weight := -LN(LEFT.cnt / RIGHT.numSamples) + minClassWeight), LOOKUP);
            return classWeights;
            END;
            // Find the best split for a given set of nodes.  In this case, it is the one with the highest information
            // gain.  Every possible split point is considered for each independent variable in the tree.
            // For nominal variables, the split is an equality split on one of the possible values for that variable
            // (i.e. split into = s and != s).  For ordinal variables, the split is an inequality (i.e. split into &amp;lt;= s and &amp;gt; s)
            // For each node, the split with the highest Information Gain (IG) is returned.
            SHARED DATASET(SplitDat) findBestSplit(DATASET(TreeNodeDat) nodeVarDat, DATASET(NodeImpurity) parentEntropy) := FUNCTION
            // Calculate the Information Gain (IG) for each split.
            // IG := Entropy(H) of Parent - Entropy(H) of the proposed split := H-parent - SUM(prob(child) * H-child) for each child group of the split
            // IV := -SUM(Prob(x) * Log2(Prob(x)) for all values of X independent variable
            // H := -SUM(Prob(y) * Log2(Prob(y)) for all values of Y dependent variable
            // At this point, nodeVarDat has one record per node per selected feature per id
            // Start by getting a list of all the values for each feature per node
            featureVals := TABLE(nodeVarDat, {wi, treeId, nodeId, number, value, isOrdinal,
            cnt := COUNT(GROUP),
            BOOLEAN rmVal := 0}, // rmVal is used later in computing split points
            wi, treeId, nodeId, number, value, isOrdinal, LOCAL);

            // Calculate the number of values per feature per node.
            features := TABLE(featureVals, {wi, treeId, nodeId, number, isOrdinal, tot := SUM(GROUP, cnt),
            vals := COUNT(GROUP)},
            wi, treeId, nodeId, number, isOrdinal, LOCAL);
            // We want to eliminate constant features (i.e. features with only one value for a node) from
            // consideration.  But we have to guard against the case where all of the selected features are
            // constant.  To do that, we save one constant feature per node in case we have to resort to
            // using it later.
            constantFeatures := features(vals = 1);
            dummySplits := DEDUP(constantFeatures, wi, treeId, nodeId, LOCAL);
            goodFeatures := features(vals &amp;gt; 1);
            // Calculate split points for each feature such that:
            // - for ordered features, the split value is the midpoint between actual values
            // - for ordered features, we remove the first value so that we have N-1 split points if there are N values.
            // - for categorical featues, no changes are made.  Each value is a valid split point (using equality).
            splitPoints0 := SORT(featureVals, wi, treeId, nodeId, number, value, LOCAL);
            // Compute the split points mid-way between values.  Use rmVal to mark the initial value for each feature
            // for later removal.
            {featureVals} doOneIter({featureVals} l, {featureVals} r) := TRANSFORM
            // is this the first record of the group (i.e. wi, treeId, nodeId, number)?
            BOOLEAN firstRec := NOT (l.wi = r.wi AND l.treeId = r.treeId AND
            l.nodeId = r.nodeId AND l.number = r.number);
            // If it&amp;apos;s an ordered feature, and not the first record, use the midpoint.
            SELF.value := IF(r.isOrdinal AND not firstRec, (l.value + r.value)/2, r.value);
            // If this is an ordered feature and it is the first record of the group, mark it for deletion.
            SELF.rmVal := r.isOrdinal AND firstRec;
            SELF := r;
            END;
            splitPoints1 := ITERATE(splitPoints0, doOneIter(LEFT, RIGHT), LOCAL);
            splitPoints := splitPoints1(rmVal = FALSE);
            // Auto-binning occurs here (if enabled). If there are more values for
            // a feature than autobinSize, randomly select potential split values with probability:
            // 1/(number-of-values / autobinSize).
            // Note: For efficiency, we use autobinSize * 2**32-1 so that we can directly compare to RANDOM()
            //       without having to divide by 2**32-1
            // Non-selected split points are marked via rmVal
            // Note that any constant features are also eliminated by the use of goodFeatures.
            splitInfo0 := JOIN(splitPoints, goodFeatures, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId
            AND LEFT.nodeId = RIGHT.nodeId AND LEFT.number = RIGHT.number,
            TRANSFORM({featureVals},
            SELF.rmVal := LEFT.isOrdinal AND
            autoBin = TRUE AND RIGHT.vals &amp;gt; autobinSize AND
            RANDOM() &amp;gt; autobinSizeScald/RIGHT.vals,
            SELF := LEFT), LOCAL);
            // Now get rid of all the marked split points.
            splitInfo := splitInfo0(rmVal = FALSE);
            // Replicate each datapoint for the node to every possible split for that node
            // Mark each datapoint as being left or right of the split.  Handle both Ordinal and Nominal cases.
            allSplitDat := JOIN(nodeVarDat, splitInfo, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId
            AND RIGHT.nodeId = LEFT.nodeId AND LEFT.number = RIGHT.number,
            TRANSFORM({TreeNodeDat, t_FieldReal splitVal},
            SELF.splitVal := RIGHT.value,
            SELF.isLEFT := IF((LEFT.isOrdinal AND LEFT.value &amp;lt;= SELF.splitVal)
            OR (NOT LEFT.isOrdinal AND LEFT.value = SELF.splitVal),TRUE, FALSE),
            SELF := LEFT), LOCAL);
            // Calculate the entropy of the left and right groups of each split
            // Group by value of Y (depend) for left and right splits
            dependGroups := TABLE(allSplitDat, {wi, treeId, nodeId, number, splitVal, isLeft, depend,
            isOrdinal, UNSIGNED cnt := COUNT(GROUP),
            REAL weightSum := SUM(GROUP, observWeight)},
            wi, treeId, nodeId, number, splitVal, isLeft, depend, isOrdinal, LOCAL);
            // Sum up the number of data points for left and right splits
            dependSummary := TABLE(dependGroups, {wi, treeId, nodeId, number, splitVal, isLeft,
            REAL totWeights := SUM(GROUP, weightSum)},
            wi, treeId, nodeId, number, splitVal, isLeft, LOCAL);
            // Calculate p_log_p for each Y value for left and right splits
            dependRatios := JOIN(dependGroups, dependSummary,
            LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND LEFT.nodeId = RIGHT.nodeId AND
            LEFT.number = RIGHT.number AND LEFT.splitVal = RIGHT.splitVal
            AND LEFT.isLeft = RIGHT.isLeft,
            TRANSFORM({dependGroups, REAL prop, REAL plogp},
            SELF.prop := LEFT.weightSum / RIGHT.totWeights, SELF.plogp := P_Log_P(SELF.prop),
            SELF := LEFT),
            LOCAL);
            // Sum the p_log_p&amp;apos;s for each Y value to get the entropy of the left and right splits.
            lr_entropies := TABLE(dependRatios, {wi, treeId, nodeId, number, splitVal, isLeft, isOrdinal, tot := SUM(GROUP, cnt),
            entropy := SUM(GROUP, plogp)},
            wi, treeId, nodeId, number, splitVal, isLeft, isOrdinal, LOCAL);
            // Now calculate the weighted average of entropies of the two groups (weighted by number of datapoints in each)
            // Note that &amp;apos;tot&amp;apos; is number of datapoints for each side of the split.
            entropies0 := TABLE(lr_entropies, {wi, treeId, nodeId, number, splitVal, isOrdinal,
            REAL totEntropy := SUM(GROUP, entropy * tot) / SUM(GROUP, tot)},
            wi, treeId, nodeId, number, splitVal, isOrdinal, LOCAL);
            entropies := SORT(entropies0, wi, treeId, nodeId, totEntropy, LOCAL);
            // We only care about the split with the lowest entropy for each tree node.  Since the parentEntropy
            // is constant for a given tree node, the split with the lowest entropy will also be the split
            // with the highest Information Gain.
            lowestEntropies := DEDUP(entropies, wi, treeId, nodeId, LOCAL);
            // Now calculate Information Gain
            // In order to stop the tree-building process when there is no split that gives information-gain
            // we set &amp;apos;number&amp;apos; to zero to indicate that there is no best split when we hit that case.
            // That happens when the data is not fully separable by the independent variables.
            // Not that field ir (impurity reduction) is a generic term that encompasses ig.
            // In the case where there are no valid (non constant) features to split on, we mark the node by
            // setting &amp;apos;number&amp;apos; to maxU4 so we can fix it up later.
            ig := JOIN(lowestEntropies, parentEntropy, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM({entropies, t_NodeID parentId, BOOLEAN isLeft, REAL ir, t_RecordId support},
            SELF.ir := IF(LEFT.number &amp;gt; 0, RIGHT.impurity - LEFT.totEntropy, 0),
            SELF.number := IF(LEFT.number = 0 AND allowNoProgress, maxU4, IF(SELF.ir &amp;gt; 0 OR allowNoProgress,
            LEFT.number, 0)),
            SELF.wi := RIGHT.wi,
            SELF.treeId := RIGHT.treeId,
            SELF.nodeId := RIGHT.nodeId,
            SELF.parentId := RIGHT.parentId,
            SELF.isLeft := RIGHT.isLeft,
            SELF.support := RIGHT.support,
            SELF := LEFT
            ),
            RIGHT OUTER, LOCAL);
            // Choose the split with the greatest information gain for each node.
            // In the case where we had no non-constant splits we fill in with an arbitrary one of the constant
            // splits so that we can keep the tree growing with the next set of selected features on the next
            // round.  Otherwise, the tree would be truncated.
            bestSplits := JOIN(ig, dummySplits, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM(SplitDat,
            SELF.number := IF(LEFT.number = maxU4, RIGHT.number, LEFT.number),
            SELF.splitVal := IF(LEFT.number = maxU4, maxR8, LEFT.splitVal), // Force LEFT
            SELF.isOrdinal := IF(LEFT.number = maxU4, RIGHT.isOrdinal, LEFT.isOrdinal),
            SELF := LEFT), LEFT OUTER, LOCAL);

            RETURN bestSplits;
            END;
            // Grow one layer of the forest
            SHARED DATASET(TreeNodeDat) GrowForestLevel(DATASET(TreeNodeDat) nodeDat, t_Count treeLevel) := FUNCTION
            // At this point, nodes contains one element per wi, treeId, nodeId and id within the node.
            // The number field is not used at this point, nor is the value field.  The depend field has
            // the dependent value (Y) for each id.
            // Calculate the Impurity for each node.
            // NodeValCounts has one record per node, per value of the dependent variable (Y)
            nodeValCounts := TABLE(nodeDat, {wi, treeId, nodeId, depend, parentId, isLeft, cnt:= COUNT(GROUP),
            REAL weightSum := SUM(GROUP, observWeight)},
            wi, treeId, nodeId, depend, parentId, isLeft, LOCAL);

            // NodeCounts is the count of data items for the node
            nodeCounts := TABLE(nodeValCounts, {wi, treeId, nodeId, tot:= SUM(GROUP, cnt),
            REAL totWeights := SUM(GROUP, weightSum)},
            wi, treeId, nodeId, LOCAL);
            // Now we can calculate the information entropy for each node
            // Entropy is defined as SUM(plogp(proportion of each Y value)) for each Y value
            nodeEntInfo := JOIN(nodeValCounts, nodeCounts, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM({nodeValCounts, REAL4 prop, REAL4 plogp}, SELF.prop:= LEFT.weightSum/RIGHT.totWeights,
            SELF.plogp:= P_LOG_P(LEFT.weightSum/RIGHT.totWeights),
            , SELF:=LEFT), LOCAL);
            // Note that for any (wi, treeId, nodeId), parentId and isLeft will be constant, but we need to carry
            //   them forward.
            nodeEnt0 := TABLE(nodeEntInfo, {wi, treeId, nodeId, parentId, isLeft,
            entropy := SUM(GROUP, plogp),
            t_RecordId tot := SUM(GROUP, cnt)},
            wi, treeId, nodeId, parentId, isLeft, LOCAL);
            // Node impurity
            nodeImp := PROJECT(nodeEnt0, TRANSFORM(NodeImpurity, SELF.impurity := LEFT.entropy,
            SELF.support := LEFT.tot,
            SELF := LEFT));

            // Filtering pure and non-pure nodes. We translate any pure nodes and their associated data into a leaf node.
            // Impure nodes need further splitting, so they are passed into the next phase.
            // If we are at maxDepth, consider everything pure enough.
            pureEnoughNodes := nodeImp(impurity &amp;lt; minImpurity OR treeLevel = maxDepth);  // Nodes considered pure enough.

            // Eliminate any data associated with the leafNodes from the original node data.  What&amp;apos;s left
            // is the data for the impure nodes that still need to be split
            toSplitNodes := JOIN(nodeCounts, pureEnoughNodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM(TreeNodeDat, SELF := LEFT, SELF := []),
            LEFT ONLY, LOCAL);
            // Choose a random set of feature on which to split each node
            // At this point, we have one record per tree, node, and number (for selected features)
            toSplitVars := SelectVarsForNodes(toSplitNodes);

            // Now, extend the values of each of those features (X) for each id
            // Use the indices to get the corresponding X value for each field.
            // Redistribute by id to match up with the original X data
            toSplitDat0 := JOIN(toSplitVars, nodeDat, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId, TRANSFORM(TreeNodeDat, SELF.number := LEFT.number,
            SELF := RIGHT), LOCAL);
            // Redistribute by id to match up with the original X data, and sort to align the JOIN.
            toSplitDat1:= SORT(DISTRIBUTE(toSplitDat0, HASH32(wi, origId)), wi, origId, number, LOCAL);
            toSplitDat2 := JOIN(toSplitDat1, X, LEFT.wi = RIGHT.wi AND LEFT.origId=RIGHT.id AND LEFT.number=RIGHT.number,
            TRANSFORM(TreeNodeDat, SELF.value := RIGHT.value, SELF.isOrdinal := RIGHT.isOrdinal, SELF := LEFT),
            LOCAL);
            // Now redistribute the results by treeId for further analysis.  Sort for further analysis.
            toSplitDat := DISTRIBUTE(toSplitDat2, HASH32(wi, treeId));

            // Filter nodeImp so that only the &amp;quot;not pure enough&amp;quot; nodes are included.  This is important
            // because we use this as the set of nodes for which we need to find best splits.
            parentNodeImp := nodeImp(impurity &amp;gt;= minImpurity AND treeLevel &amp;lt; maxDepth);

            // Now try all the possible splits and find the best
            bestSplits := findBestSplit(toSplitDat, parentNodeImp);

            // Reasonable splits were found
            goodSplits := bestSplits(number != 0);
            // No split made any progress, or we are at maxDepth for the tree
            badSplits := bestSplits(number = 0);

            // Remove from toSplitDat any cells that are 1) from a bad split or 2) for a feature that was
            // not chosen as the best split. Call it goodSplitDat.
            goodSplitDat := JOIN(toSplitDat, goodSplits, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId AND LEFT.number = RIGHT.number, TRANSFORM(LEFT), LOCAL);
            // Now, create a split node and two child nodes for each split.
            // First move the data to new child nodes.
            // Start by finding the data samples that fit into the left and the right

            leftIds := JOIN(goodSplits, goodSplitDat, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId AND LEFT.number = RIGHT.number AND
            ((RIGHT.isOrdinal AND RIGHT.value &amp;lt;= LEFT.splitVal) OR
            (NOT RIGHT.isOrdinal AND RIGHT.value = LEFT.splitVal)),
            TRANSFORM({t_Work_Item wi, t_TreeId treeId, t_NodeId nodeId, t_RecordId id},
            SELF.treeId := LEFT.treeId, SELF.nodeId := LEFT.nodeId, SELF.id := RIGHT.id,
            SELF.wi := RIGHT.wi),
            LOCAL);
            // Assign the data ids to either the left or right branch at the next level
            // All of the node data for the left split (i.e. for Ordinal data: where val &amp;lt;= splitVal,
            //  for Nominal data: where val = splitVal) is marked LEFT.
            // All the node data for the right split(i.e. for Ordinal data: where val &amp;gt; splitVal,
            //  for Nominal data: where val &amp;lt;&amp;gt; splitVal) is marked NOT LEFT
            // Note that nodeIds only need to be unique within a level.
            // Left ids are assigned every other value (1, 3, 5, ...) to leave room for the rights,
            // which will be left plus 1 for a given parent node.  This provides an inexpensive way to assign
            // ids at the next level (though it opens the door for overflow of nodeId).  We handle that
            // case later.
            // Note that &amp;apos;number&amp;apos; is set to zero for next level data.  New features will be selected next time around.
            LR_nextLevel := JOIN(goodSplitDat, leftIds, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId AND LEFT.id = RIGHT.id,
            TRANSFORM(TreeNodeDat, SELF.level := treeLevel + 1,
            SELF.nodeId := IF(RIGHT.treeId &amp;gt; 0, LEFT.nodeId * 2 - 1, LEFT.nodeId * 2),
            SELF.parentId := LEFT.nodeId,
            SELF.isLeft := IF(RIGHT.treeId &amp;gt; 0, TRUE, FALSE),
            SELF.number := 0;
            SELF := LEFT), LEFT OUTER, LOCAL);

            // Occasionally, recalculate the nodeIds to make them contiguous to avoid an overflow
            // error when the trees get very deep.  Note that nodeId only needs to be unique within
            // a level.  It is not required that they be a function of the parent&amp;apos;s id since parentId will
            // anchor the child to its parent.
            nextLevelIds := TABLE(LR_nextLevel, {wi, treeId, nodeId, t_NodeID newId := 0}, wi, treeId, nodeId, LOCAL);
            nextLevelIdsG := GROUP(nextLevelIds, wi, treeId, LOCAL);
            newIdsG := PROJECT(nextLevelIdsG, TRANSFORM({nextLevelIds}, SELF.newId := COUNTER, SELF := LEFT));
            newIds := UNGROUP(newIdsG);
            fixupIds := SORT(JOIN(LR_nextLevel, newIds, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM(TreeNodeDat, SELF.nodeId := RIGHT.newId, SELF := LEFT), LOCAL), wi, treeId, nodeId, LOCAL);
            maxNodeId := MAX(LR_nextLevel, nodeId);
            // 2**48 is the optimum wrap point.  It allows us to reorganize as infrequently as possible, yet will fit into
            // a Layout_Model2 field.
            nextLevelDat := IF(maxNodeId &amp;gt;= POWER(2, 48), fixupIds, LR_nextLevel);
            // Now reduce each splitNode to a single skeleton node with no data.
            // For a split node (i.e. branch), we only use treeId, nodeId, number (the field number to split on), value (the value to split on), and parent-id
            splitNodes := PROJECT(goodSplits, TRANSFORM(TreeNodeDat, SELF.level := treeLevel, SELF.wi := LEFT.wi,
            SELF.treeId := LEFT.treeId,
            SELF.nodeId := LEFT.nodeId, self.number := LEFT.number, self.value := LEFT.splitVal,
            SELF.isOrdinal := LEFT.isOrdinal,
            SELF.parentId := LEFT.parentId,
            SELF.isLeft := LEFT.isLeft,
            SELF.support := LEFT.support,
            SELF.ir := LEFT.ir,
            SELF := []));
            // Now handle the leaf nodes, which are the pure-enough nodes, plus the bad splits (i.e. no good
            // split left).
            // Handle the badSplit case: there&amp;apos;s no feature that will further split the data = mixed leaf node.
            // Classify the point according to the most frequent class, and create a leaf node to summarize it.
            mixedLeafs0 := JOIN(nodeValCounts, badSplits, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM(TreeNodeDat, SELF.wi := LEFT.wi, SELF.level := treeLevel,
            SELF.treeId := LEFT.treeId, SELF.nodeId := LEFT.nodeId,
            SELF.parentId := LEFT.parentId, SELF.isLeft := LEFT.isLeft, SELF.id := 0, SELF.number := 0,
            SELF.depend := LEFT.depend, SELF.support := LEFT.cnt, SELF := []), LOCAL);
            mixedLeafs1 := SORT(mixedLeafs0, wi, treeId, nodeId, -support, LOCAL);
            mixedLeafs := DEDUP(mixedLeafs1, wi, treeId, nodeId, LOCAL); // Finds the most common value
            // Create a single leaf node instance to summarize each pure node&amp;apos;s data
            // The leaf node instance only has a few significant attributes:  The tree and node id,
            // the dependent value, and the level, as well
            // as the support (i.e. the number of data points that fell into that leaf).
            pureNodes0 := JOIN(nodeValCounts, pureEnoughNodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
            LEFT.nodeId = RIGHT.nodeId,
            TRANSFORM(TreeNodeDat, SELF.wi := LEFT.wi, SELF.level := treeLevel,
            SELF.treeId := LEFT.treeId, SELF.nodeId := LEFT.nodeId,
            SELF.parentId := LEFT.parentId,
            SELF.isLeft := LEFT.isLeft, SELF.id := 0, SELF.number := 0,
            SELF.depend := LEFT.depend, SELF.support := LEFT.cnt, SELF := []), LOCAL);
            // On the last time through, we might have some mixed nodes coming in as leaf nodes.  In that case, we need
            // to only output the class with the highest occurrence within the node.
            pureNodes1 := SORT(pureNodes0, wi, treeId, nodeId, -support, LOCAL);
            pureNodes2 := DEDUP(pureNodes1, wi, treeId, nodeId, LOCAL); // Finds the most common value
            pureNodes := IF(treeLevel = maxDepth, pureNodes2, pureNodes0);
            leafNodes := pureNodes + mixedLeafs;
            // Return the three types of nodes: leafs at this level, splits (branches) at this level, and nodes at
            // the next level (children of the branches).
            RETURN leafNodes + splitNodes + nextLevelDat;
            END;

            SHARED emptyClassWeights := DATASET([], classWeightsRec);
            // Get the probability of each sample belonging to each class,
            // given an expanded forest model (set of tree nodes)
            // Note that &amp;apos;probability&amp;apos; is used loosely here as a percentage
            // of trees that voted for each class.
            EXPORT DATASET(ClassProbs) FClassProbabilities(DATASET(TreeNodeDat) tNodes, DATASET(GenField) X,
            DATASET(classWeightsRec) classWts=emptyClassWeights) := FUNCTION
            modTreeCount := MAX(tNodes, treeId);  // Number of trees in the model
            selectedLeafs := GetLeafsForData(tNodes, X);
            // At this point, we have one leaf node per tree per datapoint (X)
            // The leaf nodes contain the final class in their &amp;apos;depend&amp;apos; field.
            // Now we need to count the votes for each class and id
            // Calculate raw (unweighted) probabilities
            probs0 := TABLE(selectedLeafs, {wi, id, depend, cnt := COUNT(GROUP), prob := COUNT(GROUP) / modTreeCount},
            wi, id, depend, LOCAL);
            // Function to calculate weighted probabilities.
            calcWeightedProbs := FUNCTION
            // Calculate prob * weight for each id
            wprobs0 := JOIN(probs0, classWts, LEFT.wi = RIGHT.wi AND
            LEFT.depend = RIGHT.classLabel,
            TRANSFORM({probs0}, SELF.prob := LEFT.prob * RIGHT.weight,
            SELF := LEFT), LOOKUP);
            // Normalize based on the sum of weighted probabilities for each id
            totWprobs := TABLE(wprobs0, {wi, id, tot := SUM(GROUP, prob)}, wi, id, LOCAL);
            wprobs := JOIN(wprobs0, totWprobs, LEFT.wi = RIGHT.wi AND LEFT.id = RIGHT.id,
            TRANSFORM({wprobs0}, SELF.prob := LEFT.prob / RIGHT.tot, SELF := LEFT), LOCAL);
            // Return prob = raw_prob * weight / SUM(raw_prob * weight) for each id
            return wprobs;
            END; // calcWeightedProbs
            // If weights were provided, use weighted probs, otherwise raw probs
            wprobs := IF(EXISTS(classWts), calcWeightedProbs, probs0);
            // Now one record per datapoint per value of depend (Y) with the count of &amp;apos;votes&amp;apos; and
            // proportion of votes (raw prob) or class weighted proportion for each depend value.
            RETURN PROJECT(wprobs, TRANSFORM(ClassProbs, SELF.class := LEFT.depend, SELF := LEFT));
            END; // FClassProbabilities

            // Produce a class for each X sample given an expanded forest model (set of tree nodes)
            EXPORT DATASET(DiscreteField) ForestClassify(DATASET(TreeNodeDat) tNodes,
            DATASET(GenField) X,
            DATASET(classWeightsRec) classWts=emptyClassWeights) := FUNCTION
            // Get the probabilities of each sample
            probs := FClassProbabilities(tNodes, X, classWts);
            probsExt := PROJECT(probs, TRANSFORM({probs, UNSIGNED rnd}, SELF.rnd := RANDOM(), SELF := LEFT), LOCAL);
            // Reduce to one record per datapoint, with the highest class probability winning
            probsS := SORT(probsExt, wi, id, -prob, rnd, LOCAL);
            // Keep the first leaf value for each wi and id.  That is the one with the highest probability
            selectedClasses := DEDUP(probsS, wi, id, LOCAL);
            // Transform to discrete field
            results := PROJECT(selectedClasses, TRANSFORM(DiscreteField, SELF.number := 1, SELF.value := LEFT.class, SELF := LEFT));
            RETURN results;
            END;
            /**
            * Extract the class weights dataset from the model
            *
            */
            EXPORT Model2ClassWeights(DATASET(Layout_Model2) mod) := FUNCTION
            modCW := ModelOps2.Extract(mod, [FM1.classWeights]);
            cw := PROJECT(modCW, TRANSFORM(classWeightsRec, SELF.wi := LEFT.wi, SELF.classLabel := LEFT.indexes[1],
            SELF.weight := LEFT.value));
            RETURN cw;
            END;

            // Use the supplied forest model to predict the ClassLabel(Y) for a set of X values.
            // Optionally use class balancing to weight the classes inversely proportional to their
            // frequency in the training data.
            EXPORT DATASET(DiscreteField) Classify(DATASET(GenField) X, DATASET(Layout_Model2) mod,
            BOOLEAN balanceClasses=FALSE) := FUNCTION
            tNodes := Model2Nodes(mod);
            classWts := Model2ClassWeights(mod);
            classes := IF(balanceClasses, ForestClassify(tNodes, X, classWts), ForestClassify(tNodes, X));
            RETURN classes;
            END;

            // Get Class Probabilities.
            // Note that probabilities here are the (optionally class weighted) proportion of trees that
            // &amp;apos;voted&amp;apos; for each class, for each X sample.
            EXPORT DATASET(ClassProbs) GetClassProbs(DATASET(GenField) X, DATASET(Layout_Model2) mod,
            BOOLEAN balanceClasses=FALSE) := FUNCTION
            tNodes := Model2Nodes(mod);
            classWts := Model2ClassWeights(mod);
            probs := IF(balanceClasses, FClassProbabilities(tNodes, X, classWts),FClassProbabilities(tNodes, X));
            RETURN probs;
            END;
            /**
            * Get forest model
            *
            * Overlays the GetModel function of RF Base to provide additional information
            * used only for classification.
            * Adds the class weights, which are only used for classification
            *
            * RF uses the Layout_Model2 format
            *
            * See LT_Types for the format of the model
            *
            */
            EXPORT DATASET(Layout_Model2) GetModel := FUNCTION
            nodes := GetNodes;
            mod1 := Nodes2Model(nodes);
            mod2 := Indexes2Model;
            baseMod := mod1 + mod2;
            naClassWeights := PROJECT(classWeights, TRANSFORM(Layout_Model2, SELF.wi := LEFT.wi,
            SELF.indexes := [FM1.classWeights, LEFT.classLabel],
            SELF.value := LEFT.weight));
            mod := baseMod + naClassWeights;
            RETURN mod;
            END;
            END; // RF_Classification
            &lt;/Attribute&gt;
            &lt;/Module&gt;
            &lt;Module key=&quot;_versions.ml_core.v3_2_2.ml_core.math&quot; name=&quot;_versions.ML_Core.V3_2_2.ML_Core.Math&quot;&gt;
            &lt;Attribute key=&quot;distributions&quot;
            name=&quot;Distributions&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Math/Distributions.ecl&quot;
            ts=&quot;1621960335000000&quot;&gt;
            //Normal, Student and Chi Squared distributions for tests
            IMPORT $.^.Constants AS Core_Const;
            IMPORT $ AS Math;
            /**
            * &amp;lt;p&amp;gt;Compute PDF, CDF, and PPF values for various Probability Distributions.
            * &amp;lt;p&amp;gt;The Probability Density Function(PDF(x)) of a distribution is
            * the relative likelihood of a sample drawn from that distribution being
            * of value x.
            * &amp;lt;p&amp;gt;The Cumulative Distribution Function (CDF(x)) of a distribution
            * is the probability of a sample drawn from that distribution to be
            * less than or equal to x.
            * &amp;lt;p&amp;gt;The Percentage Point Function (PPF(x)) of a distribution is the
            * inverse of the CDF.  Given a probability, it returns the value
            * at which the probability of occurrence is less than or equal to the
            * given probability.
            **/
            EXPORT Distributions := MODULE
            /**
            * Cumulative Distribution Function (CDF) of the standard normal distribution. The
            * probability that a normal random variable will be smaller than
            * or equal to x standard deviations above or below the mean.
            * &amp;lt;p&amp;gt;Taken from C/C++ Mathematical Algorithms for Scientists and
            * Engineers, n. Shammas, McGraw-Hill, 1995.
            * @param x the number of standard deviations.
            * @return probability of exceeding x.
            **/
            EXPORT REAL8 Normal_CDF(REAL8 x) := DEFINE FUNCTION
            b1 := 0.319381530;
            b2 :=-0.356563782;
            b3 := 1.781477937;
            b4 :=-1.821255978;
            b5 := 1.330274429;
            xp1 := 1.0 / (1.0 + 0.2316419*ABS(x));
            xp2 := xp1*xp1;
            xp3 := xp2*xp1;
            xp4 := xp3*xp1;
            xp5 := xp4*xp1;
            term_sum := xp1*b1 + xp2*b2 + xp3*b3 + xp4*b4 + xp5*b5;
            recip_sqrt_2_pi := 0.39894228040143;
            rslt0 := exp(-x*x/2) * recip_sqrt_2_pi * term_sum;
            rslt := IF(x&amp;gt;=0.0, 1-rslt0, rslt0);
            RETURN rslt;
            END;

            /**
            * Percentage Point Function (PPF) for the Normal Distribution.
            * &amp;lt;p&amp;gt;Translated from C/C++ Mathematical Algorithms for Scientists and
            * Engineers, N. Shammas, McGraw-Hill, 1995.
            * @param x probability.
            * @return number of standard deviations from the mean.
            */
            EXPORT REAL8 Normal_PPF(REAL8 x) := DEFINE FUNCTION
            p0 := -0.322232431088;
            p1 := -1.0;
            p2 := -0.342242088547;
            p3 := -0.204231210245e-1;
            p4 := -0.453642210148e-4;
            q0 :=  0.993484626060e-1;
            q1 :=  0.588581570495;
            q2 :=  0.531103462366;
            q3 :=  0.103537752850;
            q4 :=  0.38560700634e-2;
            x0 := MAP(x&amp;lt;=0.0 =&amp;gt; 0.0001, x&amp;gt;=1.0 =&amp;gt; 0.9999, x);
            xp := SQRT(-2.0 * LN(IF(x0&amp;lt;=0.5, x0, 1-x0)));
            numerator := ((((p4*xp+p3)*xp+p2)*xp+p1)*xp+p0);
            denominator := ((((q4*xp+q3)*xp+q2)*xp+q1)*xp+q0);
            rslt0 := xp + numerator/denominator;
            RETURN MAP(x0=0.5  =&amp;gt; 0.0,
            x0&amp;lt;0.5  =&amp;gt; -rslt0,
            rslt0);
            END;

            // Helper for Students distribution
            REAL8 Sum_Terms(INTEGER4 df, REAL8 c, REAL8 csq) := BEGINC++
            #option pure;
            double work_sum = (df%2==0) ? 1.0  : c;
            double work_term = (df%2==0) ? 1.0  : c;
            int start = (df%2==0) ? 2  : 3;
            int stop = (df - 2);
            for (int i=start; i&amp;lt;=stop; i+=2) {
            work_term *= csq * (((double)(i-1.0))/((double)i));
            work_sum  += work_term;
            }
            return work_sum;
            ENDC++;
            /**
            * Cumulative Distribution Function (CDF) for Students t distribution.
            * &amp;lt;p&amp;gt;The integral evaluated between negative
            * infinity and x.
            * &amp;lt;p&amp;gt;Translated from NIST SEL DATAPAC Fortran TCDF.f source.
            * @param x value of the evaluation.
            * @param df degrees of freedom.
            * @return the probability that a value will be less than or equal to the
            * specified value.
            **/
            EXPORT REAL8 T_CDF(REAL8 x, REAL8 df) := DEFINE FUNCTION
            INTEGER4 DF_Cut := 1000;
            REAL8 PI := Core_Const.Pi;
            INTEGER4 ndf := (INTEGER4) df;
            BOOLEAN isEven := ndf%2 = 0;
            // Small and moderate df definitions
            REAL8 sd := SQRT(df/(df-2.0));
            REAL8 z := x/sd;
            REAL8 c := SQRT(df/(x*x+df));
            REAL8 csq := df/(x*x+df);
            REAL8 s := x/SQRT(x*x+df);
            REAL8 sum_terms := MAP(
            df=1  =&amp;gt; (2/PI)*(ATAN(x)),
            df=2  =&amp;gt; s,
            df=3  =&amp;gt; (2/PI)*(ATAN(x/SQRT(df))+(c*s)),
            isEven=&amp;gt; Sum_Terms(df, c, csq) * s,
            (2/PI)*(ATAN(x/SQRT(df)) + Sum_Terms(df, c, csq)*s));
            // Large df asymptoptic approximation definitions
            REAL8 DCONST := 0.3989422804;
            REAL8 B11 := 0.25;
            REAL8 B21 := 0.01041666666667;
            REAL8 B22 := 3.0;
            REAL8 B23 := -7.0;
            REAL8 B24 := -5.0;
            REAL8 B25 := -3.0;
            REAL8 B31 := 0.00260416666667;
            REAL8 B32 := 1.0;
            REAL8 B33 := -11.0;
            REAL8 B34 := 14.0;
            REAL8 B35 := 6.0;
            REAL8 B36 := -3.0;
            REAL8 B37 := -15.0;
            REAL8 d1 := x;
            REAL8 d3 := d1 * x * x;
            REAL8 d5 := d3 * x * x;
            REAL8 d7 := d5 * x * x;
            REAL8 d9 := d7 * x * x;
            REAL8 d11:= d9 * x * x;
            REAL8 df_2 := df * df;
            REAL8 df_3 := df_2 * df;
            REAL8 Term1 := B11*(d3+d1)/df;
            REAL8 Term2 := B21*(B22*d7+B23*d5+B24*d3+B25*d1)/df_2;
            REAL8 Term3 := B31*(B32*d11+B33*d9+B34*d7+B35*d5+B36*d3+B37*d1)/df_3;
            REAL8 Norm_CDF := Normal_CDF(x);
            T_CDF := MAP(df &amp;lt;= 0                             =&amp;gt; 0.0,
            df BETWEEN 3 AND 9     AND z&amp;lt;= -3000 =&amp;gt; 0.0,
            df BETWEEN 3 AND 9     AND z&amp;gt;=  3000 =&amp;gt; 1.0,
            df BETWEEN 10 AND 1000 AND z&amp;lt;= -150  =&amp;gt; 0.0,
            df BETWEEN 10 AND 1000 AND z&amp;gt;=  150  =&amp;gt; 1.0,
            df BETWEEN 1 AND 1000                =&amp;gt; 0.5+sum_terms/2.0,
            Norm_CDF-(EXP(-x*x*0.5))*(Term1+Term2+Term3)*DCONST);
            RETURN T_CDF;
            END;

            // Inverse T helper functions
            REAL8 df3_helper(REAL8 trm, REAL8 init_z) := BEGINC++
            #option pure;
            #include &amp;lt;math.h&amp;gt;
            const double root_3 = sqrt(3);
            double c = cos(init_z);
            double s = sin(init_z);
            double z = init_z;
            for (int i=0; i&amp;lt;15; i++) {
            z = z-(z+s*c-trm)/(2.0*c*c);
            c = cos(z);
            s = sin(z);
            }
            return root_3*s/c;
            ENDC++;
            REAL8 df4_helper(REAL8 trm, REAL8 init_z) := BEGINC++
            #option pure;
            #include &amp;lt;math.h&amp;gt;
            double c = cos(init_z);
            double s = sin(init_z);
            double z = init_z;
            for (int i=0; i&amp;lt;15; i++) {
            z = z-((1.0+0.5*c*c)*s-trm)/(1.5*c*c*c);
            c = cos(z);
            s = sin(z);
            }
            return sqrt(4)*s/c;
            ENDC++;
            REAL8 df5_helper(REAL8 trm, REAL8 init_z) := BEGINC++
            #option pure;
            #include &amp;lt;math.h&amp;gt;
            double c = cos(init_z);
            double s = sin(init_z);
            double z = init_z;
            for (int i=0; i&amp;lt;15; i++) {
            z = z-(z+(c+(2.0/3.0)*c*c*c)*s-trm)/((8.0/3.0)*c*c*c*c);
            c = cos(z);
            s = sin(z);
            }
            return sqrt(5)*s/c;
            ENDC++;
            REAL8 df6_helper(REAL8 trm, REAL8 init_z) := BEGINC++
            #option pure;
            #include &amp;lt;math.h&amp;gt;
            double c = cos(init_z);
            double s = sin(init_z);
            double z = init_z;
            for (int i=0; i&amp;lt;15; i++) {
            z = z-((1.0+0.5*c*c+0.375*c*c*c*c)*s-trm)/((15.0/8.0)*c*c*c*c*c);
            c = cos(z);
            s = sin(z);
            }
            return sqrt(6)*s/c;
            ENDC++;
            REAL8 dk_helper(REAL8 x, INTEGER4 df, REAL8 mf) := BEGINC++
            #option pure;
            #include&amp;lt;math.h&amp;gt;
            const double last_position = 12; // lowest prob &amp;lt; 0.000001
            const double step = last_position/100000;
            double position = 0;
            double cdf = 0.5;
            double target = (x&amp;lt;0.5) ? 1.0-x :  x;
            while (cdf &amp;lt; target &amp;amp;&amp;amp; position &amp;lt;=last_position) {
            double this_point = (2*position+step)/2;
            cdf += mf*pow(1+(this_point*this_point/df), -0.5*(df+1))*step;
            position += step;
            }
            if (cdf &amp;gt; target) position-= step/2;
            position = (x&amp;lt;0.5)  ? -position  : position;
            return position;
            ENDC++;
            /**
            * Percentage point function (PPF) for the T distribution.
            * &amp;lt;p&amp;gt;Translated from NIST SEL DATAPAC Fortran TPPF.f source.
            * @param x the probability.
            * @param df degrees of freedom of the distribution.
            * @return the value with that probability.
            */
            EXPORT REAL8 T_PPF(REAL8 x, REAL8 df) := DEFINE FUNCTION
            REAL8 PI := Core_Const.Pi; //3.14159265358979;
            REAL8 ROOT_2 := Core_Const.Root_2; //1.414213562373095;
            REAL8 B21 :=  0.25;
            REAL8 B31 :=  0.01041666666667;
            REAL8 B32 :=  5.0;
            REAL8 B33 :=  16.0;
            REAL8 B34 :=  3.0;
            REAL8 B41 :=  0.00260416666667;
            REAL8 B42 :=  3.0;
            REAL8 B43 :=  19.0;
            REAL8 B44 :=  17.0;
            REAL8 B45 := -15.0;
            REAL8 B51 :=  0.00001085069444;
            REAL8 B52 :=  79.0;
            REAL8 B53 :=  776.0;
            REAL8 B54 :=  1482.0;
            REAL8 B55 := -1920.0;
            REAL8 B56 := -945.0;
            REAL8 Norm_PPF := Normal_PPF(x);
            // df 7 and higher
            d1 := Norm_PPF;
            d2 := d1 * d1;
            d3 := d1 * d2;
            d5 := d3 * d2;
            d7 := d5 * d2;
            d9 := d7 * d2;
            df_2 := df * df;
            df_3 := df_2 * df;
            df_4 := df_3 * df;
            trm1 := d1;
            trm2 := B21*(d3+d1)/df;
            trm3 := B31*(B32*d5+B33*d3+B34*d1)/df_2;
            trm4 := B41*(B42*d7+B43*d5+B44*d3+B45*d1)/df_3;
            trm5 := B51*(B52*d9+B53*d7+B54*d5+B55*d3+B56*d1)/df_4;
            trms := trm1 + trm2 + trm3 + trm4 + trm5;
            // df 3, 4, 5, and 6 cases
            init_z := ATAN(Norm_PPF/SQRT(df));
            // df 7 to 50
            INTEGER4 ndf := (INTEGER4) df;
            BOOLEAN isEven := ndf&amp;amp;1 = 0;
            REAL8 m_factor := Math.DoubleFac(ndf-1)
            /(IF(isEven,2,PI)*SQRT(ndf)*Math.DoubleFac(ndf-2));
            //
            rslt := MAP(df=1    =&amp;gt; -COS(PI*x)/SIN(PI*x),
            df=2    =&amp;gt; ((ROOT_2/2.0)*(2.0*x-1.0))/SQRT(x*(1.0-x)),
            df=3    =&amp;gt; df3_helper((PI*(x-0.5)), init_z),
            df=4    =&amp;gt; df4_helper((2.0*(x-0.5)), init_z),
            df=5    =&amp;gt; df5_helper((PI*(x-0.5)), init_z),
            df=6    =&amp;gt; df6_helper((2.0*(x-0.5)), init_z),
            df BETWEEN 7 AND 50 =&amp;gt; dk_helper(x, ndf, m_factor),
            trms);
            RETURN rslt;
            END;

            // helper functions for Chi Squared
            REAL8 Low_DF_Sum(INTEGER4 df, REAL8 x) := BEGINC++
            #option pure;
            #include &amp;lt;math.h&amp;gt;
            if (x &amp;lt;= 0) return 0;
            if (df &amp;lt;=0) return 0;
            double chi = sqrt(x);
            double term_sum = (df%2==0) ? 1.0  : 0.0;
            double term = (df%2==0) ? 1.0  : 1.0/chi;
            int start = (df%2==0) ? 2  : 1;
            int stop = (df%2==0) ? (df-2)  : (df-1);
            for (int i=start; i&amp;lt;=stop; i+=2) {
            term *= x/((double)i);
            term_sum += term;
            }
            return term_sum;
            ENDC++;
            /**
            * The Cumulative Distribution Function (CDF) for the Chi Square
            * distribution for the specified degrees of freedom.
            * &amp;lt;p&amp;gt;Translated from the NIST SEL DATAPAC Fortran subroutine CHSCDF.
            * @param x the value at which to compute.
            * @param df the degrees of freedom of the distribution.
            * @return the cumulative probability.
            **/
            EXPORT REAL8 Chi2_CDF(REAL8 x, REAL8 df) := DEFINE FUNCTION
            INTEGER4 DF_Cut := 1000;
            REAL8 PI := Core_Const.Pi; //3.14159265358979;
            INTEGER4 ndf := (INTEGER4) df;
            BOOLEAN isEven := ndf%2 = 0;
            REAL8 sd := SQRT(2*df);
            REAL8 z := (x-df)/sd;
            // definitions for cases above the cut line for degrees of freedom
            REAL8 DPWR := 0.33333333333333;
            REAL8 dfact := 4.5 * df;
            REAL8 adj_point_gt_x := (POWER(x/df,DPWR)-1.0+1.0/dfact)*SQRT(dfact);
            REAL8 high_df_gt_x := Normal_CDF(adj_point_gt_x);
            REAL8 dw := SQRT(x - df-df*LN(x/df));
            REAL8 root_rdf1 := SQRT(2.0/df);
            REAL8 root_rdf2 := root_rdf1 * root_rdf1;
            REAL8 root_rdf3 := root_rdf2 * root_rdf1;
            REAL8 root_rdf4 := root_rdf3 * root_rdf1;
            REAL8 d1 := dw;
            REAL8 d2 := d1 * dw;
            REAL8 d3 := d2 * dw;
            REAL8 B11 :=  0.33333333333333;
            REAL8 B21 := -0.02777777777778;
            REAL8 B31 := -0.00061728395061;
            REAL8 B32 := -13.0;
            REAL8 B41 := 0.00018004115226;
            REAL8 B42 := 6.0;
            REAL8 B43 := 17.0;
            REAL8 trm0 := dw;
            REAL8 trm1 := B11*root_rdf1;
            REAL8 trm2 := B21*d1*root_rdf2;
            REAL8 trm3 := B31*(d2+B32)*root_rdf3;
            REAL8 trm4 := B41*(B42*d3+B43*d1)*root_rdf4;
            REAL8 high_df_le_x := Normal_CDF(trm0+trm1+trm2+trm3+trm4);
            // definitions for cases below the cut line for degrees of freedom
            REAL8 chi := SQRT(x);
            REAL8 low_even := Low_DF_Sum(ndf, x)*EXP(-x/2.0);
            REAL8 low_odd := (1.0-Normal_CDF(chi))*2.0 + (SQRT(2.0/PI)*low_even);
            // determine the result based upon the case
            rslt := MAP(x &amp;lt;= 0        =&amp;gt; 0.0,
            df&amp;lt;10 AND z &amp;lt; -200    =&amp;gt; 0.0,
            df&amp;gt;=10 AND z &amp;lt; -100   =&amp;gt; 0.0,
            df&amp;lt;10 AND z &amp;gt; 200     =&amp;gt; 1.0,
            df&amp;gt;=10 AND z &amp;gt; 100    =&amp;gt; 1.0,
            df &amp;lt; DF_cut AND isEven=&amp;gt; 1.0 - low_even,
            df &amp;lt; df_Cut           =&amp;gt; 1.0 - low_odd,
            df &amp;gt;=df_cut AND x&amp;lt;=df =&amp;gt; high_df_gt_x,
            high_df_le_x);
            //cdf := Math.lowerGamma(df/2, x/2) / Math.gamma(df/2);
            RETURN rslt;
            END;

            // helpers for Chi squared PPF
            REAL8 df_lt_crit(REAL8 x, REAL8 df) := BEGINC++
            #option pure;
            #include &amp;lt;math.h&amp;gt;
            const int max_iter = 30000;
            const int max_bisect = 1000;
            const double half_df = df / 2.0;
            const double min_delta = 0.0000000001;
            double G = tgamma(half_df);
            // now ready to iterate to find percentage point value
            int iter = 0;
            double curr_point = 0.0;
            double step = pow(x*half_df*G, 2.0/df);
            double min_pos = 0;
            double max_pos = 0;
            // determine upper and lower limits
            while (iter&amp;lt;max_iter &amp;amp;&amp;amp; curr_point &amp;lt; x) {
            min_pos = max_pos;
            max_pos += step;
            double term_sum = 2.0/df;
            double term = 2.0/df;
            double cut1 = max_pos - half_df;
            double cut2 = max_pos*10000000000.0;
            for (long j=1; j&amp;lt;10000 &amp;amp;&amp;amp; ((double)j)&amp;lt;cut1+(cut2*term/term_sum); j++) {
            term = max_pos*term/(half_df+((double)j));
            term_sum += term;
            }
            curr_point = pow(max_pos, half_df) * exp(-max_pos) * term_sum / G;
            iter++;
            }
            // search by bisection
            double target_pos = (min_pos+max_pos) / 2.0;
            curr_point = pow(target_pos, half_df)*exp(-target_pos)*(2.0/half_df)/G;
            double delta = 2*min_delta;
            iter = 0;
            while (iter&amp;lt;max_bisect &amp;amp;&amp;amp; delta&amp;gt;min_delta &amp;amp;&amp;amp; curr_point!=x) {
            double term_sum = 2.0/df;
            double term = 2.0/df;
            double cut1 = target_pos - half_df;
            double cut2 = target_pos*10000000000.0;
            for (int j=1; j&amp;lt;10000.0 &amp;amp;&amp;amp; ((double)j)&amp;lt;(cut1+(cut2*term/term_sum)); j++) {
            term = target_pos*term/(half_df+((double)j));
            term_sum += term;
            }
            curr_point = pow(target_pos, half_df) * exp(-target_pos) * term_sum / G;
            if (curr_point==x) return 2.0 * target_pos;
            if (curr_point &amp;lt; x) min_pos = target_pos;
            else max_pos = target_pos;
            iter++;
            target_pos = (max_pos + min_pos) / 2.0;
            delta = (target_pos&amp;gt;min_pos)  ? target_pos-min_pos  : min_pos-target_pos;
            }
            return 2.0 * target_pos;
            ENDC++;
            /**
            * Probability Point Function (PPF) for the Chi Squared distribution.
            * &amp;lt;p&amp;gt;Translated from the NIST SEL DATAPAC Fortran subroutine CHSPPF.
            * @param x the probability value.
            * @param df the degrees of freedom of the distribution.
            * @return the value with that probability.
            */
            EXPORT REAL8 Chi2_PPF(REAL8 x, REAL8 df) := FUNCTION
            critical := 100;
            x0 := MAP(x&amp;lt;=0.0 =&amp;gt; 0.0001, x&amp;gt;=1.0 =&amp;gt; 0.9999, x);
            REAL8 k := 2.0/9.0;
            xq := Normal_PPF(x0);
            wrk := 1.0 -k/df + xq*SQRT(k/df);
            df_ge_crit := df * wrk * wrk * wrk;
            rslt := IF(df&amp;lt;critical, df_lt_crit(x, df), df_ge_crit);
            RETURN rslt;
            END;
            END;&amp;#10;
            &lt;/Attribute&gt;
            &lt;Attribute key=&quot;doublefac&quot;
            name=&quot;DoubleFac&quot;
            sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Math/DoubleFac.ecl&quot;
            ts=&quot;1621960335000000&quot;&gt;
            /**
            * Compute the double factorial.
            * The double factorial is defined for odd n as the product of
            * all the odd numbers up to and including that number.
            * &amp;lt;p&amp;gt;For even numbers it is the product
            * of the even numbers up to and including that number.
            * &amp;lt;p&amp;gt;Thus DoubleFac(8) = 8*6*4*2.
            * &amp;lt;p&amp;gt;IF i &amp;lt; 2, the value 1 is returned.
            * @param i the input value.
            * @return the numeric result.
            **/
            EXPORT REAL8 DoubleFac(INTEGER2 i) := BEGINC++
            #option pure
            if ( i &amp;lt; 2 )
            return 1.0;
            double accum = (double)i;
            for ( int j = i-2; j &amp;gt; 1; j -= 2 )
            accum *= (double)j;
            return accum;
            ENDC++;&amp;#10;
            &lt;/Attribute&gt;
            &lt;/Module&gt;
            &lt;Module key=&quot;std&quot; name=&quot;std&quot;/&gt;
            &lt;Module key=&quot;std.system&quot; name=&quot;std.system&quot;&gt;
            &lt;Attribute key=&quot;thorlib&quot;
            name=&quot;Thorlib&quot;
            sourcePath=&quot;/opt/HPCCSystems/8.0.14/clienttools/share/ecllibrary/std/system/Thorlib.ecl&quot;
            ts=&quot;1621443946000000&quot;&gt;
            -----BEGIN PGP SIGNED MESSAGE-----
            Hash: SHA1

            /*##############################################################################
            ## HPCC SYSTEMS software Copyright (C) 2012 HPCC Systems®.  All rights reserved.
            ############################################################################## */

            /*
            * Internal functions for accessing system information relating to execution on the thor engine.
            *
            * This module is currently treated as internal, and subject to change without notice.
            */

            externals :=
            SERVICE
            unsigned integer4 node() : ctxmethod, entrypoint=&amp;apos;getNodeNum&amp;apos;;
            unsigned integer4 nodes() : ctxmethod, entrypoint=&amp;apos;getNodes&amp;apos;;
            varstring l2p(const varstring name, boolean create=false) : ctxmethod, entrypoint=&amp;apos;getFilePart&amp;apos;;
            unsigned integer getFileOffset(const varstring lfname) : ctxmethod, entrypoint=&amp;apos;getFileOffset&amp;apos;;
            varstring daliServer() : once, ctxmethod, entrypoint=&amp;apos;getDaliServers&amp;apos;;
            varstring cluster() : once, ctxmethod, entrypoint=&amp;apos;getClusterName&amp;apos;;
            varstring getExpandLogicalName(const varstring name) : pure, ctxmethod, entrypoint=&amp;apos;getExpandLogicalName&amp;apos;;
            varstring group() : once, ctxmethod, entrypoint=&amp;apos;getGroupName&amp;apos;;
            varstring platform() : pure ,ctxmethod, entrypoint=&amp;apos;getPlatform&amp;apos;;
            END;

            RETURN MODULE

            /*
            * Returns the index of the slave node this piece of code is executing on.  Zero based.
            */

            export node() := externals.node();

            /*
            * Converts a logical filename to a physical filename.
            *
            * @param name          The logical filename to be converted.
            * @param create        True if creating a new file, false if reading an existing file.
            */

            export logicalToPhysical(const varstring name, boolean create=false) := externals.l2p(name, create);

            /*
            * How many nodes in the cluster that this code will be executed on.
            */

            export nodes() := CLUSTERSIZE;

            /*
            * Returns the dali server this thor is connected to.
            */

            export daliServer() := externals.daliServer();

            /*
            * Returns which thor group the job is currently executing on.
            */

            export group() := externals.group();

            /*
            * Converts a logical filename to a physical filename.
            */

            export getExpandLogicalName(const varstring name) := externals.getExpandLogicalName(name);

            /*
            * Returns the name of the cluster the query is currently executing on.
            */

            export cluster() := externals.cluster();

            /*
            * Returns the platform the query is currently executing on.
            */

            export platform() := externals.platform();

            /*
            * The following are either unused, or should be replaced with a different syntax.

            export getenv(const varstring name, const varstring defaultValue) := externals.getenv(name, defaultValue);
            - - use getenv() built in command instead.
            export getFileOffset(const varstring lfname) := externals.getFileOffset(lfname);

            */

            END;
            -----BEGIN PGP SIGNATURE-----
            Version: GnuPG v1

            iQEcBAEBAgAGBQJgpUVqAAoJEG37B3CNqkF96soH/3UQSOP7D4Ja5pZHdiV+z3ht
            /8XCEQrn4BIgkUSQYRdIDAqDmxQrgM5R23SLcQliUR7aywcDV0/Tvm3CfQ7tfMLV
            j9+BCbD9M3CHrJeFO/2ZRrQOhMSZCn7CLM+NcG30aPVyXFq2Lcq1mIZZbTER4Nbo
            wU/4vO/iEAxsQQM2Tmpj0xlipUWSkkADr9jd+hrBZ1sq+qO+9/cbau2CEA33DCka
            MaH5PDduCqj4otFLDTuHwbutto0gm/CizUmsMqQMF1aSUZYDZczI9jINo1n8xKAh
            XlSnQ5iIvNgSlUHcsumMej767eb7s0xjCwZ7jtHnkN2XnpT1gbQFCxPzPuW4/+0=
            =fjzT
            -----END PGP SIGNATURE-----&amp;#10;
            &lt;/Attribute&gt;
            &lt;/Module&gt;
            &lt;Option name=&quot;eclcc_compiler_version&quot; value=&quot;8.0.14&quot;/&gt;
            &lt;/Archive&gt;&#10;</Text>
    </Query>
    <Results>
        <Result isScalar="0"
                name="Y_train"
                recordSizeEntry="mf3"
                rowLimit="-1"
                sequence="1"
                status="undefined">
            <SchemaRaw xsi:type="SOAP-ENC:base64">
                d2kAAQIAaWQAAQgAbnVtYmVyAAEEAHZhbHVlAAEEAQAYbQAAAHJlY29yZF9fMCA6PSBSRUNP
                UkQKICB1bnNpZ25lZDIgd2k7CiAgdW5zaWduZWQ4IGlkOwogIHVuc2lnbmVkNCBudW1iZXI7
                CiBFTkQ7CnsocmVjb3JkX18wKSBpbnRlZ2VyNCB2YWx1ZSB9Owo=   </SchemaRaw>
        </Result>
        <Result isScalar="0"
                name="TrainingData"
                recordSizeEntry="mf1"
                rowLimit="-1"
                sequence="0"
                status="undefined">
            <SchemaRaw xsi:type="SOAP-ENC:base64">
                aWQAAQgAeDEAAgh4MgABCAB4MwABCAB5AAEIAAAYWAAAAFJFQ09SRAogIHVuc2lnbmVkOCBp
                ZDsKICByZWFsOCB4MTsKICB1bnNpZ25lZDggeDI7CiAgdW5zaWduZWQ4IHgzOwogIHVuc2ln
                bmVkOCB5OwogRU5EOwo=   </SchemaRaw>
        </Result>
        <Result isScalar="0"
                name="Model"
                recordSizeEntry="mf21"
                rowLimit="-1"
                sequence="2"
                status="undefined">
            <SchemaRaw xsi:type="SOAP-ENC:base64">
                d2kAAQIAdmFsdWUAAghpbmRleGVzABUBBAAAGDkAAAB7IHVuc2lnbmVkMiB3aSwgcmVhbDgg
                dmFsdWUsIHNldCBvZiB1bnNpZ25lZDQgaW5kZXhlcyB9Owo=   </SchemaRaw>
        </Result>
        <Result isScalar="0"
                name="Tree"
                recordSizeEntry="mfK2"
                rowLimit="-1"
                sequence="4"
                status="undefined">
            <SchemaRaw xsi:type="SOAP-ENC:base64">
                d2kAAQIAbGV2ZWwAAQIAdHJlZWlkAAEEAG5vZGVpZAABCABwYXJlbnRpZAABCABpc2xlZnQA
                AGlkAAEIAG51bWJlcgABBAB2YWx1ZQACCGRlcGVuZAACCHN1cHBvcnQAAQgAaXNvcmRpbmFs
                AAAAGO0AAABSRUNPUkQKICB1bnNpZ25lZDIgd2k7CiAgdW5zaWduZWQyIGxldmVsOwogIHVu
                c2lnbmVkNCB0cmVlaWQ7CiAgdW5zaWduZWQ4IG5vZGVpZDsKICB1bnNpZ25lZDggcGFyZW50
                aWQ7CiAgYm9vbGVhbiBpc2xlZnQ7CiAgdW5zaWduZWQ4IGlkOwogIHVuc2lnbmVkNCBudW1i
                ZXI7CiAgcmVhbDggdmFsdWU7CiAgcmVhbDggZGVwZW5kOwogIHVuc2lnbmVkOCBzdXBwb3J0
                OwogIGJvb2xlYW4gaXNvcmRpbmFsOwogRU5EOwo=   </SchemaRaw>
        </Result>
        <Result isScalar="0"
                name="ModelStats"
                recordSizeEntry="mf03"
                rowLimit="-1"
                sequence="3"
                status="undefined">
            <SchemaRaw xsi:type="SOAP-ENC:base64">
                d2kAAQIAdHJlZWNvdW50AAEIAG1pbnRyZWVkZXB0aAABCABtYXh0cmVlZGVwdGgAAQgAYXZn
                dHJlZWRlcHRoAAIIbWludHJlZW5vZGVzAAEIAG1heHRyZWVub2RlcwABCABhdmd0cmVlbm9k
                ZXMAAgh0b3RhbG5vZGVzAAEIAG1pbnN1cHBvcnQAAQgAbWF4c3VwcG9ydAABCABhdmdzdXBw
                b3J0AAIIYXZnc3VwcG9ydHBlcmxlYWYAAghtYXhzdXBwb3J0cGVybGVhZgABCABhdmdsZWFm
                ZGVwdGgAAghtaW5sZWFmZGVwdGgAAQgAYmZsZXZlbAABCAAAGKMBAABSRUNPUkQKICB1bnNp
                Z25lZDIgd2k7CiAgdW5zaWduZWQ4IHRyZWVjb3VudDsKICB1bnNpZ25lZDggbWludHJlZWRl
                cHRoOwogIHVuc2lnbmVkOCBtYXh0cmVlZGVwdGg7CiAgcmVhbDggYXZndHJlZWRlcHRoOwog
                IHVuc2lnbmVkOCBtaW50cmVlbm9kZXM7CiAgdW5zaWduZWQ4IG1heHRyZWVub2RlczsKICBy
                ZWFsOCBhdmd0cmVlbm9kZXM7CiAgdW5zaWduZWQ4IHRvdGFsbm9kZXM7CiAgdW5zaWduZWQ4
                IG1pbnN1cHBvcnQ7CiAgdW5zaWduZWQ4IG1heHN1cHBvcnQ7CiAgcmVhbDggYXZnc3VwcG9y
                dDsKICByZWFsOCBhdmdzdXBwb3J0cGVybGVhZjsKICB1bnNpZ25lZDggbWF4c3VwcG9ydHBl
                cmxlYWY7CiAgcmVhbDggYXZnbGVhZmRlcHRoOwogIHVuc2lnbmVkOCBtaW5sZWFmZGVwdGg7
                CiAgdW5zaWduZWQ4IGJmbGV2ZWw7CiBFTkQ7Cg==   </SchemaRaw>
        </Result>
    </Results>
    <State>blocked</State>
    <Statistics>
        <Statistic c="esp"
                   count="1"
                   creator="myesp@10.0.0.209"
                   kind="WhenCreated"
                   s="global"
                   scope=""
                   ts="1624947468993793"
                   unit="ts"
                   value="1624947468993784"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="WhenCompiled"
                   s="global"
                   scope=""
                   ts="1624947469009679"
                   unit="ts"
                   value="1624947469009438"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="WhenStarted"
                   s="compile"
                   scope="compile"
                   ts="1624947472017608"
                   unit="ts"
                   value="1624947469063838"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="SizePeakMemory"
                   s="compile"
                   scope="compile"
                   ts="1624947472017626"
                   unit="sz"
                   value="54095872"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeElapsed"
                   s="compile"
                   scope="compile"
                   ts="1624947472017641"
                   unit="ns"
                   value="2953416313"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="NumSysContextSwitches"
                   s="compile"
                   scope="compile"
                   ts="1624947472017659"
                   unit="cnt"
                   value="100825"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeOsUser"
                   s="compile"
                   scope="compile"
                   ts="1624947472017675"
                   unit="ns"
                   value="6020000000"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeOsSystem"
                   s="compile"
                   scope="compile"
                   ts="1624947472017692"
                   unit="ns"
                   value="440000000"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeOsTotal"
                   s="compile"
                   scope="compile"
                   ts="1624947472017713"
                   unit="ns"
                   value="23090000000"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeUser"
                   s="compile"
                   scope="compile"
                   ts="1624947472017733"
                   unit="ns"
                   value="3190000000"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeSystem"
                   s="compile"
                   scope="compile"
                   ts="1624947472017753"
                   unit="ns"
                   value="260000000"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="WhenStarted"
                   s="compile"
                   scope="compile:compile c++"
                   ts="1624947472017776"
                   unit="ts"
                   value="1624947469410530"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeElapsed"
                   s="compile"
                   scope="compile:compile c++"
                   ts="1624947472017796"
                   unit="ns"
                   value="2606327771"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="WhenStarted"
                   s="compile"
                   scope="compile:generate"
                   ts="1624947472017816"
                   unit="ts"
                   value="1624947469231739"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeElapsed"
                   s="compile"
                   scope="compile:generate"
                   ts="1624947472017837"
                   unit="ns"
                   value="160188057"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="WhenStarted"
                   s="compile"
                   scope="compile:parse"
                   ts="1624947472017858"
                   unit="ts"
                   value="1624947469063868"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeElapsed"
                   s="compile"
                   scope="compile:parse"
                   ts="1624947472017883"
                   unit="ns"
                   value="148374287"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="WhenStarted"
                   s="compile"
                   scope="compile:write c++"
                   ts="1624947472017925"
                   unit="ts"
                   value="1624947469388072"/>
        <Statistic c="eclcc"
                   count="1"
                   creator="myeclccserver@10.0.0.209"
                   kind="TimeElapsed"
                   s="compile"
                   scope="compile:write c++"
                   ts="1624947472017960"
                   unit="ns"
                   value="3812305"/>
        <Statistic c="hthor"
                   count="1"
                   creator="myeclagent@10.0.0.209"
                   kind="WhenStarted"
                   s="global"
                   scope=""
                   ts="1624947472474470"
                   unit="ts"
                   value="1624947472474236"/>
    </Statistics>
    <Tracing>
        <EclAgentBuild>community_8.0.2-1</EclAgentBuild>
    </Tracing>
    <Workflow>
        <Item mode="normal"
              state="reqd"
              type="normal"
              wfid="1">
            <Schedule/>
        </Item>
    </Workflow>
</W20210629-061748><?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet href="../esp/xslt/xmlformatter.xsl" type="text/xsl"?><W20210629-061748 agentSession='4294993060'
                                                                                                                                                 buildVersion='community_8.0.2-1'
                                                                                                                                                 cloneable='1'
                                                                                                                                                 clusterName='thor'
                                                                                                                                                 codeVersion='652'
                                                                                                                                                 eclVersion='BUILD_VERSION_MAJOR.BUILD_VERSION_MINOR.BUILD_VERSION_POINT'
                                                                                                                                                 hash='2244056846'
                                                                                                                                                 isClone='0'
                                                                                                                                                 jobName='tmp_exec'
                                                                                                                                                 scope='aparra'
                                                                                                                                                 state='blocked'
                                                                                                                                                 submitID='aparra'
                                                                                                                                                 wuidVersion='2'
                                                                                                                                                 xmlns:xsi='http://www.w3.org/1999/XMLSchema-instance'> <Action>compile</Action>
<Debug>
    <allowvariableroxiefilenames>1</allowvariableroxiefilenames>
    <created_by>ws_workunits</created_by>
    <created_for>aparra</created_for>
    <eclcc_compiler_version>8.0.14</eclcc_compiler_version>
    <expandpersistinputdependencies>1</expandpersistinputdependencies>
    <maxcompilethreads>2</maxcompilethreads>
    <passdfstoeclcc>1</passdfstoeclcc>
    <targetclustertype>thorlcr</targetclustertype>
</Debug>
<Exceptions>
    <Exception code="2007"
               col="37"
               filename="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl"
               row="75"
               sequence="0"
               severity="1"
               source="eclcc"
               time="2021-06-29T06:17:49Z">
        Incompatible types for rmVal: should cast Integer to a Boolean
    </Exception>
</Exceptions>
<Graphs>
    <Graph name="graph1" type="activities" wfid="1">
        <xgmml>
            <graph wfid="1">
                <edge id="17_19" source="1" target="18">
                    <att name="_sourceActivity" value="17"/>
                    <att name="_targetActivity" value="19"/>
                </edge>
                <edge id="27_29" source="18" target="28">
                    <att name="_sourceActivity" value="27"/>
                    <att name="_targetActivity" value="29"/>
                </edge>
                <edge id="27_36" source="18" target="35">
                    <att name="_sourceActivity" value="27"/>
                    <att name="_targetActivity" value="36"/>
                </edge>
                <edge id="11_43" source="1" target="35">
                    <att name="_sourceActivity" value="11"/>
                    <att name="_targetActivity" value="43"/>
                </edge>
                <edge id="47_53" source="35" target="52">
                    <att name="_sourceActivity" value="47"/>
                    <att name="_targetActivity" value="53"/>
                </edge>
                <edge id="47_56" source="35" target="52">
                    <att name="_sourceActivity" value="47"/>
                    <att name="_targetActivity" value="56"/>
                </edge>
                <edge id="49_60" source="35" target="52">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="49"/>
                    <att name="_targetActivity" value="60"/>
                </edge>
                <edge id="11_66" source="1" target="65">
                    <att name="_sourceActivity" value="11"/>
                    <att name="_targetActivity" value="66"/>
                </edge>
                <edge id="63_73" source="52" target="72">
                    <att name="_sourceActivity" value="63"/>
                    <att name="_targetActivity" value="73"/>
                </edge>
                <edge id="71_75" source="65" target="72">
                    <att name="_sourceActivity" value="71"/>
                    <att name="_targetActivity" value="75"/>
                </edge>
                <edge id="11_76" source="1" target="72">
                    <att name="_sourceActivity" value="11"/>
                    <att name="_targetActivity" value="76"/>
                </edge>
                <edge id="51_77" source="35" target="72">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="51"/>
                    <att name="_targetActivity" value="77"/>
                </edge>
                <edge id="34_86" source="28" target="85">
                    <att name="_sourceActivity" value="34"/>
                    <att name="_targetActivity" value="86"/>
                </edge>
                <edge id="27_87" source="18" target="85">
                    <att name="_sourceActivity" value="27"/>
                    <att name="_targetActivity" value="87"/>
                </edge>
                <edge id="51_88" source="35" target="85">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="51"/>
                    <att name="_targetActivity" value="88"/>
                </edge>
                <edge id="15_103" source="1" target="102">
                    <att name="_sourceActivity" value="15"/>
                    <att name="_targetActivity" value="103"/>
                </edge>
                <edge id="108_110" source="102" target="109">
                    <att name="_sourceActivity" value="108"/>
                    <att name="_targetActivity" value="110"/>
                </edge>
                <edge id="47_111" source="35" target="109">
                    <att name="_sourceActivity" value="47"/>
                    <att name="_targetActivity" value="111"/>
                </edge>
                <edge id="84_115" source="72" target="114">
                    <att name="_sourceActivity" value="84"/>
                    <att name="_targetActivity" value="115"/>
                </edge>
                <edge id="83_116" source="72" target="114">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="83"/>
                    <att name="_targetActivity" value="116"/>
                </edge>
                <edge id="137_142" source="118" target="141">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="137"/>
                    <att name="_targetActivity" value="142"/>
                </edge>
                <edge id="47_144" source="35" target="141">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="47"/>
                    <att name="_targetActivity" value="144"/>
                </edge>
                <edge id="153_155" source="141" target="154">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="153"/>
                    <att name="_targetActivity" value="155"/>
                </edge>
                <edge id="97_156" source="85" target="154">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="97"/>
                    <att name="_targetActivity" value="156"/>
                </edge>
                <edge id="137_160" source="118" target="159">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="137"/>
                    <att name="_targetActivity" value="160"/>
                </edge>
                <edge id="158_161" source="154" target="159">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="158"/>
                    <att name="_targetActivity" value="161"/>
                </edge>
                <edge id="153_162" source="141" target="159">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="153"/>
                    <att name="_targetActivity" value="162"/>
                </edge>
                <edge id="101_163" source="85" target="159">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="101"/>
                    <att name="_targetActivity" value="163"/>
                </edge>
                <edge id="42_163" source="35" target="159">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="42"/>
                    <att name="_targetActivity" value="163"/>
                </edge>
                <edge id="167_169" source="159" target="168">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="167"/>
                    <att name="_targetActivity" value="169"/>
                </edge>
                <edge id="172_174" source="168" target="173">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="172"/>
                    <att name="_targetActivity" value="174"/>
                </edge>
                <edge id="90_175" source="85" target="173">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="90"/>
                    <att name="_targetActivity" value="175"/>
                </edge>
                <edge id="178_180" source="173" target="179">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="178"/>
                    <att name="_targetActivity" value="180"/>
                </edge>
                <edge id="178_186" source="173" target="185">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="178"/>
                    <att name="_targetActivity" value="186"/>
                </edge>
                <edge id="184_187" source="179" target="185">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="184"/>
                    <att name="_targetActivity" value="187"/>
                </edge>
                <edge id="184_190" source="179" target="185">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="184"/>
                    <att name="_targetActivity" value="190"/>
                </edge>
                <edge id="198_201" source="185" target="200">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="198"/>
                    <att name="_targetActivity" value="201"/>
                </edge>
                <edge id="205_207" source="200" target="206">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="205"/>
                    <att name="_targetActivity" value="207"/>
                </edge>
                <edge id="205_208" source="200" target="206">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="205"/>
                    <att name="_targetActivity" value="208"/>
                </edge>
                <edge id="139_221" source="118" target="206">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="139"/>
                    <att name="_targetActivity" value="221"/>
                </edge>
                <edge id="99_223" source="85" target="206">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="99"/>
                    <att name="_targetActivity" value="223"/>
                </edge>
                <edge id="199_224" source="185" target="206">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="199"/>
                    <att name="_targetActivity" value="224"/>
                </edge>
                <edge id="178_230" source="173" target="229">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="178"/>
                    <att name="_targetActivity" value="230"/>
                </edge>
                <edge id="228_231" source="206" target="229">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="228"/>
                    <att name="_targetActivity" value="231"/>
                </edge>
                <edge id="236_238" source="229" target="237">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="236"/>
                    <att name="_targetActivity" value="238"/>
                </edge>
                <edge id="235_239" source="229" target="237">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="235"/>
                    <att name="_targetActivity" value="239"/>
                </edge>
                <edge id="235_243" source="229" target="242">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="235"/>
                    <att name="_targetActivity" value="243"/>
                </edge>
                <edge id="241_244" source="237" target="242">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="241"/>
                    <att name="_targetActivity" value="244"/>
                </edge>
                <edge id="249_251" source="242" target="250">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="249"/>
                    <att name="_targetActivity" value="251"/>
                </edge>
                <edge id="249_260" source="242" target="259">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="249"/>
                    <att name="_targetActivity" value="260"/>
                </edge>
                <edge id="258_261" source="250" target="259">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="258"/>
                    <att name="_targetActivity" value="261"/>
                </edge>
                <edge id="263_265" source="259" target="264">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="263"/>
                    <att name="_targetActivity" value="265"/>
                </edge>
                <edge id="140_269" source="118" target="268">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="140"/>
                    <att name="_targetActivity" value="269"/>
                </edge>
                <edge id="228_270" source="206" target="268">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="228"/>
                    <att name="_targetActivity" value="270"/>
                </edge>
                <edge id="140_275" source="118" target="274">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="140"/>
                    <att name="_targetActivity" value="275"/>
                </edge>
                <edge id="138_276" source="118" target="274">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="138"/>
                    <att name="_targetActivity" value="276"/>
                </edge>
                <edge id="273_284" source="268" target="274">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="273"/>
                    <att name="_targetActivity" value="284"/>
                </edge>
                <edge id="236_287" source="229" target="274">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="236"/>
                    <att name="_targetActivity" value="287"/>
                </edge>
                <edge id="267_289" source="264" target="274">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="267"/>
                    <att name="_targetActivity" value="289"/>
                </edge>
                <edge id="249_290" source="242" target="274">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="249"/>
                    <att name="_targetActivity" value="290"/>
                </edge>
                <edge id="248_291" source="242" target="274">
                    <att name="_dependsOn" value="1"/>
                    <att name="_sourceActivity" value="248"/>
                    <att name="_targetActivity" value="291"/>
                </edge>
                <edge id="64_302" source="52" target="114">
                    <att name="_sourceActivity" value="64"/>
                    <att name="_targetActivity" value="302"/>
                </edge>
                <edge id="113_303" source="109" target="114">
                    <att name="_sourceActivity" value="113"/>
                    <att name="_targetActivity" value="303"/>
                </edge>
                <edge id="307_309" source="114" target="308">
                    <att name="_sourceActivity" value="307"/>
                    <att name="_targetActivity" value="309"/>
                </edge>
                <edge id="321_323" source="308" target="322">
                    <att name="_sourceActivity" value="321"/>
                    <att name="_targetActivity" value="323"/>
                </edge>
                <edge id="321_330" source="308" target="329">
                    <att name="_sourceActivity" value="321"/>
                    <att name="_targetActivity" value="330"/>
                </edge>
                <edge id="328_337" source="322" target="336">
                    <att name="_sourceActivity" value="328"/>
                    <att name="_targetActivity" value="337"/>
                </edge>
                <edge id="335_339" source="329" target="336">
                    <att name="_sourceActivity" value="335"/>
                    <att name="_targetActivity" value="339"/>
                </edge>
                <node id="1">
                    <att>
                        <graph>
                            <att name="rootGraph" value="1"/>
                            <edge id="2_0" source="2" target="3"/>
                            <edge id="3_0" source="3" target="4"/>
                            <edge id="4_0" source="4" target="5"/>
                            <edge id="5_0" source="5" target="6"/>
                            <edge id="6_0" source="6" target="7"/>
                            <edge id="7_0" source="7" target="8"/>
                            <edge id="8_0" source="8" target="9"/>
                            <edge id="9_0" source="9" target="10"/>
                            <edge id="10_0" source="10" target="11"/>
                            <edge id="6_1" source="6" target="12">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="3_1" source="3" target="13">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="8_1" source="8" target="14">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="14_0" source="14" target="15"/>
                            <edge id="3_2" source="3" target="16">
                                <att name="_sourceIndex" value="2"/>
                            </edge>
                            <edge id="16_0" source="16" target="17"/>
                            <node id="2" label="Inline Dataset">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(65,1)"/>
                                <att name="name" value="ds"/>
                                <att name="_kind" value="148"/>
                                <att name="ecl" value="DATASET(1000, make_data(LEFT, COUNTER));&#10;"/>
                                <att name="recordSize" value="40"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="3" label="Split">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(65,7)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="ds;&#10;"/>
                                <att name="recordSize" value="40"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="4" label="Project">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(75,1)"/>
                                <att name="name" value="Y"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({ unsigned8 id, integer4 value },SELF.id := LEFT.id;SELF.value := IF(rnd / 1000000.0 &lt;= 0.0, (LEFT.y  +  1) % 2, LEFT.y);));&#10;"/>
                                <att name="recordSize" value="12"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="5" label="Project">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(82,1)"/>
                                <att name="name" value="Ye"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({(RECORD&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10; END) integer4 value },...));&#10;"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="6" label="Split">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(82,7)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="Ye;&#10;"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="7" label="Project">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl(46,7)"/>
                                <att name="name" value="dsOut"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({ unsigned2 wi, unsigned8 id, real8 value },SELF.wi := LEFT.wi;SELF.id := LEFT.id;...));&#10;"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="8" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl(46,16)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="dsOut;&#10;"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="9" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(146,3)"/>
                                <att name="name" value="YD"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="10" label="Local Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(148,3)"/>
                                <att name="name" value="YSD"/>
                                <att name="_kind" value="3"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="SORT(wi, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="11" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::6&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="18"/>
                                <att name="_fileName" value="~spill::6"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                            <node id="12" label="Output&#10;&apos;Y_train&apos;">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(84,1)"/>
                                <att name="_kind" value="16"/>
                                <att name="ecl" value="OUTPUT(..., , named(&apos;Y_train&apos;), workunit);&#10;"/>
                                <att name="recordSize" value="18"/>
                            </node>
                            <node id="13" label="Output&#10;&apos;TrainingData&apos;">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(66,1)"/>
                                <att name="_kind" value="16"/>
                                <att name="ecl" value="OUTPUT(..., , named(&apos;TrainingData&apos;), workunit);&#10;"/>
                                <att name="recordSize" value="40"/>
                            </node>
                            <node id="14" label="Project">
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({ unsigned2 wi, real8 value },SELF.wi := LEFT.wi;SELF.value := LEFT.value;));&#10;"/>
                                <att name="recordSize" value="10"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="15" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::5&apos;, __compressed__);&#10;"/>
                                <att name="recordSize" value="10"/>
                                <att name="_fileName" value="~spill::5"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                            <node id="16" label="Project">
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned8 id;&#10;  real8 x1;&#10;  unsigned8 x2;&#10;  unsigned8 x3;&#10; END,...));&#10;"/>
                                <att name="recordSize" value="32"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="17" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::4&apos;, __compressed__);&#10;"/>
                                <att name="recordSize" value="32"/>
                                <att name="_fileName" value="~spill::4"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="18">
                    <att>
                        <graph>
                            <edge id="19_0" source="19" target="20"/>
                            <edge id="20_0" source="20" target="21"/>
                            <edge id="20_1" source="20" target="22">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="20_2" source="20" target="23">
                                <att name="_sourceIndex" value="2"/>
                            </edge>
                            <edge id="21_0" source="21" target="24"/>
                            <edge id="22_0" source="22" target="24">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="23_0" source="23" target="24">
                                <att name="_targetIndex" value="2"/>
                            </edge>
                            <edge id="24_0" source="24" target="25"/>
                            <edge id="25_0" source="25" target="26"/>
                            <edge id="26_0" source="26" target="27"/>
                            <node id="19" label="Spill Read">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(65,1)"/>
                                <att name="name" value="ds"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::4&apos;, RECORD&#10;  unsigned8 id;&#10;  real8 x1;&#10;  unsigned8 x2;&#10;  unsigned8 x3;&#10; END, THOR, __compressed__);&#10;"/>
                                <att name="recordSize" value="32"/>
                                <att name="predictedCount" value="1000"/>
                                <att name="_fileName" value="~spill::4"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="20" label="Split">
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="ds;&#10;"/>
                                <att name="recordSize" value="32"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="21" label="Project">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(68,1)"/>
                                <att name="name" value="X1"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.isordinal := true;SELF.wi := 1;...));&#10;"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="22" label="Project">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(70,1)"/>
                                <att name="name" value="X2"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.isordinal := true;SELF.wi := 1;...));&#10;"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="23" label="Project">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(72,1)"/>
                                <att name="name" value="X3"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.isordinal := true;SELF.wi := 1;...));&#10;"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="24" label="Funnel">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl(41,16)"/>
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(81,7)"/>
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(78,1)"/>
                                <att name="name" value="X"/>
                                <att name="_kind" value="17"/>
                                <att name="ordered" value="0"/>
                                <att name="ecl" value="X1  +  X2  +  X3;&#10;"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="25" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(145,3)"/>
                                <att name="name" value="XD"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="26" label="Local Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(147,3)"/>
                                <att name="name" value="XSD"/>
                                <att name="_kind" value="3"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="SORT(wi, id, number, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi, id, number"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="27" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::7&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi, id, number"/>
                                <att name="recordSize" value="23"/>
                                <att name="_fileName" value="~spill::7"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="28">
                    <att>
                        <graph>
                            <edge id="29_0" source="29" target="30"/>
                            <edge id="30_0" source="30" target="31"/>
                            <edge id="31_0" source="31" target="32"/>
                            <edge id="32_0" source="32" target="33"/>
                            <edge id="33_0" source="33" target="34"/>
                            <node id="29" label="Projected&#10;Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(128,5)"/>
                                <att name="name" value="xDat"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::7&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi, id, number"/>
                                <att name="recordSize" value="30"/>
                                <att name="predictedCount" value="3000"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(147,3)"/>
                                <att name="name" value="XSD"/>
                                <att name="_fileName" value="~spill::7"/>
                                <att name="_isTransformSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="30" label="Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(134,5)"/>
                                <att name="name" value="xDatS"/>
                                <att name="_kind" value="3"/>
                                <att name="ecl" value="SORT(wi, id);&#10;"/>
                                <att name="metaDistribution" value="sorted(wi, id)"/>
                                <att name="metaGlobalSortOrder" value="wi, id"/>
                                <att name="metaLocalSortOrder" value="wi, id"/>
                                <att name="recordSize" value="30"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="31" label="Iterate">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(135,5)"/>
                                <att name="name" value="xDat2"/>
                                <att name="_kind" value="9"/>
                                <att name="ecl" value="ITERATE(TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10;  real8 value;&#10;  unsigned8 newid;&#10; END,...));&#10;"/>
                                <att name="metaGlobalSortOrder" value="wi, id"/>
                                <att name="metaLocalSortOrder" value="wi, id"/>
                                <att name="recordSize" value="30"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="32" label="Project">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(136,5)"/>
                                <att name="name" value="outDat0"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.id := LEFT.newid;SELF.wi := LEFT.wi;...));&#10;"/>
                                <att name="metaGlobalSortOrder" value="wi"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="33" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(137,5)"/>
                                <att name="name" value="outDat"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="34" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::8&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="23"/>
                                <att name="_fileName" value="~spill::8"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="35">
                    <att>
                        <graph>
                            <edge id="36_0" source="36" target="37"/>
                            <edge id="37_0" source="37" target="38"/>
                            <edge id="38_0" source="38" target="39"/>
                            <edge id="39_0" source="39" target="40"/>
                            <edge id="40_0" source="40" target="41"/>
                            <edge id="41_0" source="41" target="42"/>
                            <edge id="43_0" source="43" target="44"/>
                            <edge id="44_0"
                                  label="LEFT"
                                  source="44"
                                  target="45"/>
                            <edge id="40_1"
                                  label="RIGHT"
                                  source="40"
                                  target="45">
                                <att name="_sourceIndex" value="1"/>
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="45_0" source="45" target="46"/>
                            <edge id="46_0" source="46" target="47"/>
                            <edge id="46_1" source="46" target="48">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="48_0" source="48" target="49"/>
                            <edge id="44_1" source="44" target="50">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="50_0" source="50" target="51"/>
                            <node id="36" label="Projected&#10;Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(147,3)"/>
                                <att name="name" value="XSD"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::7&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi, id, number"/>
                                <att name="recordSize" value="14"/>
                                <att name="predictedCount" value="3000"/>
                                <att name="_fileName" value="~spill::7"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="37" label="Local Group">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(164,17)"/>
                                <att name="_kind" value="15"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="GROUP(wi, id, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaGrouping" value="wi, id"/>
                                <att name="metaLocalSortOrder" value="wi, id"/>
                                <att name="metaGroupSortOrder" value="number"/>
                                <att name="recordSize" value="14"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="38" label="Grouped Aggregate">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(164,3)"/>
                                <att name="name" value="idFeatures"/>
                                <att name="_kind" value="10"/>
                                <att name="grouped" value="1"/>
                                <att name="ecl" value="TABLE({ unsigned2 wi := wi, integer8 numfeats := COUNT(group), unsigned4 maxfnum := MAX(group, number) }, local);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="14"/>
                                <att name="predictedCount" value="1..3000[group]"/>
                            </node>
                            <node id="39" label="Hash Aggregate">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(165,3)"/>
                                <att name="name" value="wiFeatures"/>
                                <att name="_kind" value="11"/>
                                <att name="ecl" value="TABLE({ unsigned2 wi := wi, integer8 numfeatures := MAX(group, numfeats), unsigned4 maxnum := MAX(group, maxfnum) }, wi);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="14"/>
                                <att name="predictedCount" value="1..3000[group]"/>
                            </node>
                            <node id="40" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(165,24)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.wiFeatures;&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="14"/>
                                <att name="predictedCount" value="1..3000[group]"/>
                            </node>
                            <node id="41" label="Aggregate">
                                <att name="_kind" value="10"/>
                                <att name="ecl" value="TABLE({ integer8 value := SUM(group, maxnum) });&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="1"/>
                            </node>
                            <node id="42" label="Store&#10;Internal(&apos;a4&apos;)">
                                <att name="_kind" value="22"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="extractresult(value, named(&apos;a4&apos;));&#10;"/>
                                <att name="recordSize" value="8"/>
                            </node>
                            <node id="43" label="Disk Grouped Aggregate&#10;Spill">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(163,3)"/>
                                <att name="name" value="wiSamples"/>
                                <att name="_kind" value="75"/>
                                <att name="ecl" value="DATASET(&apos;~spill::6&apos;, { unsigned2 wi, unsigned8 id, real8 value }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1..1000[group]"/>
                                <att name="_fileName" value="~spill::6"/>
                                <att name="_isTransformSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="44" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(163,23)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.wiSamples;&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1..1000[group]"/>
                            </node>
                            <node id="45" label="Join">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,20)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                <att name="name" value="wiMeta0"/>
                                <att name="_kind" value="155"/>
                                <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, makeMeta(LEFT));&#10;"/>
                                <att name="recordSize" value="22"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="46" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,20)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,14)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="wiMeta0;&#10;"/>
                                <att name="recordSize" value="22"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="47" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::1&apos;, __compressed__);&#10;"/>
                                <att name="recordSize" value="22"/>
                                <att name="_fileName" value="~spill::1"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                            <node id="48" label="Aggregate">
                                <att name="_kind" value="10"/>
                                <att name="ecl" value="TABLE({ unsigned8 numsamples := MAX(group, numsamples) });&#10;"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="1"/>
                            </node>
                            <node id="49" label="Store&#10;Internal(&apos;a1&apos;)">
                                <att name="_kind" value="22"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="extractresult(numsamples, named(&apos;a1&apos;));&#10;"/>
                                <att name="recordSize" value="8"/>
                            </node>
                            <node id="50" label="Aggregate">
                                <att name="_kind" value="10"/>
                                <att name="ecl" value="TABLE({ integer8 value := SUM(group, ABS(numsamples  -  maxid)) });&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="1"/>
                            </node>
                            <node id="51" label="Store&#10;Internal(&apos;a2&apos;)">
                                <att name="_kind" value="22"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="extractresult(value, named(&apos;a2&apos;));&#10;"/>
                                <att name="recordSize" value="8"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="52">
                    <att>
                        <graph>
                            <edge id="53_0" source="53" target="54"/>
                            <edge id="54_0" source="54" target="55"/>
                            <edge id="55_0"
                                  label="LEFT"
                                  source="55"
                                  target="57"/>
                            <edge id="56_0"
                                  label="RIGHT"
                                  source="56"
                                  target="57">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="58_0" source="58" target="59"/>
                            <edge id="59_0" source="59" target="60"/>
                            <edge id="60_0" source="60" target="61"/>
                            <edge id="57_0"
                                  label="LEFT"
                                  source="57"
                                  target="62"/>
                            <edge id="61_0"
                                  label="RIGHT"
                                  source="61"
                                  target="62">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="62_0" source="62" target="63"/>
                            <edge id="61_1" source="61" target="64">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <node id="53" label="Projected&#10;Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(340,5)"/>
                                <att name="name" value="dummyTrees"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::1&apos;, RECORD&#10;  unsigned2 wi;&#10;  unsigned8 numsamples;&#10;  unsigned4 numfeatures;&#10;  unsigned8 featurespernode;&#10; END, THOR, __compressed__);&#10;"/>
                                <att name="recordSize" value="2"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,3)"/>
                                <att name="name" value="wiMeta"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                <att name="name" value="wiMeta0"/>
                                <att name="_fileName" value="~spill::1"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="54" label="Normalize">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(342,5)"/>
                                <att name="name" value="trees"/>
                                <att name="_kind" value="21"/>
                                <att name="ecl" value="NORMALIZE(20, TRANSFORM({ unsigned4 treeid, unsigned2 wi },SELF.treeid := COUNTER;SELF.wi := LEFT.wi;));&#10;"/>
                                <att name="recordSize" value="6"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="55" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(344,5)"/>
                                <att name="name" value="treesD"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="6"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="56" label="Projected&#10;Spill Read">
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::1&apos;, RECORD&#10;  unsigned2 wi;&#10;  unsigned8 numsamples;&#10;  unsigned4 numfeatures;&#10;  unsigned8 featurespernode;&#10; END, THOR, __compressed__);&#10;"/>
                                <att name="recordSize" value="10"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,3)"/>
                                <att name="name" value="wiMeta"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                <att name="name" value="wiMeta0"/>
                                <att name="_fileName" value="~spill::1"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="57" label="Lookup Join">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(306,5)"/>
                                <att name="name" value="xTrees"/>
                                <att name="_kind" value="157"/>
                                <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, TRANSFORM({ unsigned4 treeid, unsigned2 wi, unsigned8 numsamples },SELF.numsamples := RIGHT.numsamples;...), lookup, few);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="14"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="58" label="Inline Dataset">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(216,3)"/>
                                <att name="name" value="treeDummy"/>
                                <att name="_kind" value="148"/>
                                <att name="ecl" value="DATASET(20, TRANSFORM({ unsigned4 treeid },SELF.treeid := COUNTER;), { unsigned4 treeid });&#10;"/>
                                <att name="recordSize" value="4"/>
                                <att name="predictedCount" value="20"/>
                            </node>
                            <node id="59" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(218,3)"/>
                                <att name="name" value="treeDummyD"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(treeid);&#10;"/>
                                <att name="metaDistribution" value="treeid"/>
                                <att name="recordSize" value="4"/>
                                <att name="predictedCount" value="20"/>
                            </node>
                            <node id="60" label="Normalize">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(230,28)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(222,3)"/>
                                <att name="name" value="treeSampleIndxSampled"/>
                                <att name="_kind" value="21"/>
                                <att name="ecl" value="NORMALIZE(INTERNAL(&apos;a1&apos;), TRANSFORM({ unsigned4 treeid, unsigned8 id, unsigned8 origid },SELF.origid := (RANDOM() % INTERNAL(&apos;a1&apos;)  +  1);...));&#10;"/>
                                <att name="metaDistribution" value="treeid"/>
                                <att name="recordSize" value="20"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="61" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(230,28)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(222,28)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="treeSampleIndxSampled;&#10;"/>
                                <att name="metaDistribution" value="treeid"/>
                                <att name="recordSize" value="20"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="62" label="Lookup Join">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(317,17)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(311,5)"/>
                                <att name="name" value="treeDat0"/>
                                <att name="_kind" value="157"/>
                                <att name="ecl" value="JOIN(LEFT.treeid = RIGHT.treeid AND RIGHT.origid &lt;= LEFT.numsamples, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  integer4 origid;&#10; END,...), many, lookup);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="63" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::A&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="18"/>
                                <att name="_fileName" value="~spill::A"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                            <node id="64" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::9&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="treeid"/>
                                <att name="recordSize" value="20"/>
                                <att name="_fileName" value="~spill::9"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="65">
                    <att>
                        <graph>
                            <edge id="66_0" source="66" target="67"/>
                            <edge id="67_0" source="67" target="68"/>
                            <edge id="68_0" source="68" target="69"/>
                            <edge id="69_0" source="69" target="70"/>
                            <edge id="70_0" source="70" target="71"/>
                            <node id="66" label="Projected&#10;Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(128,5)"/>
                                <att name="name" value="xDat"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::6&apos;, { unsigned2 wi, unsigned8 id, real8 value }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="26"/>
                                <att name="predictedCount" value="1000"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(148,3)"/>
                                <att name="name" value="YSD"/>
                                <att name="_fileName" value="~spill::6"/>
                                <att name="_isTransformSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="67" label="Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(134,5)"/>
                                <att name="name" value="xDatS"/>
                                <att name="_kind" value="3"/>
                                <att name="ecl" value="SORT(wi, id);&#10;"/>
                                <att name="metaDistribution" value="sorted(wi, id)"/>
                                <att name="metaGlobalSortOrder" value="wi, id"/>
                                <att name="metaLocalSortOrder" value="wi, id"/>
                                <att name="recordSize" value="26"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="68" label="Iterate">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(135,5)"/>
                                <att name="name" value="xDat2"/>
                                <att name="_kind" value="9"/>
                                <att name="ecl" value="ITERATE(TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  real8 value;&#10;  unsigned8 newid;&#10; END,...));&#10;"/>
                                <att name="metaGlobalSortOrder" value="wi, id"/>
                                <att name="metaLocalSortOrder" value="wi, id"/>
                                <att name="recordSize" value="26"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="69" label="Project">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(136,5)"/>
                                <att name="name" value="outDat0"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({ unsigned2 wi, unsigned8 id, real8 value },SELF.id := LEFT.newid;SELF.wi := LEFT.wi;...));&#10;"/>
                                <att name="metaGlobalSortOrder" value="wi"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="70" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(137,5)"/>
                                <att name="name" value="outDat"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="71" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::B&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="18"/>
                                <att name="_fileName" value="~spill::B"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="72">
                    <att>
                        <graph>
                            <edge id="73_0" source="73" target="74"/>
                            <edge id="75_0"
                                  label="True"
                                  source="75"
                                  target="77"/>
                            <edge id="76_0"
                                  label="False"
                                  source="76"
                                  target="77">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="74_0"
                                  label="LEFT"
                                  source="74"
                                  target="78"/>
                            <edge id="77_0"
                                  label="RIGHT"
                                  source="77"
                                  target="78">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="78_0" source="78" target="79"/>
                            <edge id="79_0" source="79" target="80"/>
                            <edge id="80_0" source="80" target="81"/>
                            <edge id="81_0" source="81" target="82"/>
                            <edge id="82_0" source="82" target="83"/>
                            <edge id="80_1" source="80" target="84">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <node id="73" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(317,17)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(311,5)"/>
                                <att name="name" value="treeDat0"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::A&apos;, RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  integer4 origid;&#10; END, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="_fileName" value="~spill::A"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="74" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(319,5)"/>
                                <att name="name" value="treeDat1D"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, origid));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="75" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(137,5)"/>
                                <att name="name" value="outDat"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::B&apos;, { unsigned2 wi, unsigned8 id, real8 value }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                                <att name="_fileName" value="~spill::B"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="76" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(148,3)"/>
                                <att name="name" value="YSD"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::6&apos;, { unsigned2 wi, unsigned8 id, real8 value }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                                <att name="_fileName" value="~spill::6"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="77" label="If">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(180,3)"/>
                                <att name="name" value="Y"/>
                                <att name="_kind" value="28"/>
                                <att name="ecl" value="IF(INTERNAL(&apos;a2&apos;) != 0, outDat, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.YSD);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1000"/>
                                <att name="_graphIndependent" value="1"/>
                            </node>
                            <node id="78" label="Local Join">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(323,5)"/>
                                <att name="name" value="treeDat2"/>
                                <att name="_kind" value="155"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.origid = RIGHT.id, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                <att name="recordSize" value="82"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="79" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(362,5)"/>
                                <att name="name" value="rootsD"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="82"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="80" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(362,15)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="rootsD;&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="82"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="81" label="Filter">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,52)"/>
                                <att name="_kind" value="5"/>
                                <att name="ecl" value="FILTER(id &gt; 0);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="82"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="82" label="Exists">
                                <att name="_kind" value="124"/>
                                <att name="ecl" value="TABLE({ boolean value := EXISTS(group) });&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="1"/>
                                <att name="predictedCount" value="1"/>
                            </node>
                            <node id="83" label="Store&#10;Internal(&apos;a6&apos;)">
                                <att name="_kind" value="22"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="extractresult(value, named(&apos;a6&apos;));&#10;"/>
                                <att name="recordSize" value="1"/>
                            </node>
                            <node id="84" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::C&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="82"/>
                                <att name="_fileName" value="~spill::C"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="85">
                    <att>
                        <graph>
                            <edge id="86_0"
                                  label="True"
                                  source="86"
                                  target="88"/>
                            <edge id="87_0"
                                  label="False"
                                  source="87"
                                  target="88">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="88_0" source="88" target="89"/>
                            <edge id="89_0" source="89" target="90"/>
                            <edge id="89_1" source="89" target="91">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="91_0" source="91" target="92"/>
                            <edge id="92_0" source="92" target="93"/>
                            <edge id="93_0" source="93" target="94"/>
                            <edge id="94_0" source="94" target="95"/>
                            <edge id="95_0" source="95" target="96"/>
                            <edge id="96_0" source="96" target="97"/>
                            <edge id="96_1" source="96" target="98">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="98_0" source="98" target="99"/>
                            <edge id="96_2" source="96" target="100">
                                <att name="_sourceIndex" value="2"/>
                            </edge>
                            <edge id="100_0" source="100" target="101"/>
                            <node id="86" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(137,5)"/>
                                <att name="name" value="outDat"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::8&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                                <att name="_fileName" value="~spill::8"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="87" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(147,3)"/>
                                <att name="name" value="XSD"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::7&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaLocalSortOrder" value="wi, id, number"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                                <att name="_fileName" value="~spill::7"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="88" label="If">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(179,3)"/>
                                <att name="name" value="X"/>
                                <att name="_kind" value="28"/>
                                <att name="ecl" value="IF(INTERNAL(&apos;a2&apos;) != 0, outDat, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.XSD);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                                <att name="_graphIndependent" value="1"/>
                            </node>
                            <node id="89" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(179,15)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.X;&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="3000"/>
                            </node>
                            <node id="90" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::3&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="23"/>
                                <att name="_fileName" value="~spill::3"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                            <node id="91" label="Filter">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(185,23)"/>
                                <att name="_kind" value="5"/>
                                <att name="ecl" value="FILTER(id = 1);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="0..3000[group]"/>
                            </node>
                            <node id="92" label="Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(185,3)"/>
                                <att name="name" value="allFeatures"/>
                                <att name="_kind" value="3"/>
                                <att name="ecl" value="SORT(wi, number);&#10;"/>
                                <att name="metaDistribution" value="sorted(wi, number)"/>
                                <att name="metaGlobalSortOrder" value="wi, number"/>
                                <att name="metaLocalSortOrder" value="wi, number"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="0..3000[group]"/>
                            </node>
                            <node id="93" label="Group">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(186,3)"/>
                                <att name="name" value="allFeaturesG"/>
                                <att name="_kind" value="15"/>
                                <att name="ecl" value="GROUP(wi);&#10;"/>
                                <att name="metaGrouping" value="wi"/>
                                <att name="metaGlobalSortOrder" value="wi, number"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="metaGroupSortOrder" value="number"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="0..3000[group]"/>
                            </node>
                            <node id="94" label="Grouped Count Project">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(187,3)"/>
                                <att name="name" value="featureMap0"/>
                                <att name="_kind" value="31"/>
                                <att name="grouped" value="1"/>
                                <att name="ecl" value="PROJECT(TRANSFORM({(numericfield) boolean isordinal },SELF.id := COUNTER;SELF.wi := LEFT.wi;...));&#10;"/>
                                <att name="metaGrouping" value="wi"/>
                                <att name="metaGlobalSortOrder" value="wi, number"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="metaGroupSortOrder" value="number"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="0..3000[group]"/>
                            </node>
                            <node id="95" label="Degroup">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(188,3)"/>
                                <att name="name" value="featureMap"/>
                                <att name="_kind" value="14"/>
                                <att name="ecl" value="GROUP();&#10;"/>
                                <att name="metaGlobalSortOrder" value="wi, number"/>
                                <att name="metaLocalSortOrder" value="wi, number"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="0..3000[group]"/>
                            </node>
                            <node id="96" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(188,24)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.featureMap;&#10;"/>
                                <att name="metaGlobalSortOrder" value="wi, number"/>
                                <att name="metaLocalSortOrder" value="wi, number"/>
                                <att name="recordSize" value="23"/>
                                <att name="predictedCount" value="0..3000[group]"/>
                            </node>
                            <node id="97" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::2&apos;, __compressed__);&#10;"/>
                                <att name="metaGlobalSortOrder" value="wi, number"/>
                                <att name="metaLocalSortOrder" value="wi, number"/>
                                <att name="recordSize" value="23"/>
                                <att name="_fileName" value="~spill::2"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                            <node id="98" label="Aggregate">
                                <att name="_kind" value="10"/>
                                <att name="ecl" value="TABLE({ unsigned8 id := MAX(group, id) });&#10;"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="1"/>
                            </node>
                            <node id="99" label="Store&#10;Internal(&apos;a5&apos;)">
                                <att name="_kind" value="22"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="extractresult(id, named(&apos;a5&apos;));&#10;"/>
                                <att name="recordSize" value="8"/>
                            </node>
                            <node id="100" label="Count">
                                <att name="_kind" value="125"/>
                                <att name="ecl" value="TABLE({ integer8 value := COUNT(group) });&#10;"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="1"/>
                            </node>
                            <node id="101" label="Store&#10;Internal(&apos;a3&apos;)">
                                <att name="_kind" value="22"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="extractresult(value, named(&apos;a3&apos;));&#10;"/>
                                <att name="recordSize" value="8"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="102">
                    <att>
                        <graph>
                            <edge id="103_0" source="103" target="104"/>
                            <edge id="104_0" source="104" target="105"/>
                            <edge id="105_0" source="105" target="106"/>
                            <edge id="106_0" source="106" target="107"/>
                            <edge id="107_0" source="107" target="108"/>
                            <node id="103" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl(46,7)"/>
                                <att name="name" value="dsOut"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::5&apos;, { unsigned2 wi, real8 value }, THOR, __compressed__);&#10;"/>
                                <att name="recordSize" value="10"/>
                                <att name="predictedCount" value="1000"/>
                                <att name="_fileName" value="~spill::5"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="104" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(52,5)"/>
                                <att name="name" value="Y_DS"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, value));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, value)"/>
                                <att name="recordSize" value="10"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="105" label="Local Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(53,20)"/>
                                <att name="_kind" value="3"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="SORT(wi, value, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, value)"/>
                                <att name="metaLocalSortOrder" value="wi, value"/>
                                <att name="recordSize" value="10"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="106" label="Local Group">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(53,20)"/>
                                <att name="_kind" value="15"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="GROUP(wi, value, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, value)"/>
                                <att name="metaGrouping" value="wi, value"/>
                                <att name="metaLocalSortOrder" value="wi, value"/>
                                <att name="recordSize" value="10"/>
                                <att name="predictedCount" value="1000"/>
                            </node>
                            <node id="107" label="Grouped Aggregate">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(53,5)"/>
                                <att name="name" value="classCounts"/>
                                <att name="_kind" value="10"/>
                                <att name="grouped" value="1"/>
                                <att name="ecl" value="TABLE({ unsigned2 wi := wi, real8 value := value, integer8 cnt := COUNT(group) });&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, value)"/>
                                <att name="metaLocalSortOrder" value="wi, value"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1..1000[group]"/>
                            </node>
                            <node id="108" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::D&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, value)"/>
                                <att name="metaLocalSortOrder" value="wi, value"/>
                                <att name="recordSize" value="18"/>
                                <att name="_fileName" value="~spill::D"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="109">
                    <att>
                        <graph>
                            <edge id="110_0"
                                  label="LEFT"
                                  source="110"
                                  target="112"/>
                            <edge id="111_0"
                                  label="RIGHT"
                                  source="111"
                                  target="112">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="112_0" source="112" target="113"/>
                            <node id="110" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(53,5)"/>
                                <att name="name" value="classCounts"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::D&apos;, { unsigned2 wi, real8 value, integer8 cnt }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, value)"/>
                                <att name="metaLocalSortOrder" value="wi, value"/>
                                <att name="recordSize" value="18"/>
                                <att name="predictedCount" value="1..1000[group]"/>
                                <att name="_fileName" value="~spill::D"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="111" label="Projected&#10;Spill Read">
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::1&apos;, RECORD&#10;  unsigned2 wi;&#10;  unsigned8 numsamples;&#10;  unsigned4 numfeatures;&#10;  unsigned8 featurespernode;&#10; END, THOR, __compressed__);&#10;"/>
                                <att name="recordSize" value="10"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,3)"/>
                                <att name="name" value="wiMeta"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                <att name="name" value="wiMeta0"/>
                                <att name="_fileName" value="~spill::1"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="112" label="Lookup Join">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(472,23)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(55,5)"/>
                                <att name="name" value="classWeights"/>
                                <att name="_kind" value="157"/>
                                <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, TRANSFORM({ unsigned2 wi, real8 value, set of unsigned4 indexes },SELF.wi := LEFT.wi;...), lookup);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="113" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::E&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="_fileName" value="~spill::E"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="114">
                    <att>
                        <graph>
                            <att name="rootGraph" value="1"/>
                            <edge id="297_116"
                                  label="Child"
                                  source="297"
                                  target="116">
                                <att name="_childGraph" value="1"/>
                            </edge>
                            <edge id="298_116"
                                  label="Body"
                                  source="298"
                                  target="116">
                                <att name="_childGraph" value="1"/>
                            </edge>
                            <edge id="115_0" source="115" target="116"/>
                            <edge id="116_0" source="116" target="299"/>
                            <edge id="299_0" source="299" target="300"/>
                            <edge id="300_0" source="300" target="301"/>
                            <edge id="301_0" source="301" target="304"/>
                            <edge id="302_0" source="302" target="304">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="303_0" source="303" target="304">
                                <att name="_targetIndex" value="2"/>
                            </edge>
                            <edge id="304_0" source="304" target="305"/>
                            <edge id="305_0" source="305" target="306"/>
                            <edge id="305_1" source="305" target="307">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <node id="115" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(362,5)"/>
                                <att name="name" value="rootsD"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::C&apos;, RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                <att name="recordSize" value="82"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="_fileName" value="~spill::C"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="116" label="Loop">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,5)"/>
                                <att name="name" value="treeNodes"/>
                                <att name="_kind" value="103"/>
                                <att name="ecl" value="LOOP(LEFT.id &gt; 0, EXISTS(...), no_loopbody(), loopfirst(INTERNAL(&apos;a6&apos;)));&#10;"/>
                                <att name="recordSize" value="82"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="_loopid" value="117"/>
                            </node>
                            <node id="117">
                                <att name="_kind" value="1">
                                    <graph loopBody="1">
                                        <att name="_numResults" value="27"/>
                                        <node id="118">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="119_0" source="119" target="120"/>
                                                    <edge id="120_0" source="120" target="121"/>
                                                    <edge id="121_0" source="121" target="122"/>
                                                    <edge id="122_0" source="122" target="123"/>
                                                    <edge id="123_0" source="123" target="124"/>
                                                    <edge id="124_0" source="124" target="125"/>
                                                    <edge id="125_0" source="125" target="126"/>
                                                    <edge id="123_1"
                                                          label="LEFT"
                                                          source="123"
                                                          target="127">
                                                        <att name="_sourceIndex" value="1"/>
                                                    </edge>
                                                    <edge id="126_0"
                                                          label="RIGHT"
                                                          source="126"
                                                          target="127">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="127_0" source="127" target="128"/>
                                                    <edge id="128_0" source="128" target="129"/>
                                                    <edge id="129_0" source="129" target="130"/>
                                                    <edge id="130_0" source="130" target="131"/>
                                                    <edge id="131_0" source="131" target="132"/>
                                                    <edge id="132_0" source="132" target="133"/>
                                                    <edge id="133_0" source="133" target="134"/>
                                                    <edge id="134_0" source="134" target="135"/>
                                                    <edge id="126_1"
                                                          label="LEFT"
                                                          source="126"
                                                          target="136">
                                                        <att name="_sourceIndex" value="1"/>
                                                    </edge>
                                                    <edge id="135_0"
                                                          label="RIGHT"
                                                          source="135"
                                                          target="136">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="136_0" source="136" target="137"/>
                                                    <edge id="135_1" source="135" target="138">
                                                        <att name="_sourceIndex" value="1"/>
                                                    </edge>
                                                    <edge id="133_1" source="133" target="139">
                                                        <att name="_sourceIndex" value="1"/>
                                                    </edge>
                                                    <edge id="123_2" source="123" target="140">
                                                        <att name="_sourceIndex" value="2"/>
                                                    </edge>
                                                    <node id="119" label="Begin Loop">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,52)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(1);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="120" label="Local Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, treeid, nodeid, depend, parentid, isleft, local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="121" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, depend, parentid, isleft, local);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="122" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,5)"/>
                                                        <att name="name" value="nodeValCounts"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, real8 depend := depend, unsigned8 parentid := parentid, boolean isleft := isleft, integer8 cnt := COUNT(group), real8 weightsum := SUM(group, observweight) }, local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="recordSize" value="47"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="123" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="nodeValCounts;&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="recordSize" value="47"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="124" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(214,19)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="depend, parentid, isleft"/>
                                                        <att name="recordSize" value="47"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="125" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(214,5)"/>
                                                        <att name="name" value="nodeCounts"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, real8 totweights := SUM(group, weightsum) }, local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="126" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(214,19)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="nodeCounts;&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="127" label="Lightweight Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(219,5)"/>
                                                        <att name="name" value="nodeEntInfo"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="128" label="Local Group">
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="129" label="Grouped Sort">
                                                        <att name="_kind" value="3"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(parentid, isleft);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="parentid, isleft"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="130" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(226,17)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, parentid, isleft, local);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="131" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(226,5)"/>
                                                        <att name="name" value="nodeEnt0"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned8 parentid := parentid, boolean isleft := isleft, real8 entropy := SUM(group, plogp), unsigned8 tot := SUM(group, cnt) }, local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="132" label="Project">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(231,5)"/>
                                                        <att name="name" value="nodeImp"/>
                                                        <att name="_kind" value="7"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="PROJECT(TRANSFORM({(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;... END)... },...));&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="133" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(231,16)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="nodeImp;&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="134" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(238,5)"/>
                                                        <att name="name" value="pureEnoughNodes"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(impurity &lt; 1e-07 OR &lt;...&gt;.&lt;unnamed&gt; = 100);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="135" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(238,24)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="pureEnoughNodes;&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="136" label="Lightweight Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(242,5)"/>
                                                        <att name="name" value="toSplitNodes"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM({ unsigned4 treeid, unsigned8 nodeid, unsigned2 wi },SELF.treeid := LEFT.treeid;...), left only, local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="137" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(8);&#10;"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                    <node id="138" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(7);&#10;"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                    <node id="139" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(6);&#10;"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                    <node id="140" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(5);&#10;"/>
                                                        <att name="recordSize" value="47"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="141">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="142_0" source="142" target="143"/>
                                                    <edge id="143_0"
                                                          label="LEFT"
                                                          source="143"
                                                          target="145"/>
                                                    <edge id="144_0"
                                                          label="RIGHT"
                                                          source="144"
                                                          target="145">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="145_0" source="145" target="146"/>
                                                    <edge id="146_0" source="146" target="147"/>
                                                    <edge id="147_0" source="147" target="148"/>
                                                    <edge id="148_0" source="148" target="149"/>
                                                    <edge id="149_0" source="149" target="150"/>
                                                    <edge id="150_0" source="150" target="151"/>
                                                    <edge id="151_0" source="151" target="152"/>
                                                    <edge id="152_0" source="152" target="153"/>
                                                    <node id="142" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(242,5)"/>
                                                        <att name="name" value="toSplitNodes"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(8);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="143" label="Local Dedup">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(238,5)"/>
                                                        <att name="name" value="nodes"/>
                                                        <att name="_kind" value="4"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="144" label="Projected&#10;Spill Read">
                                                        <att name="_kind" value="195"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DATASET(&apos;~spill::1&apos;, RECORD&#10;  unsigned2 wi;&#10;  unsigned8 numsamples;&#10;  unsigned4 numfeatures;&#10;  unsigned8 featurespernode;&#10; END, THOR, __compressed__, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.wiMeta);&#10;"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(177,3)"/>
                                                        <att name="name" value="wiMeta"/>
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(166,3)"/>
                                                        <att name="name" value="wiMeta0"/>
                                                        <att name="_fileName" value="~spill::1"/>
                                                        <att name="_isSpill" value="1"/>
                                                        <att name="signedBy" value="hpcc"/>
                                                    </node>
                                                    <node id="145" label="Lookup Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(252,5)"/>
                                                        <att name="name" value="xNodes"/>
                                                        <att name="_kind" value="157"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned8 numfeatures;&#10;... END,...), lookup, few);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="30"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="146" label="Normalize">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(265,5)"/>
                                                        <att name="name" value="nodeVars0"/>
                                                        <att name="_kind" value="21"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="NORMALIZE(LEFT.featurespernode * 2, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10;... END,...));&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="34"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="147" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(266,5)"/>
                                                        <att name="name" value="nodeVars1"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="34"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="148" label="Grouped Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(267,5)"/>
                                                        <att name="name" value="nodeVars2"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, treeid, nodeid, number);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="34"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="149" label="Grouped Dedup">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(269,5)"/>
                                                        <att name="name" value="nodeVars3"/>
                                                        <att name="_kind" value="4"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DEDUP(wi, treeid, nodeid, number);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="34"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="150" label="Grouped Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(272,5)"/>
                                                        <att name="name" value="nodeVars4"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, treeid, nodeid, rnd);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="wi, treeid, nodeid, rnd"/>
                                                        <att name="recordSize" value="34"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="151" label="Grouped Count Project">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(275,26)"/>
                                                        <att name="_kind" value="31"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10; END,...));&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="152" label="Degroup">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(275,5)"/>
                                                        <att name="name" value="nodeVars5"/>
                                                        <att name="_kind" value="14"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP();&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="153" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(9);&#10;"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="154">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="155_0"
                                                          label="LEFT"
                                                          source="155"
                                                          target="157"/>
                                                    <edge id="156_0"
                                                          label="RIGHT"
                                                          source="156"
                                                          target="157">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="157_0" source="157" target="158"/>
                                                    <node id="155" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(275,5)"/>
                                                        <att name="name" value="nodeVars5"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(9);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="156" label="Projected&#10;Spill Read">
                                                        <att name="_kind" value="195"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DATASET(&apos;~spill::2&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.featureMap);&#10;"/>
                                                        <att name="metaGlobalSortOrder" value="wi, number"/>
                                                        <att name="metaLocalSortOrder" value="wi, number"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="predictedCount" value="0..3000[group]"/>
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(188,3)"/>
                                                        <att name="name" value="featureMap"/>
                                                        <att name="_fileName" value="~spill::2"/>
                                                        <att name="_isSpill" value="1"/>
                                                        <att name="signedBy" value="hpcc"/>
                                                    </node>
                                                    <node id="157" label="Lookup Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(281,7)"/>
                                                        <att name="name" value="rnDat"/>
                                                        <att name="_kind" value="157"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.id, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10; END,...), lookup);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="158" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(10);&#10;"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="159">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="161_0"
                                                          label="True"
                                                          source="161"
                                                          target="163"/>
                                                    <edge id="162_0"
                                                          label="False"
                                                          source="162"
                                                          target="163">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="160_0"
                                                          label="LEFT"
                                                          source="160"
                                                          target="164"/>
                                                    <edge id="163_0"
                                                          label="RIGHT"
                                                          source="163"
                                                          target="164">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="164_0"
                                                          label="LEFT"
                                                          source="164"
                                                          target="166"/>
                                                    <edge id="165_0"
                                                          label="RIGHT"
                                                          source="165"
                                                          target="166">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="166_0" source="166" target="167"/>
                                                    <node id="160" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(242,5)"/>
                                                        <att name="name" value="toSplitNodes"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(8);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="161" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(281,7)"/>
                                                        <att name="name" value="rnDat"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(10);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="162" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(275,5)"/>
                                                        <att name="name" value="nodeVars5"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(9);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="163" label="If">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(285,5)"/>
                                                        <att name="name" value="nodeVars"/>
                                                        <att name="_kind" value="66"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="IF(INTERNAL(&apos;a3&apos;) != INTERNAL(&apos;a4&apos;), rnDat, nodeVars5);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphIndependent" value="1"/>
                                                    </node>
                                                    <node id="164" label="Lightweight Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(290,5)"/>
                                                        <att name="name" value="nodeVarDat"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10; END,...), local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="18"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="165" label="Begin Loop">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,52)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(1);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="166" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(253,5)"/>
                                                        <att name="name" value="toSplitDat0"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="62"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="167" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(11);&#10;"/>
                                                        <att name="recordSize" value="62"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="168">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="169_0" source="169" target="170"/>
                                                    <edge id="170_0" source="170" target="171"/>
                                                    <edge id="171_0" source="171" target="172"/>
                                                    <node id="169" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(253,5)"/>
                                                        <att name="name" value="toSplitDat0"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(11);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="62"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="170" label="Hash Distribute">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(257,24)"/>
                                                        <att name="_kind" value="19"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DISTRIBUTE(HASH32(wi, origid));&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                                        <att name="recordSize" value="62"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="171" label="Local Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(257,5)"/>
                                                        <att name="name" value="toSplitDat1"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, origid, number, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, origid, number"/>
                                                        <att name="recordSize" value="62"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="172" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(12);&#10;"/>
                                                        <att name="recordSize" value="62"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="173">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="174_0"
                                                          label="LEFT"
                                                          source="174"
                                                          target="176"/>
                                                    <edge id="175_0"
                                                          label="RIGHT"
                                                          source="175"
                                                          target="176">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="176_0" source="176" target="177"/>
                                                    <edge id="177_0" source="177" target="178"/>
                                                    <node id="174" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(257,5)"/>
                                                        <att name="name" value="toSplitDat1"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(12);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, origid, number"/>
                                                        <att name="recordSize" value="62"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="175" label="Projected&#10;Spill Read">
                                                        <att name="_kind" value="195"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DATASET(&apos;~spill::3&apos;, {(numericfield) boolean isordinal }, THOR, __compressed__, _versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Base.X);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, id)"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="predictedCount" value="3000"/>
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(179,3)"/>
                                                        <att name="name" value="X"/>
                                                        <att name="_fileName" value="~spill::3"/>
                                                        <att name="_isSpill" value="1"/>
                                                        <att name="signedBy" value="hpcc"/>
                                                    </node>
                                                    <node id="176" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(258,5)"/>
                                                        <att name="name" value="toSplitDat2"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.origid = RIGHT.id AND LEFT.number = RIGHT.number, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, origid)"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="177" label="Hash Distribute">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(262,5)"/>
                                                        <att name="name" value="toSplitDat"/>
                                                        <att name="_kind" value="19"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid));&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="178" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(13);&#10;"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="179">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="180_0" source="180" target="181"/>
                                                    <edge id="181_0" source="181" target="182"/>
                                                    <edge id="182_0" source="182" target="183"/>
                                                    <edge id="183_0" source="183" target="184"/>
                                                    <node id="180" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(262,5)"/>
                                                        <att name="name" value="toSplitDat"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(13);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="181" label="Local Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,20)"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, treeid, nodeid, number, value, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="182" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,20)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, number, value, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid, number, value"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="183" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,5)"/>
                                                        <att name="name" value="featureVals"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 value := value, boolean rmval := false }, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="184" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(14);&#10;"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="185">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="187_0" source="187" target="188"/>
                                                    <edge id="188_0" source="188" target="189"/>
                                                    <edge id="190_0" source="190" target="191"/>
                                                    <edge id="191_0" source="191" target="192"/>
                                                    <edge id="192_0" source="192" target="193"/>
                                                    <edge id="193_0" source="193" target="194"/>
                                                    <edge id="189_0"
                                                          label="LEFT"
                                                          source="189"
                                                          target="195"/>
                                                    <edge id="194_0"
                                                          label="RIGHT"
                                                          source="194"
                                                          target="195">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="195_0" source="195" target="196"/>
                                                    <edge id="186_0"
                                                          label="LEFT"
                                                          source="186"
                                                          target="197"/>
                                                    <edge id="196_0"
                                                          label="RIGHT"
                                                          source="196"
                                                          target="197">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="197_0" source="197" target="198"/>
                                                    <edge id="193_1" source="193" target="199">
                                                        <att name="_sourceIndex" value="1"/>
                                                    </edge>
                                                    <node id="186" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(262,5)"/>
                                                        <att name="name" value="toSplitDat"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(13);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="187" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,5)"/>
                                                        <att name="name" value="featureVals"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(14);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="188" label="Local Iterate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(106,5)"/>
                                                        <att name="name" value="splitPoints1"/>
                                                        <att name="_kind" value="9"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="ITERATE(TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="189" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(107,5)"/>
                                                        <att name="name" value="splitPoints"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(NOT rmval);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="190" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(73,5)"/>
                                                        <att name="name" value="featureVals"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(14);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, value"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="191" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(79,17)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, number, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid, number"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="metaGroupSortOrder" value="value"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="192" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(79,5)"/>
                                                        <att name="name" value="features"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, boolean isordinal := true, integer8 vals := COUNT(group) }, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="193" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(79,17)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="features;&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="194" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(88,5)"/>
                                                        <att name="name" value="goodFeatures"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(vals &gt; 1);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="195" label="Lightweight Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(115,5)"/>
                                                        <att name="name" value="splitInfo0"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="196" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(123,5)"/>
                                                        <att name="name" value="splitInfo"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(NOT rmval);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="197" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(126,5)"/>
                                                        <att name="name" value="allSplitDat"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND RIGHT.nodeid = LEFT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  boolean isleft;&#10;  unsigned2 wi;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="198" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(16);&#10;"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                    <node id="199" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(15);&#10;"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="200">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="201_0" source="201" target="202"/>
                                                    <edge id="202_0" source="202" target="203"/>
                                                    <edge id="203_0" source="203" target="204"/>
                                                    <edge id="204_0" source="204" target="205"/>
                                                    <node id="201" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(126,5)"/>
                                                        <att name="name" value="allSplitDat"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(16);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="202" label="Local Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,21)"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, treeid, nodeid, number, splitval, isleft, depend, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft, depend"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="203" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,21)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, number, splitval, isleft, depend, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid, number, splitval, isleft, depend"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft, depend"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="204" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,5)"/>
                                                        <att name="name" value="dependGroups"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, boolean isleft := isleft, unsigned8 cnt := COUNT(group), real8 weightsum := SUM(group, observweight) }, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="205" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(17);&#10;"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="206">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="208_0" source="208" target="209"/>
                                                    <edge id="209_0" source="209" target="210"/>
                                                    <edge id="207_0"
                                                          label="LEFT"
                                                          source="207"
                                                          target="211"/>
                                                    <edge id="210_0"
                                                          label="RIGHT"
                                                          source="210"
                                                          target="211">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="211_0" source="211" target="212"/>
                                                    <edge id="212_0" source="212" target="213"/>
                                                    <edge id="213_0" source="213" target="214"/>
                                                    <edge id="214_0" source="214" target="215"/>
                                                    <edge id="215_0" source="215" target="216"/>
                                                    <edge id="216_0" source="216" target="217"/>
                                                    <edge id="217_0" source="217" target="218"/>
                                                    <edge id="218_0" source="218" target="219"/>
                                                    <edge id="219_0" source="219" target="220"/>
                                                    <edge id="221_0" source="221" target="222"/>
                                                    <edge id="220_0"
                                                          label="LEFT"
                                                          source="220"
                                                          target="223"/>
                                                    <edge id="222_0"
                                                          label="RIGHT"
                                                          source="222"
                                                          target="223">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="224_0" source="224" target="225"/>
                                                    <edge id="225_0" source="225" target="226"/>
                                                    <edge id="223_0"
                                                          label="LEFT"
                                                          source="223"
                                                          target="227"/>
                                                    <edge id="226_0"
                                                          label="RIGHT"
                                                          source="226"
                                                          target="227">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="227_0" source="227" target="228"/>
                                                    <node id="207" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,5)"/>
                                                        <att name="name" value="dependGroups"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(17);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="208" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(135,5)"/>
                                                        <att name="name" value="dependGroups"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(17);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="209" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(140,22)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, number, splitval, isleft, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="metaGroupSortOrder" value="depend"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="210" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(140,5)"/>
                                                        <att name="name" value="dependSummary"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, boolean isleft := isleft, real8 totweights := SUM(group, weightsum) }, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="211" label="Lightweight Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(144,5)"/>
                                                        <att name="name" value="dependRatios"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="212" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(153,21)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, number, splitval, isleft, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval, isleft"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="213" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(153,5)"/>
                                                        <att name="name" value="lr_entropies"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, unsigned8 tot := SUM(group, cnt), real8 entropy := SUM(group, plogp) }, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval"/>
                                                        <att name="recordSize" value="42"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="214" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(158,19)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, number, splitval, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid, number, splitval"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval"/>
                                                        <att name="recordSize" value="42"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="215" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(158,19)"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, boolean isordinal := true, real8 _agg_6 := SUM(group, entropy * tot), unsigned8 _agg_7 := SUM(group, tot) }, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval"/>
                                                        <att name="recordSize" value="43"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="216" label="Project">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(158,5)"/>
                                                        <att name="name" value="entropies0"/>
                                                        <att name="_kind" value="7"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="NEWTABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned4 number := number, real8 splitval := splitval, boolean isordinal := isordinal, real8 totentropy := (_agg_6 / _agg_7) });&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number, splitval"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="217" label="Local Group">
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="number, splitval"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="218" label="Grouped Sort">
                                                        <att name="_kind" value="3"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(totentropy);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="totentropy"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="219" label="Degroup">
                                                        <att name="_kind" value="14"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP();&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, totentropy"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="220" label="Local Dedup">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(165,5)"/>
                                                        <att name="name" value="lowestEntropies"/>
                                                        <att name="_kind" value="4"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, totentropy"/>
                                                        <att name="recordSize" value="35"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="221" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(231,16)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(6);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="222" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(266,5)"/>
                                                        <att name="name" value="parentNodeImp"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(impurity &gt;= 1e-07 AND &lt;...&gt;.&lt;unnamed&gt; &lt; 100);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="223" label="Lightweight Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(173,5)"/>
                                                        <att name="name" value="ig"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned4 number;&#10;... END,...), right outer, local);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="224" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(79,17)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(15);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="225" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(86,5)"/>
                                                        <att name="name" value="constantFeatures"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(vals = 1);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="226" label="Local Dedup">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(87,5)"/>
                                                        <att name="name" value="dummySplits"/>
                                                        <att name="_kind" value="4"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, number"/>
                                                        <att name="recordSize" value="27"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="227" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(192,5)"/>
                                                        <att name="name" value="bestSplits"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD(RECORD&#10;   unsigned2 wi;&#10;   unsigned4 treeid;&#10;   unsigned8 nodeid;&#10;   unsigned8 parentid;&#10;...  END)&#10;... END,...), left outer, local);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="228" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(18);&#10;"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="229">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="231_0" source="231" target="232"/>
                                                    <edge id="232_0" source="232" target="233"/>
                                                    <edge id="230_0"
                                                          label="LEFT"
                                                          source="230"
                                                          target="234"/>
                                                    <edge id="233_0"
                                                          label="RIGHT"
                                                          source="233"
                                                          target="234">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="234_0" source="234" target="235"/>
                                                    <edge id="233_1" source="233" target="236">
                                                        <att name="_sourceIndex" value="1"/>
                                                    </edge>
                                                    <node id="230" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(262,5)"/>
                                                        <att name="name" value="toSplitDat"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(13);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="231" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(192,5)"/>
                                                        <att name="name" value="bestSplits"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(18);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="232" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(272,5)"/>
                                                        <att name="name" value="goodSplits"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(number != 0);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="233" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(272,19)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="goodSplits;&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="234" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(278,5)"/>
                                                        <att name="name" value="goodSplitDat"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned2 wi;&#10;  unsigned8 id;&#10;  unsigned4 number;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="235" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(20);&#10;"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                    <node id="236" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(19);&#10;"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="237">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="238_0"
                                                          label="LEFT"
                                                          source="238"
                                                          target="240"/>
                                                    <edge id="239_0"
                                                          label="RIGHT"
                                                          source="239"
                                                          target="240">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="240_0" source="240" target="241"/>
                                                    <node id="238" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(272,19)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(19);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="239" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(278,5)"/>
                                                        <att name="name" value="goodSplitDat"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(20);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="240" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(284,5)"/>
                                                        <att name="name" value="leftIds"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 id;&#10; END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="241" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(21);&#10;"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="242">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="243_0"
                                                          label="LEFT"
                                                          source="243"
                                                          target="245"/>
                                                    <edge id="244_0"
                                                          label="RIGHT"
                                                          source="244"
                                                          target="245">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="245_0" source="245" target="246"/>
                                                    <edge id="246_0" source="246" target="247"/>
                                                    <edge id="247_0" source="247" target="248"/>
                                                    <edge id="246_1" source="246" target="249">
                                                        <att name="_sourceIndex" value="1"/>
                                                    </edge>
                                                    <node id="243" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(278,5)"/>
                                                        <att name="name" value="goodSplitDat"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(20);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="70"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="244" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(284,5)"/>
                                                        <att name="name" value="leftIds"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(21);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="245" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,5)"/>
                                                        <att name="name" value="LR_nextLevel"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid AND ..., TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), left outer, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="246" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,21)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="LR_nextLevel;&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="247" label="Aggregate">
                                                        <att name="_kind" value="10"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned8 nodeid := MAX(group, nodeid) });&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="8"/>
                                                        <att name="predictedCount" value="1"/>
                                                    </node>
                                                    <node id="248" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(4);&#10;"/>
                                                        <att name="recordSize" value="8"/>
                                                        <att name="_isSpill" value="1"/>
                                                        <att name="_fromChild" value="1"/>
                                                    </node>
                                                    <node id="249" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(22);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="250">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="251_0" source="251" target="252"/>
                                                    <edge id="252_0" source="252" target="253"/>
                                                    <edge id="253_0" source="253" target="254"/>
                                                    <edge id="254_0" source="254" target="255"/>
                                                    <edge id="255_0" source="255" target="256"/>
                                                    <edge id="256_0" source="256" target="257"/>
                                                    <edge id="257_0" source="257" target="258"/>
                                                    <node id="251" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,21)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(22);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="252" label="Local Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(316,21)"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="253" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(316,21)"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="254" label="Grouped Aggregate">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(316,5)"/>
                                                        <att name="name" value="nextLevelIds"/>
                                                        <att name="_kind" value="10"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ unsigned2 wi := wi, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid }, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="255" label="Local Group">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(317,5)"/>
                                                        <att name="name" value="nextLevelIdsG"/>
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid"/>
                                                        <att name="metaGroupSortOrder" value="nodeid"/>
                                                        <att name="recordSize" value="14"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="256" label="Grouped Count Project">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(318,5)"/>
                                                        <att name="name" value="newIdsG"/>
                                                        <att name="_kind" value="31"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 newid;&#10; END,...));&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaGrouping" value="wi, treeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid"/>
                                                        <att name="metaGroupSortOrder" value="nodeid"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="257" label="Degroup">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(319,5)"/>
                                                        <att name="name" value="newIds"/>
                                                        <att name="_kind" value="14"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP();&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="258" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(23);&#10;"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="259">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="260_0"
                                                          label="LEFT"
                                                          source="260"
                                                          target="262"/>
                                                    <edge id="261_0"
                                                          label="RIGHT"
                                                          source="261"
                                                          target="262">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="262_0" source="262" target="263"/>
                                                    <node id="260" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,21)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(22);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="261" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(319,5)"/>
                                                        <att name="name" value="newIds"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(23);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="22"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="262" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(320,22)"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="263" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(24);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="264">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="265_0" source="265" target="266"/>
                                                    <edge id="266_0" source="266" target="267"/>
                                                    <node id="265" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(320,22)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(24);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="266" label="Local Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(320,5)"/>
                                                        <att name="name" value="fixupIds"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="267" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(25);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="268">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <edge id="270_0" source="270" target="271"/>
                                                    <edge id="269_0"
                                                          label="LEFT"
                                                          source="269"
                                                          target="272"/>
                                                    <edge id="271_0"
                                                          label="RIGHT"
                                                          source="271"
                                                          target="272">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="272_0" source="272" target="273"/>
                                                    <node id="269" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(5);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="recordSize" value="47"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="270" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(192,5)"/>
                                                        <att name="name" value="bestSplits"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(18);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="271" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(274,5)"/>
                                                        <att name="name" value="badSplits"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(number = 0);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="272" label="Local Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(342,5)"/>
                                                        <att name="name" value="mixedLeafs0"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="273" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_internal" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(26);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="_isSpill" value="1"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                        <node id="274">
                                            <att name="_kind" value="1">
                                                <graph child="1">
                                                    <att name="rootGraph" value="1"/>
                                                    <edge id="275_0"
                                                          label="LEFT"
                                                          source="275"
                                                          target="277"/>
                                                    <edge id="276_0"
                                                          label="RIGHT"
                                                          source="276"
                                                          target="277">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="277_0" source="277" target="278"/>
                                                    <edge id="278_0" source="278" target="279"/>
                                                    <edge id="279_0" source="279" target="280"/>
                                                    <edge id="280_0" source="280" target="281"/>
                                                    <edge id="281_0" source="281" target="282"/>
                                                    <edge id="282_0"
                                                          label="True"
                                                          source="282"
                                                          target="283"/>
                                                    <edge id="278_1"
                                                          label="False"
                                                          source="278"
                                                          target="283">
                                                        <att name="_sourceIndex" value="1"/>
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="284_0" source="284" target="285"/>
                                                    <edge id="285_0" source="285" target="286"/>
                                                    <edge id="287_0" source="287" target="288"/>
                                                    <edge id="289_0"
                                                          label="True"
                                                          source="289"
                                                          target="291"/>
                                                    <edge id="290_0"
                                                          label="False"
                                                          source="290"
                                                          target="291">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="283_0" source="283" target="292"/>
                                                    <edge id="286_0" source="286" target="292">
                                                        <att name="_targetIndex" value="1"/>
                                                    </edge>
                                                    <edge id="288_0" source="288" target="292">
                                                        <att name="_targetIndex" value="2"/>
                                                    </edge>
                                                    <edge id="291_0" source="291" target="292">
                                                        <att name="_targetIndex" value="3"/>
                                                    </edge>
                                                    <edge id="292_0" source="292" target="293"/>
                                                    <edge id="293_0" source="293" target="294"/>
                                                    <edge id="294_0" source="294" target="295"/>
                                                    <edge id="295_0" source="295" target="296"/>
                                                    <edge id="296_0" source="296" target="297"/>
                                                    <edge id="293_1" source="293" target="298">
                                                        <att name="_sourceIndex" value="1"/>
                                                    </edge>
                                                    <node id="275" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(209,22)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(5);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="recordSize" value="47"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="276" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(238,24)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(7);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, parentid, isleft"/>
                                                        <att name="recordSize" value="39"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="277" label="Lightweight Join">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(354,5)"/>
                                                        <att name="name" value="pureNodes0"/>
                                                        <att name="_kind" value="155"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi AND LEFT.treeid = RIGHT.treeid AND LEFT.nodeid = RIGHT.nodeid, TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...), local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="278" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(354,19)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="pureNodes0;&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, depend, parentid, isleft"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="279" label="Local Group">
                                                        <att name="_kind" value="15"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="depend, parentid, isleft"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="280" label="Grouped Sort">
                                                        <att name="_kind" value="3"/>
                                                        <att name="grouped" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(-support);&#10;"/>
                                                        <att name="metaGrouping" value="wi, treeid, nodeid"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="metaGroupSortOrder" value="-support"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="281" label="Degroup">
                                                        <att name="_kind" value="14"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GROUP();&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, -support"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="282" label="Local Dedup">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(364,5)"/>
                                                        <att name="name" value="pureNodes2"/>
                                                        <att name="_kind" value="4"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, -support"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="283" label="If">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(365,5)"/>
                                                        <att name="name" value="pureNodes"/>
                                                        <att name="_kind" value="66"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="IF(&lt;...&gt;.&lt;unnamed&gt; = 100, pureNodes2, ...);&#10;"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="284" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(342,5)"/>
                                                        <att name="name" value="mixedLeafs0"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(26);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="285" label="Local Sort">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(348,5)"/>
                                                        <att name="name" value="mixedLeafs1"/>
                                                        <att name="_kind" value="3"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SORT(wi, treeid, nodeid, -support, local);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, -support"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="286" label="Local Dedup">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(349,5)"/>
                                                        <att name="name" value="mixedLeafs"/>
                                                        <att name="_kind" value="4"/>
                                                        <att name="local" value="1"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="DEDUP(wi, treeid, nodeid, local);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid, -support"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="287" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(272,19)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(19);&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="52"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="288" label="Project">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(329,5)"/>
                                                        <att name="name" value="splitNodes"/>
                                                        <att name="_kind" value="7"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...));&#10;"/>
                                                        <att name="metaDistribution" value="unknown"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="289" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(320,5)"/>
                                                        <att name="name" value="fixupIds"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(25);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="metaLocalSortOrder" value="wi, treeid, nodeid"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="290" label="Read Local Result">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(303,21)"/>
                                                        <att name="_kind" value="93"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="GetGraphResult(22);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                        <att name="_graphId" value="117"/>
                                                    </node>
                                                    <node id="291" label="If">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(326,5)"/>
                                                        <att name="name" value="nextLevelDat"/>
                                                        <att name="_kind" value="66"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="IF(maxNodeId &gt;= 281474976710656.0, fixupIds, LR_nextLevel);&#10;"/>
                                                        <att name="metaDistribution" value="HASH32(wi, treeid)"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="292" label="Funnel">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(203,3)"/>
                                                        <att name="name" value="GrowForestLevel"/>
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(369,12)"/>
                                                        <att name="_kind" value="17"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ordered" value="0"/>
                                                        <att name="ecl" value="leafNodes  +  splitNodes  +  nextLevelDat;&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="293" label="Split">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(369,12)"/>
                                                        <att name="_kind" value="6"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="_versions.LearningTrees.V1_1_1.LearningTrees.internal.RF_Classification.GrowForestLevel(ROWS, COUNTER);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="294" label="Filter">
                                                        <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(364,52)"/>
                                                        <att name="_kind" value="5"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="FILTER(id &gt; 0, &lt;...&gt;.&lt;unnamed&gt;  +  1 &lt;= 100);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                        <att name="predictedCount" value="0..?[disk]"/>
                                                    </node>
                                                    <node id="295" label="Exists">
                                                        <att name="_kind" value="124"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="TABLE({ boolean value := EXISTS(group) });&#10;"/>
                                                        <att name="recordSize" value="1"/>
                                                        <att name="predictedCount" value="1"/>
                                                    </node>
                                                    <node id="296" label="Project">
                                                        <att name="_kind" value="7"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="NEWTABLE({ boolean &lt;unnamed&gt; := value });&#10;"/>
                                                        <att name="recordSize" value="1"/>
                                                        <att name="predictedCount" value="1"/>
                                                    </node>
                                                    <node id="297" label="Local Result">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(3);&#10;"/>
                                                        <att name="recordSize" value="1"/>
                                                    </node>
                                                    <node id="298" label="End Loop">
                                                        <att name="_kind" value="94"/>
                                                        <att name="_parentActivity" value="116"/>
                                                        <att name="ecl" value="SetGraphResult(0);&#10;"/>
                                                        <att name="recordSize" value="82"/>
                                                    </node>
                                                </graph>
                                            </att>
                                            <att name="_parentActivity" value="116"/>
                                        </node>
                                    </graph>
                                </att>
                                <att name="_parentActivity" value="116"/>
                            </node>
                            <node id="299" label="Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(360,3)"/>
                                <att name="name" value="GrowForest"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(365,12)"/>
                                <att name="_kind" value="3"/>
                                <att name="ecl" value="SORT(wi, treeid, level, nodeid);&#10;"/>
                                <att name="metaDistribution" value="sorted(wi, treeid, level, nodeid)"/>
                                <att name="metaGlobalSortOrder" value="wi, treeid, level, nodeid"/>
                                <att name="metaLocalSortOrder" value="wi, treeid, level, nodeid"/>
                                <att name="recordSize" value="82"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="300" label="Count Project">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(573,5)"/>
                                <att name="name" value="nodesExt"/>
                                <att name="_kind" value="31"/>
                                <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...));&#10;"/>
                                <att name="metaDistribution" value="sorted(wi, treeid, level, nodeid)"/>
                                <att name="metaGlobalSortOrder" value="wi, treeid, level, nodeid"/>
                                <att name="metaLocalSortOrder" value="wi, treeid, level, nodeid"/>
                                <att name="recordSize" value="70"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="301" label="Normalize">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(240,15)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(575,5)"/>
                                <att name="name" value="nfMod"/>
                                <att name="_kind" value="21"/>
                                <att name="ecl" value="NORMALIZE(11, nf_to_mod(LEFT));&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaGlobalSortOrder" value="wi"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="302" label="Projected&#10;Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(240,15)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(585,5)"/>
                                <att name="name" value="nfIndexes"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::9&apos;, { unsigned4 treeid, unsigned8 id, unsigned8 origid }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(230,28)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(222,3)"/>
                                <att name="name" value="treeSampleIndxSampled"/>
                                <att name="_fileName" value="~spill::9"/>
                                <att name="_isTransformSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="303" label="Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(472,23)"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(55,5)"/>
                                <att name="name" value="classWeights"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::E&apos;, { unsigned2 wi, real8 value, set of unsigned4 indexes }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="_fileName" value="~spill::E"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="304" label="Funnel">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(475,5)"/>
                                <att name="name" value="mod"/>
                                <att name="_kind" value="17"/>
                                <att name="ordered" value="0"/>
                                <att name="ecl" value="baseMod  +  classWeights;&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="305" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(475,12)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="mod;&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="306" label="Output&#10;&apos;Model&apos;">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(93,1)"/>
                                <att name="_kind" value="16"/>
                                <att name="ecl" value="OUTPUT(..., , named(&apos;Model&apos;), workunit);&#10;"/>
                                <att name="recordSize" value="15..?(271)"/>
                            </node>
                            <node id="307" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::F&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="_fileName" value="~spill::F"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="308">
                    <att>
                        <graph>
                            <att name="rootGraph" value="1"/>
                            <edge id="309_0" source="309" target="310"/>
                            <edge id="310_0" source="310" target="311"/>
                            <edge id="311_0" source="311" target="312"/>
                            <edge id="312_0" source="312" target="313"/>
                            <edge id="313_0" source="313" target="314"/>
                            <edge id="314_0" source="314" target="315"/>
                            <edge id="315_0" source="315" target="316"/>
                            <edge id="316_0" source="316" target="317"/>
                            <edge id="317_0" source="317" target="318"/>
                            <edge id="318_0" source="318" target="319"/>
                            <edge id="316_1" source="316" target="320">
                                <att name="_sourceIndex" value="1"/>
                            </edge>
                            <edge id="320_0" source="320" target="321"/>
                            <node id="309" label="Filtered&#10;Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(213,24)"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::F&apos;, { unsigned2 wi, real8 value, set of unsigned4 indexes }, THOR, __compressed__);&#10;FILTER(filter);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl(475,5)"/>
                                <att name="name" value="mod"/>
                                <att name="_fileName" value="~spill::F"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="310" label="Assert">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(213,5)"/>
                                <att name="name" value="outCells"/>
                                <att name="_kind" value="5"/>
                                <att name="ecl" value="ASSERT(COUNT(indexes) = 3, &apos;ModelOps2.ToNumericField: Extracted indexes must be exactly 2 dimensional.  Fou...&apos; + ..., fail);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="15..?(271)"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="311" label="Project">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl(215,5)"/>
                                <att name="name" value="outMod"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(mod_to_nf(LEFT));&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="22"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="312" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(519,5)"/>
                                <att name="name" value="nfNodesD"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, id));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="recordSize" value="22"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="313" label="Local Group">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(520,5)"/>
                                <att name="name" value="nfNodesG"/>
                                <att name="_kind" value="15"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="GROUP(wi, id, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaGrouping" value="wi, id"/>
                                <att name="recordSize" value="22"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="314" label="Grouped Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(521,5)"/>
                                <att name="name" value="nfNodesS"/>
                                <att name="_kind" value="3"/>
                                <att name="grouped" value="1"/>
                                <att name="ecl" value="SORT(wi, id, number);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, id)"/>
                                <att name="metaGrouping" value="wi, id"/>
                                <att name="metaGroupSortOrder" value="wi, id, number"/>
                                <att name="recordSize" value="22"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="315" label="Rollup Group">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(538,5)"/>
                                <att name="name" value="nodes"/>
                                <att name="_kind" value="97"/>
                                <att name="grouped" value="1"/>
                                <att name="ecl" value="ROLLUP(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned8 nodeid;&#10;  unsigned8 parentid;&#10;  boolean isleft;&#10;... END,...));&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="54"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="316" label="Split">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(538,14)"/>
                                <att name="_kind" value="6"/>
                                <att name="ecl" value="nodes;&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="54"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="317" label="Sort">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(97,1)"/>
                                <att name="name" value="tn"/>
                                <att name="_kind" value="3"/>
                                <att name="ecl" value="SORT(wi, treeid, level, nodeid, number, depend);&#10;"/>
                                <att name="metaDistribution" value="sorted(wi, treeid, level, nodeid, number, depend)"/>
                                <att name="metaGlobalSortOrder" value="wi, treeid, level, nodeid, number, depend"/>
                                <att name="metaLocalSortOrder" value="wi, treeid, level, nodeid, number, depend"/>
                                <att name="recordSize" value="54"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="318" label="Project">
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="NEWTABLE({ unsigned2 wi := wi, unsigned2 level := level, unsigned4 treeid := treeid, unsigned8 nodeid := nodeid, unsigned8 parentid := parentid, boolean isleft := isleft, unsigned8 id := 0, unsigned4 number := number, real8 value := value, real8 depend := depend, unsigned8 support := support, boolean isordinal := isordinal });&#10;"/>
                                <att name="metaDistribution" value="sorted(wi, treeid, level, nodeid, number, depend)"/>
                                <att name="metaGlobalSortOrder" value="wi, treeid, level, nodeid, number, depend"/>
                                <att name="metaLocalSortOrder" value="wi, treeid, level, nodeid, number, depend"/>
                                <att name="recordSize" value="62"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="319" label="Output&#10;&apos;Tree&apos;">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(98,1)"/>
                                <att name="_kind" value="16"/>
                                <att name="ecl" value="OUTPUT(..., , named(&apos;Tree&apos;), workunit);&#10;"/>
                                <att name="recordSize" value="62"/>
                            </node>
                            <node id="320" label="Project">
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="PROJECT(TRANSFORM(RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10;  unsigned2 level;&#10;... END,...));&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="20"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="321" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::G&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="20"/>
                                <att name="_fileName" value="~spill::G"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="322">
                    <att>
                        <graph>
                            <edge id="323_0" source="323" target="324"/>
                            <edge id="324_0" source="324" target="325"/>
                            <edge id="325_0" source="325" target="326"/>
                            <edge id="326_0" source="326" target="327"/>
                            <edge id="327_0" source="327" target="328"/>
                            <node id="323" label="Projected&#10;Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(538,5)"/>
                                <att name="name" value="nodes"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::G&apos;, RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10;  unsigned2 level;&#10;... END, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="_fileName" value="~spill::G"/>
                                <att name="_isSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="324" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(637,18)"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid, internal));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="325" label="Local Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(637,18)"/>
                                <att name="_kind" value="3"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="SORT(wi, treeid, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                <att name="metaLocalSortOrder" value="wi, treeid"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="326" label="Local Group">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(637,18)"/>
                                <att name="_kind" value="15"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="GROUP(wi, treeid, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                <att name="metaGrouping" value="wi, treeid"/>
                                <att name="metaLocalSortOrder" value="wi, treeid"/>
                                <att name="recordSize" value="8"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="327" label="Grouped Aggregate">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(637,5)"/>
                                <att name="name" value="treeStats"/>
                                <att name="_kind" value="10"/>
                                <att name="grouped" value="1"/>
                                <att name="ecl" value="TABLE({ unsigned2 wi := wi, integer8 nodecount := COUNT(group), unsigned2 depth := MAX(group, level) });&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="12"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="328" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::H&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="12"/>
                                <att name="_fileName" value="~spill::H"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="329">
                    <att>
                        <graph>
                            <edge id="330_0" source="330" target="331"/>
                            <edge id="331_0" source="331" target="332"/>
                            <edge id="332_0" source="332" target="333"/>
                            <edge id="333_0" source="333" target="334"/>
                            <edge id="334_0" source="334" target="335"/>
                            <node id="330" label="Filtered&#10;Projected&#10;Spill Read">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,24)"/>
                                <att name="_kind" value="195"/>
                                <att name="ecl" value="DATASET(&apos;~spill::G&apos;, RECORD&#10;  unsigned4 treeid;&#10;  unsigned2 wi;&#10;  unsigned4 number;&#10;  unsigned2 level;&#10;... END, THOR, __compressed__);&#10;FILTER(number = 0);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="16"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(538,5)"/>
                                <att name="name" value="nodes"/>
                                <att name="_fileName" value="~spill::G"/>
                                <att name="_isTransformSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="331" label="Hash Distribute">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,18)"/>
                                <att name="_kind" value="19"/>
                                <att name="ecl" value="DISTRIBUTE(HASH32(wi, treeid, internal));&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                <att name="recordSize" value="16"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="332" label="Local Sort">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,18)"/>
                                <att name="_kind" value="3"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="SORT(wi, treeid, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                <att name="metaLocalSortOrder" value="wi, treeid"/>
                                <att name="recordSize" value="16"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="333" label="Local Group">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,18)"/>
                                <att name="_kind" value="15"/>
                                <att name="local" value="1"/>
                                <att name="ecl" value="GROUP(wi, treeid, local);&#10;"/>
                                <att name="metaDistribution" value="HASH32(wi, treeid, internal)"/>
                                <att name="metaGrouping" value="wi, treeid"/>
                                <att name="metaLocalSortOrder" value="wi, treeid"/>
                                <att name="recordSize" value="16"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="334" label="Grouped Aggregate">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(639,18)"/>
                                <att name="_kind" value="10"/>
                                <att name="grouped" value="1"/>
                                <att name="ecl" value="TABLE({ unsigned2 wi := wi, integer8 nodecount := COUNT(group), integer8 _agg_3 := SUM(group, level), unsigned8 totsupt := SUM(group, support), unsigned8 maxsupt := MAX(group, support), unsigned2 mindepth := MIN(group, level) });&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="36"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="335" label="Spill Write">
                                <att name="_kind" value="196"/>
                                <att name="_internal" value="1"/>
                                <att name="ecl" value="OUTPUT(..., , &apos;~spill::I&apos;, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="metaLocalSortOrder" value="wi"/>
                                <att name="recordSize" value="36"/>
                                <att name="_fileName" value="~spill::I"/>
                                <att name="_isSpill" value="1"/>
                            </node>
                        </graph>
                    </att>
                </node>
                <node id="336">
                    <att>
                        <graph>
                            <att name="rootGraph" value="1"/>
                            <edge id="337_0" source="337" target="338"/>
                            <edge id="339_0" source="339" target="340"/>
                            <edge id="338_0"
                                  label="LEFT"
                                  source="338"
                                  target="341"/>
                            <edge id="340_0"
                                  label="RIGHT"
                                  source="340"
                                  target="341">
                                <att name="_targetIndex" value="1"/>
                            </edge>
                            <edge id="341_0" source="341" target="342"/>
                            <node id="337" label="Disk Grouped Aggregate&#10;Spill">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(643,17)"/>
                                <att name="_kind" value="75"/>
                                <att name="ecl" value="DATASET(&apos;~spill::H&apos;, { unsigned2 wi, integer8 nodecount, unsigned2 depth }, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="46"/>
                                <att name="predictedCount" value="0..?[few]"/>
                                <att name="_fileName" value="~spill::H"/>
                                <att name="_isTransformSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="338" label="Project">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(643,5)"/>
                                <att name="name" value="treeSumm"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="NEWTABLE({ unsigned2 wi := wi, integer8 treecount := treecount, unsigned2 mintreedepth := mintreedepth, unsigned2 maxtreedepth := maxtreedepth, real8 avgtreedepth := (_agg_4 / treecount), integer8 mintreenodes := mintreenodes, integer8 maxtreenodes := maxtreenodes, real8 avgtreenodes := (_agg_7 / treecount), integer8 totalnodes := _agg_7 });&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="54"/>
                                <att name="predictedCount" value="0..?[few]"/>
                            </node>
                            <node id="339" label="Disk Grouped Aggregate&#10;Spill">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(652,17)"/>
                                <att name="_kind" value="75"/>
                                <att name="ecl" value="DATASET(&apos;~spill::I&apos;, RECORD&#10;  unsigned2 wi;&#10;  integer8 nodecount;&#10;  integer8 _agg_3;&#10;  unsigned8 totsupt;&#10;... END, THOR, __compressed__);&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="60"/>
                                <att name="predictedCount" value="0..?[few]"/>
                                <att name="_fileName" value="~spill::I"/>
                                <att name="_isTransformSpill" value="1"/>
                                <att name="spillReason" value="Resource limit spill: Heavyweight (2&gt;1)"/>
                                <att name="signedBy" value="hpcc"/>
                            </node>
                            <node id="340" label="Project">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(652,5)"/>
                                <att name="name" value="leafSumm"/>
                                <att name="_kind" value="7"/>
                                <att name="ecl" value="NEWTABLE({ unsigned2 wi := wi, unsigned8 minsupport := minsupport, unsigned8 maxsupport := maxsupport, real8 avgsupport := (_agg_3 / _agg_4), real8 avgsupportperleaf := (_agg_3 / _agg_5), unsigned8 maxsupportperleaf := maxsupportperleaf, real8 avgleafdepth := (_agg_7 / _agg_4), unsigned2 minleafdepth := minleafdepth });&#10;"/>
                                <att name="metaDistribution" value="unknown"/>
                                <att name="recordSize" value="52"/>
                                <att name="predictedCount" value="0..?[few]"/>
                            </node>
                            <node id="341" label="Join">
                                <att name="definition" value="/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl(661,5)"/>
                                <att name="name" value="allStats"/>
                                <att name="_kind" value="155"/>
                                <att name="ecl" value="JOIN(LEFT.wi = RIGHT.wi, TRANSFORM(RECORD&#10;  unsigned2 wi;&#10;  unsigned8 treecount;&#10;  unsigned8 mintreedepth;&#10;  unsigned8 maxtreedepth;&#10;... END,...));&#10;"/>
                                <att name="recordSize" value="130"/>
                                <att name="predictedCount" value="0..?[disk]"/>
                            </node>
                            <node id="342" label="Output&#10;&apos;ModelStats&apos;">
                                <att name="definition" value="/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl(95,1)"/>
                                <att name="_kind" value="16"/>
                                <att name="ecl" value="OUTPUT(..., , named(&apos;ModelStats&apos;), workunit);&#10;"/>
                                <att name="recordSize" value="130"/>
                            </node>
                        </graph>
                    </att>
                </node>
            </graph>
        </xgmml>
    </Graph>
</Graphs>
<Process>
    <EclAgent>
        <myeclagent log="//10.0.0.209/var/log/HPCCSystems/myeclagent/eclagent.2021_06_29.log" pid="6199"/>
    </EclAgent>
</Process>
<Query fetchEntire="1" hasArchive="1" isArchive="1">
    <Associated>
        <File desc="Compiler log"
              filename="/var/lib/HPCCSystems/myeclccserver/W20210629-061748.eclcc.log"
              ip="10.0.0.209"
              type="log"/>
        <File crc="-1719638775"
              desc="Workunit DLL"
              filename="/var/lib/HPCCSystems/myeclccserver/libW20210629-061748.so"
              ip="10.0.0.209"
              type="dll"/>
    </Associated>
    <ShortText>IMPORT LearningTrees AS LT;
        IMPORT ML_Core.Types AS CTypes;
        IMPORT LT.LT_Types AS Types;

        NumericField := CTypes.NumericField;
        DiscreteField := CTypes.DiscreteField;
        errorProb := 0;
        wiCount := 1;
        numTrainingRecs := 1000;
        numTestRecs := 1000;
        numTrees := 20;
        numVarsPerTree := 0;

        // Return TRUE with probability p
        prob(REAL p) := FUNCTION
        rnd := RANDOM() % 1000000 + 1;
        isTrue := IF(rnd / 1000000 &lt;= p, TRUE, FALSE);
        RETURN isTrue;
        END;

        // Test Pattern -- Ordinal variable X1 determines OP(X2, X3) =&gt; Y
        //                 OP (OR, AND, XOR, NOR), is determined as follows:
        //                 X1 &lt; -50 =&gt; OR(X2, X3); -50 &lt;= X1 &lt; 0 =&gt; AND(X2, X3);
        //                 0 &lt; X1 &lt;= 50 =&gt; XOR(X2, X3); X1 &gt;= 50 =&gt; NOR(X2, X3);

        dsRec := {UNSIGNED id, REAL X1, UNSIGNED X2, UNSIGNED X3, UNSIGNED Y};
        dsRec0 := {UNSIGNED id, UNSIGNED X1, UNSIGNED X2, UNSIGNED X3, UNSIGNED Y};
        dummy := DATASET([{0, 0, 0, 0, 0}], dsRec);
        dsRec make_data0(dsRec d, UNSIGNED c) := TRANSFORM
        SELF.id := c;
        // Pick random X1:  -100 &lt; X1 &lt; 100
        r1 := __COMMON__(RANDOM());
        r2 := __COMMON__(RANDOM());
        r3 := __COMMON__(RANDOM());
        SELF.X1 := r1%4;
        // Pick random X2 and X3: Choose val between 0 and 1 and round to 0 or 1.
        SELF.X2 := ROUND(r2%1000000 / 1000000);
        BOOLEAN x2B := SELF.X2=1;
        SELF.X3 := ROUND(r3%1000000 / 1000000);
        BOOLEAN x3B := SELF.X3=1;
        BOOLEAN y := MAP(SELF.X1 = 0 =&gt; x2B OR x3B, // OR
        SELF.X1 = 1 =&gt; x2B AND x3B, // AND
        SELF.X1 = 2 =&gt; (x2B OR x3B) AND (NOT (x2B AND x3B)), // XOR
        (NOT (x2B OR x3B)));  // NOR
        SELF.Y := IF(y, 1, 0);
        END;
        dsRec make_data(dsRec d, UNSIGNED c) := TRANSFORM
        SELF.id := c;
        // Pick random X1:  -100 &lt; X1 &lt; 100
        r1 := __COMMON__(RANDOM());
        r2 := __COMMON__(RANDOM());
        r3 := __COMMON__(RANDOM());
        SELF.X1 := ROUND(r1%1000000 / 10000 * 2 - 100);
        // Pick random X2 and X3: Choose val between 0 and 1 and round to 0 or 1.
        SELF.X2 := ROUND(r2%1000000 / 1000000);
        BOOLEAN x2B := SELF.X2=1;
        SELF.X3 := ROUND(r3%1000000 / 1000000);
        BOOLEAN x3B := SELF.X3=1;
        BOOLEAN y := MAP(SELF.X1 &lt; -50 =&gt; x2B OR x3B, // OR
        SELF.X1 &gt;= -50 AND SELF.X1 &lt; 0 =&gt; x2B AND x3B, // AND
        SELF.X1 &gt;= 0 AND SELF.X1 &lt; 50 =&gt; (x2B OR x3B) AND (NOT (x2B AND x3B)), // XOR
        (NOT (x2B OR x3B)));  // NOR
        SELF.Y := IF(y, 1, 0);
        END;
        ds := NORMALIZE(dummy, numTrainingRecs, make_data(LEFT, COUNTER));
        OUTPUT(ds, NAMED(&apos;TrainingData&apos;));

        X1 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 1,
        SELF.value := LEFT.X1));
        X2 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 2,
        SELF.value := LEFT.X2));
        X3 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 3,
        SELF.value := LEFT.X3));
        // Add noise to Y by randomly flipping the value according to PROBABILITY(errorProb).
        Y := PROJECT(ds, TRANSFORM(DiscreteField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 1,
        SELF.value := IF(prob(errorProb), (LEFT.Y + 1)%2, LEFT.Y)));
        nominals := [];
        X := X1 + X2 + X3;

        // Expand to number of work items
        Xe := NORMALIZE(X, wiCount, TRANSFORM(NumericField, SELF.wi := COUNTER, SELF := LEFT));
        Ye := NORMALIZE(Y, wiCount, TRANSFORM(DiscreteField, SELF.wi := COUNTER, SELF := LEFT));

        OUTPUT(Ye, NAMED(&apos;Y_train&apos;));

        F := LT.ClassificationForest(numTrees, numVarsPerTree);

        mod := F.GetModel(Xe, Ye);

        // With this line it runs fine.
        //mod := F.GetModel(X, Y, nominals);

        OUTPUT(mod, NAMED(&apos;Model&apos;));
        modStats := F.GetModelStats(mod);
        OUTPUT(modStats, NAMED(&apos;ModelStats&apos;));
        tn0 := F.Model2Nodes(mod);
        tn := SORT(tn0, wi, treeId, level, nodeid, id, number, depend);
        OUTPUT(tn, {wi, level, treeId, nodeId, parentId, isLeft, id, number, value, depend, support, isOrdinal},NAMED(&apos;Tree&apos;));

        //IMPORT ML_Core;
        //IMPORT ML_Core.Types;
        //IMPORT ML_Core.ModelOps2 as ModelOps2;
        //IMPORT LearningTrees as LT;
        //
        //classifications := DATASET(
        //       [{1, 1, 1, 0}, {1, 1, 2, 1},
        //        {1, 2, 1, 0}, {1, 2, 2, 1},
        //        {1, 3, 1, 0}, {1, 3, 2, 1},
        //        {1, 4, 1, 0}, {1, 4, 2, 1},
        //        {1, 5, 1, 0}, {1, 5, 2, 1},
        //        {1, 6, 1, 0}, {1, 6, 2, 1},
        //        {1, 7, 1, 1}, {1, 7, 2, 0},
        //        {1, 8, 1, 1}, {1, 8, 2, 0},
        //        {1, 9, 1, 1}, {1, 9, 2, 0},
        //        {2, 1, 1, 0}, {2, 1, 2, 1}, {2, 1, 3, 0},
        //        {2, 2, 1, 0}, {2, 2, 2, 1}, {2, 2, 3, 0},
        //        {2, 3, 1, 0}, {2, 3, 2, 1}, {2, 3, 3, 0},
        //        {2, 4, 1, 0}, {2, 4, 2, 0}, {2, 4, 3, 1},
        //        {2, 5, 1, 0}, {2, 5, 2, 0}, {2, 5, 3, 1},
        //        {2, 6, 1, 0}, {2, 6, 2, 0}, {2, 6, 3, 1},
        //        {2, 7, 1, 1}, {2, 7, 2, 0}, {2, 7, 3, 0},
        //        {2, 8, 1, 1}, {2, 8, 2, 0}, {2, 8, 3, 0},
        //        {2, 9, 1, 1}, {2, 9, 2, 0}, {2, 9, 3, 0},
        //        {3, 1, 1, 0},
        //        {3, 2, 1, 0},
        //        {3, 3, 1, 0},
        //        {3, 4, 1, 0},
        //        {3, 5, 1, 0},
        //        {3, 6, 1, 0},
        //        {3, 7, 1, 1},
        //        {3, 8, 1, 1},
        //        {3, 9, 1, 1}], Types.DiscreteField);
        //observations := DATASET(
        //    [{1, 1, 1, .6}, {1, 1, 2, .7}, {1, 1, 3, .8},
        //     {1, 2, 1, .8}, {1, 2, 2, .7}, {1, 2, 3, .7},
        //     {1, 3, 1, .7}, {1, 3, 2, .8}, {1, 3, 3, .6},
        //     {1, 4, 1, .9}, {1, 4, 2, .7}, {1, 4, 3, .9},
        //     {1, 5, 1, .8}, {1, 5, 2, .9}, {1, 5, 3, .6},
        //     {1, 6, 1, .8}, {1, 6, 2, .5}, {1, 6, 3, .8},
        //     {1, 7, 1, .2}, {1, 7, 2,  0}, {1, 7, 3, .3},
        //     {1, 8, 1, .3}, {1, 8, 2, .4}, {1, 8, 3, .4},
        //     {1, 9, 1, .4}, {1, 9, 2, .7}, {1, 9, 3,  0},
        //     {2, 1, 1, .9}, {2, 1, 2, .7}, {2, 1, 3, .8},
        //     {2, 2, 1, .8}, {2, 2, 2, .7}, {2, 2, 3, .7},
        //     {2, 3, 1, .7}, {2, 3, 2, .8}, {2, 3, 3, .9},
        //     {2, 4, 1, .6}, {2, 4, 2, .5}, {2, 4, 3, .6},
        //     {2, 5, 1, .6}, {2, 5, 2, .6}, {2, 5, 3, .6},
        //     {2, 6, 1, .6}, {2, 6, 2, .5}, {2, 6, 3, .5},
        //     {2, 7, 1, .2}, {2, 7, 2, .1}, {2, 7, 3, .3},
        //     {2, 8, 1, .3}, {2, 8, 2, .4}, {2, 8, 3, .4},
        //     {2, 9, 1, .4}, {2, 9, 2, .7}, {2, 9, 3, .3},
        //     {3, 1, 1, .6}, {3, 1, 2, .7}, {3, 1, 3, .8},
        //     {3, 2, 1, .8}, {3, 2, 2, .7}, {3, 2, 3, .7},
        //     {3, 3, 1, .7}, {3, 3, 2, .8}, {3, 3, 3, .6},
        //     {3, 4, 1, .9}, {3, 4, 2, .7}, {3, 4, 3, .9},
        //     {3, 5, 1, .8}, {3, 5, 2, .9}, {3, 5, 3, .6},
        //     {3, 6, 1, .8}, {3, 6, 2, .5}, {3, 6, 3, .8},
        //     {3, 7, 1, .2}, {3, 7, 2, .1}, {3, 7, 3, .3},
        //     {3, 8, 1, .3}, {3, 8, 2, .4}, {3, 8, 3, .4},
        //     {3, 9, 1, .4}, {3, 9, 2, .7}, {3, 9, 3, .3}], Types.NumericField);
        //
        //testData := DATASET([
        //    {1, 1, 1, .2},
        //    {1, 1, 2, .87}], Types.NumericField);
        //
        //
        //CF := LT.ClassificationForest().GetModel(observations, classifications);
        //
        //OUTPUT(&apos;ClassificationForest&apos;);
        //OUTPUT(CF);
        //OUTPUT(LR.LogitPredict(betas, testData));

        //matrix := DATASET([{1, 1, 1, 5},
        //    {1, 1, 2, 1},
        //    {1, 1, 3, 4},
        //    {1, 1, 4, 1},
        //    {1, 1, 5, 2},
        //    {1, 1, 6, 4},
        //    {1, 1, 7, 8}], Types.NumericField);
        //OUTPUT(linearRegression.Predict(matrix, model));</ShortText>
    <Text>&lt;Archive build=&quot;community_8.0.14-1&quot;
        eclVersion=&quot;8.0.14&quot;
        legacyImport=&quot;0&quot;
        legacyWhen=&quot;0&quot;&gt;
        &lt;Query attributePath=&quot;ECLDir.tmp_exec&quot;/&gt;
        &lt;Module key=&quot;ecldir&quot; name=&quot;ECLDir&quot;&gt;
        &lt;Attribute key=&quot;tmp_exec&quot;
        name=&quot;tmp_exec&quot;
        sourcePath=&quot;/Users/alex/Documents/Work/pmml2ecl/pmml-ecl-ml/src/main/java/test/ECLDir/tmp_exec.ecl&quot;
        ts=&quot;1624947466000000&quot;&gt;
        IMPORT LearningTrees AS LT;
        IMPORT ML_Core.Types AS CTypes;
        IMPORT LT.LT_Types AS Types;

        NumericField := CTypes.NumericField;
        DiscreteField := CTypes.DiscreteField;
        errorProb := 0;
        wiCount := 1;
        numTrainingRecs := 1000;
        numTestRecs := 1000;
        numTrees := 20;
        numVarsPerTree := 0;

        // Return TRUE with probability p
        prob(REAL p) := FUNCTION
        rnd := RANDOM() % 1000000 + 1;
        isTrue := IF(rnd / 1000000 &amp;lt;= p, TRUE, FALSE);
        RETURN isTrue;
        END;

        // Test Pattern -- Ordinal variable X1 determines OP(X2, X3) =&amp;gt; Y
        //                 OP (OR, AND, XOR, NOR), is determined as follows:
        //                 X1 &amp;lt; -50 =&amp;gt; OR(X2, X3); -50 &amp;lt;= X1 &amp;lt; 0 =&amp;gt; AND(X2, X3);
        //                 0 &amp;lt; X1 &amp;lt;= 50 =&amp;gt; XOR(X2, X3); X1 &amp;gt;= 50 =&amp;gt; NOR(X2, X3);

        dsRec := {UNSIGNED id, REAL X1, UNSIGNED X2, UNSIGNED X3, UNSIGNED Y};
        dsRec0 := {UNSIGNED id, UNSIGNED X1, UNSIGNED X2, UNSIGNED X3, UNSIGNED Y};
        dummy := DATASET([{0, 0, 0, 0, 0}], dsRec);
        dsRec make_data0(dsRec d, UNSIGNED c) := TRANSFORM
        SELF.id := c;
        // Pick random X1:  -100 &amp;lt; X1 &amp;lt; 100
        r1 := __COMMON__(RANDOM());
        r2 := __COMMON__(RANDOM());
        r3 := __COMMON__(RANDOM());
        SELF.X1 := r1%4;
        // Pick random X2 and X3: Choose val between 0 and 1 and round to 0 or 1.
        SELF.X2 := ROUND(r2%1000000 / 1000000);
        BOOLEAN x2B := SELF.X2=1;
        SELF.X3 := ROUND(r3%1000000 / 1000000);
        BOOLEAN x3B := SELF.X3=1;
        BOOLEAN y := MAP(SELF.X1 = 0 =&amp;gt; x2B OR x3B, // OR
        SELF.X1 = 1 =&amp;gt; x2B AND x3B, // AND
        SELF.X1 = 2 =&amp;gt; (x2B OR x3B) AND (NOT (x2B AND x3B)), // XOR
        (NOT (x2B OR x3B)));  // NOR
        SELF.Y := IF(y, 1, 0);
        END;
        dsRec make_data(dsRec d, UNSIGNED c) := TRANSFORM
        SELF.id := c;
        // Pick random X1:  -100 &amp;lt; X1 &amp;lt; 100
        r1 := __COMMON__(RANDOM());
        r2 := __COMMON__(RANDOM());
        r3 := __COMMON__(RANDOM());
        SELF.X1 := ROUND(r1%1000000 / 10000 * 2 - 100);
        // Pick random X2 and X3: Choose val between 0 and 1 and round to 0 or 1.
        SELF.X2 := ROUND(r2%1000000 / 1000000);
        BOOLEAN x2B := SELF.X2=1;
        SELF.X3 := ROUND(r3%1000000 / 1000000);
        BOOLEAN x3B := SELF.X3=1;
        BOOLEAN y := MAP(SELF.X1 &amp;lt; -50 =&amp;gt; x2B OR x3B, // OR
        SELF.X1 &amp;gt;= -50 AND SELF.X1 &amp;lt; 0 =&amp;gt; x2B AND x3B, // AND
        SELF.X1 &amp;gt;= 0 AND SELF.X1 &amp;lt; 50 =&amp;gt; (x2B OR x3B) AND (NOT (x2B AND x3B)), // XOR
        (NOT (x2B OR x3B)));  // NOR
        SELF.Y := IF(y, 1, 0);
        END;
        ds := NORMALIZE(dummy, numTrainingRecs, make_data(LEFT, COUNTER));
        OUTPUT(ds, NAMED(&amp;apos;TrainingData&amp;apos;));

        X1 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 1,
        SELF.value := LEFT.X1));
        X2 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 2,
        SELF.value := LEFT.X2));
        X3 := PROJECT(ds, TRANSFORM(NumericField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 3,
        SELF.value := LEFT.X3));
        // Add noise to Y by randomly flipping the value according to PROBABILITY(errorProb).
        Y := PROJECT(ds, TRANSFORM(DiscreteField, SELF.wi := 1, SELF.id := LEFT.id, SELF.number := 1,
        SELF.value := IF(prob(errorProb), (LEFT.Y + 1)%2, LEFT.Y)));
        nominals := [];
        X := X1 + X2 + X3;

        // Expand to number of work items
        Xe := NORMALIZE(X, wiCount, TRANSFORM(NumericField, SELF.wi := COUNTER, SELF := LEFT));
        Ye := NORMALIZE(Y, wiCount, TRANSFORM(DiscreteField, SELF.wi := COUNTER, SELF := LEFT));

        OUTPUT(Ye, NAMED(&amp;apos;Y_train&amp;apos;));

        F := LT.ClassificationForest(numTrees, numVarsPerTree);

        mod := F.GetModel(Xe, Ye);

        // With this line it runs fine.
        //mod := F.GetModel(X, Y, nominals);

        OUTPUT(mod, NAMED(&amp;apos;Model&amp;apos;));
        modStats := F.GetModelStats(mod);
        OUTPUT(modStats, NAMED(&amp;apos;ModelStats&amp;apos;));
        tn0 := F.Model2Nodes(mod);
        tn := SORT(tn0, wi, treeId, level, nodeid, id, number, depend);
        OUTPUT(tn, {wi, level, treeId, nodeId, parentId, isLeft, id, number, value, depend, support, isOrdinal},NAMED(&amp;apos;Tree&amp;apos;));

        //IMPORT ML_Core;
        //IMPORT ML_Core.Types;
        //IMPORT ML_Core.ModelOps2 as ModelOps2;
        //IMPORT LearningTrees as LT;
        //
        //classifications := DATASET(
        //       [{1, 1, 1, 0}, {1, 1, 2, 1},
        //        {1, 2, 1, 0}, {1, 2, 2, 1},
        //        {1, 3, 1, 0}, {1, 3, 2, 1},
        //        {1, 4, 1, 0}, {1, 4, 2, 1},
        //        {1, 5, 1, 0}, {1, 5, 2, 1},
        //        {1, 6, 1, 0}, {1, 6, 2, 1},
        //        {1, 7, 1, 1}, {1, 7, 2, 0},
        //        {1, 8, 1, 1}, {1, 8, 2, 0},
        //        {1, 9, 1, 1}, {1, 9, 2, 0},
        //        {2, 1, 1, 0}, {2, 1, 2, 1}, {2, 1, 3, 0},
        //        {2, 2, 1, 0}, {2, 2, 2, 1}, {2, 2, 3, 0},
        //        {2, 3, 1, 0}, {2, 3, 2, 1}, {2, 3, 3, 0},
        //        {2, 4, 1, 0}, {2, 4, 2, 0}, {2, 4, 3, 1},
        //        {2, 5, 1, 0}, {2, 5, 2, 0}, {2, 5, 3, 1},
        //        {2, 6, 1, 0}, {2, 6, 2, 0}, {2, 6, 3, 1},
        //        {2, 7, 1, 1}, {2, 7, 2, 0}, {2, 7, 3, 0},
        //        {2, 8, 1, 1}, {2, 8, 2, 0}, {2, 8, 3, 0},
        //        {2, 9, 1, 1}, {2, 9, 2, 0}, {2, 9, 3, 0},
        //        {3, 1, 1, 0},
        //        {3, 2, 1, 0},
        //        {3, 3, 1, 0},
        //        {3, 4, 1, 0},
        //        {3, 5, 1, 0},
        //        {3, 6, 1, 0},
        //        {3, 7, 1, 1},
        //        {3, 8, 1, 1},
        //        {3, 9, 1, 1}], Types.DiscreteField);
        //observations := DATASET(
        //    [{1, 1, 1, .6}, {1, 1, 2, .7}, {1, 1, 3, .8},
        //     {1, 2, 1, .8}, {1, 2, 2, .7}, {1, 2, 3, .7},
        //     {1, 3, 1, .7}, {1, 3, 2, .8}, {1, 3, 3, .6},
        //     {1, 4, 1, .9}, {1, 4, 2, .7}, {1, 4, 3, .9},
        //     {1, 5, 1, .8}, {1, 5, 2, .9}, {1, 5, 3, .6},
        //     {1, 6, 1, .8}, {1, 6, 2, .5}, {1, 6, 3, .8},
        //     {1, 7, 1, .2}, {1, 7, 2,  0}, {1, 7, 3, .3},
        //     {1, 8, 1, .3}, {1, 8, 2, .4}, {1, 8, 3, .4},
        //     {1, 9, 1, .4}, {1, 9, 2, .7}, {1, 9, 3,  0},
        //     {2, 1, 1, .9}, {2, 1, 2, .7}, {2, 1, 3, .8},
        //     {2, 2, 1, .8}, {2, 2, 2, .7}, {2, 2, 3, .7},
        //     {2, 3, 1, .7}, {2, 3, 2, .8}, {2, 3, 3, .9},
        //     {2, 4, 1, .6}, {2, 4, 2, .5}, {2, 4, 3, .6},
        //     {2, 5, 1, .6}, {2, 5, 2, .6}, {2, 5, 3, .6},
        //     {2, 6, 1, .6}, {2, 6, 2, .5}, {2, 6, 3, .5},
        //     {2, 7, 1, .2}, {2, 7, 2, .1}, {2, 7, 3, .3},
        //     {2, 8, 1, .3}, {2, 8, 2, .4}, {2, 8, 3, .4},
        //     {2, 9, 1, .4}, {2, 9, 2, .7}, {2, 9, 3, .3},
        //     {3, 1, 1, .6}, {3, 1, 2, .7}, {3, 1, 3, .8},
        //     {3, 2, 1, .8}, {3, 2, 2, .7}, {3, 2, 3, .7},
        //     {3, 3, 1, .7}, {3, 3, 2, .8}, {3, 3, 3, .6},
        //     {3, 4, 1, .9}, {3, 4, 2, .7}, {3, 4, 3, .9},
        //     {3, 5, 1, .8}, {3, 5, 2, .9}, {3, 5, 3, .6},
        //     {3, 6, 1, .8}, {3, 6, 2, .5}, {3, 6, 3, .8},
        //     {3, 7, 1, .2}, {3, 7, 2, .1}, {3, 7, 3, .3},
        //     {3, 8, 1, .3}, {3, 8, 2, .4}, {3, 8, 3, .4},
        //     {3, 9, 1, .4}, {3, 9, 2, .7}, {3, 9, 3, .3}], Types.NumericField);
        //
        //testData := DATASET([
        //    {1, 1, 1, .2},
        //    {1, 1, 2, .87}], Types.NumericField);
        //
        //
        //CF := LT.ClassificationForest().GetModel(observations, classifications);
        //
        //OUTPUT(&amp;apos;ClassificationForest&amp;apos;);
        //OUTPUT(CF);
        //OUTPUT(LR.LogitPredict(betas, testData));

        //matrix := DATASET([{1, 1, 1, 5},
        //    {1, 1, 2, 1},
        //    {1, 1, 3, 4},
        //    {1, 1, 4, 1},
        //    {1, 1, 5, 2},
        //    {1, 1, 6, 4},
        //    {1, 1, 7, 8}], Types.NumericField);
        //OUTPUT(linearRegression.Predict(matrix, model));
        &lt;/Attribute&gt;
        &lt;/Module&gt;
        &lt;Module key=&quot;&quot; name=&quot;&quot;&gt;
        &lt;Attribute key=&quot;learningtrees&quot;
        name=&quot;LearningTrees&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/LearningTrees.ecl&quot;
        ts=&quot;1621960364000000&quot;&gt;
        IMPORT _versions.LearningTrees.V1_1_1.LearningTrees as _LearningTrees; EXPORT LearningTrees := _LearningTrees;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;ml_core&quot;
        name=&quot;ML_Core&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/ML_Core.ecl&quot;
        ts=&quot;1621960337000000&quot;&gt;
        IMPORT _versions.ML_Core.V3_2_2.ML_Core as _ML_Core; EXPORT ML_Core := _ML_Core;
        &lt;/Attribute&gt;
        &lt;/Module&gt;
        &lt;Module key=&quot;_versions&quot; name=&quot;_versions&quot;/&gt;
        &lt;Module key=&quot;_versions.learningtrees&quot; name=&quot;_versions.LearningTrees&quot;/&gt;
        &lt;Module key=&quot;_versions.learningtrees.v1_1_1&quot; name=&quot;_versions.LearningTrees.V1_1_1&quot;/&gt;
        &lt;Module key=&quot;_versions.learningtrees.v1_1_1.learningtrees&quot; name=&quot;_versions.LearningTrees.V1_1_1.LearningTrees&quot;&gt;
        &lt;Attribute key=&quot;lt_types&quot;
        name=&quot;LT_Types&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LT_Types.ecl&quot;
        ts=&quot;1621960363000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
        ############################################################################## */
        IMPORT $ AS LT;
        IMPORT ML_core;
        IMPORT ML_core.Types as CTypes;

        t_Work_Item := CTypes.t_Work_Item;
        t_Count := CTypes.t_Count;
        t_RecordId := CTypes.t_RecordID;
        t_FieldNumber := CTypes.t_FieldNumber;
        t_FieldReal := CTypes.t_FieldReal;
        t_Discrete := CTypes.t_Discrete;
        t_TreeId := t_FieldNumber;
        Layout_Model := CTypes.Layout_Model;
        DiscreteField := CTypes.DiscreteField;
        NumericField := CTypes.NumericField;
        Field_Mapping := CTypes.Field_Mapping;
        t_index := CTypes.t_index;

        /**
        * Type definition module for Learning Trees.
        */
        EXPORT LT_Types := MODULE
        /**
        * Type definition for the node id field representing a tree node&amp;apos;s id
        */
        EXPORT t_NodeId := UNSIGNED8;
        /**
        * Definition of the meaning of the indexes of the Forest Model variables.
        * &amp;lt;p&amp;gt;Ind1 enumerates the first index, which
        * is used to determine which type of data is stored:&amp;lt;ul&amp;gt;
        * &amp;lt;li&amp;gt;nodes stores the list of tree nodes that describes the forest.
        *         The second index is just the sequential number of the node
        *         The third index is enumerated below (see Ind3_nodes).&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;samples stores the set of sample indexes (i.e. ids) associated
        *         with each treeId.
        *         The second index represents the treeId.  The third index
        *         represents the sample number. The value is the id of the
        *         sample in the original training dataset.
        *         {samples, treeId, sampleNum} -&amp;gt; origId.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;classWeights (ClassificationForest only) stores the weights associated
        *         with each class label.  The second index represents the class
        *         label.  The value is the weight.  {classWeights, classLabel} -&amp;gt; weight.
        *         Class weights are only stored for Classification Forests.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
        */
        EXPORT Forest_Model := MODULE
        /**
        * Index 1 represents the category of data within the model
        *
        * @value reserved = 1.  Reserved for future use.
        * @value nodes = 2.  The set of tree nodes within the model.
        * @value samples = 3. The particular record ids that are included in tree&amp;apos;s sample .
        * @value classWeights = 4.  The weights assigned to each class (for ClassificationForest only).
        */
        EXPORT Ind1 := MODULE
        EXPORT t_index reserved := 1; // Reserved for future use
        EXPORT t_index nodes := 2;
        EXPORT t_index samples := 3;
        EXPORT t_index classWeights := 4;
        END;
        /**
        * For tree node data (i.e. Ind1 = nodes), the following
        * constant definitions are used for the different fields
        * of the tree-node.
        * Note that Ind1 indicates tree nodes, Ind2 represents the different nodes
        * and Ind3 defines the different fields.  For example, the treeId for the
        * first node would be stored at [2,1,1].  These correspond to the persisted
        * fields of TreeNodeDat with similar names.
        *
        * @value treeID = 1.  The tree identifier.
        * @value level = 2.  The level of the node within the tree.
        * @value nodeId = 3.  The nodeId of this node within the tree.
        * @value parentId = 4.  The parent node&amp;apos;s nodeId.
        * @value isLeft = 5.  Left / Right indicator of this node within it&amp;apos;s parent&amp;apos;s chilren.
        * @value number = 6.  The field number to split on.
        * @value value = 7.  The value to compare against.
        * @value isOrd = 8.  Indicator of ordered vs categorical data.
        * @value depend = 9.  The value to predict for samples in this leaf.
        * @value support = 10.  The number of datapoints from the training data that reached
        *                       this node.
        * @value if = 11.  The &amp;apos;impurity reduction&amp;apos; achieved by this branch.
        *
        */
        EXPORT Ind3_Nodes := MODULE
        EXPORT t_index treeId := 1;
        EXPORT t_index level := 2;
        EXPORT t_index nodeId := 3;
        EXPORT t_index parentId := 4;
        EXPORT t_index isLeft := 5;
        EXPORT t_index number := 6;
        EXPORT t_index value := 7;
        EXPORT t_index isOrd := 8;
        EXPORT t_index depend := 9;
        EXPORT t_index support := 10;
        EXPORT t_index ir := 11;
        END;
        END;

        /**
        * Definition of the meaning of the indexes of the Gradient Boosting Model variables.
        * &amp;lt;p&amp;gt;Ind1 enumerates the first index, which
        * is used to determine which type of data is stored:&amp;lt;ul&amp;gt;
        * &amp;lt;li&amp;gt;fModels stores the list of forest models that comprise the boosting
        *         hierarchy.  Each of these models can be decomposed by the Forest
        *         learning modules.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;Other values are reserved for future use.
        */
        EXPORT Bf_Model := MODULE
        /**
        * Index 1 represents the category of data within the model
        *
        * @value reserved = 1.  Reserved for future use.
        * @value fModels = 2.  The set of forest models that comprise the boosting
        *                       hierarchy.
        */
        EXPORT Ind1 := MODULE
        EXPORT t_index reserved := 1; // Reserved for future use
        EXPORT t_index fModels := 2;
        END;
        END;

        /**
        * GenField extends NumericField by adding an isOrdinal field.  This
        * allows both Ordered and Nominal (Categorical) data to be held by the same record type.
        *
        * @field wi The work-item identifier for this cell.
        * @field id The record-identifier for this cell.
        * @field number The field number (i.e. featureId) of this cell.
        * @field value The numerical value of this cell.
        * @field isOrdinal TRUE if this field represents ordered data.  FALSE if it is categorical.
        * @see ML_Core.Types.NumericField.
        */
        EXPORT GenField := RECORD(NumericField)
        Boolean isOrdinal;
        END;


        /**
        * &amp;lt;p&amp;gt;This is the major working structure for building the forest.
        * &amp;lt;p&amp;gt;For efficiency and uniformity, this record structure serves several purposes
        * as the forest is built:
        * &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;It represents all of the X,Y data associated with each tree and node as the
        *   forest is being built.  This case is recognized by id &amp;gt; 0 (i.e. it is a data point).
        *   wi, treeId, level, and NodeId represent the work-item and tree node with which the data is currently
        *         associated.
        *         All data in a tree&amp;apos;s sample is originally assigned to the tree&amp;apos;s root node (level = 1, nodeId = 1).
        *   &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;id is the sample index in this trees data bootstrap sample.&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;origId is the sample index in the original Independent(X) data.&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;number is the field number from the X data.&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;isOrdinal indicates whether this data is Ordinal (true) or Nominal (false).&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;value is the data value of this data point.&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;depend is the Dependent (Y) value associated with this data point.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;It represents the skeleton of the tree as the tree is built from the root down
        *   and the data points are subsumed (summarized) by the evolving tree structure.
        *   These cases can be identified by id = 0.&amp;lt;ul&amp;gt;
        *   &amp;lt;li&amp;gt;It represents branch (split) nodes:&amp;lt;ul&amp;gt;
        *       &amp;lt;li&amp;gt;id = 0 -- All data was subsumed.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;number &amp;gt; 0 -- The original field number of the Independent(X) variable on which to split.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;value -- the value on which to split&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;parentId -- The nodeId of the branch at the previous level that leads to this
        *                   node.  Zero only for root.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;level -- The distance from the root (root = 1).&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;support -- The number of data points that reach this node.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;ir -- The impurity reduction for this split.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;It represents leaf nodes:&amp;lt;ul&amp;gt;
        *       &amp;lt;li&amp;gt;id = 0 -- All data was subsumed.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;number = 0 -- This discriminates a leaf from a branch node.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;depend has the Y value for that leaf.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;parentId has the nodeId of the branch node at the previous level.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;support has the count of samples that reached this leaf.&amp;lt;/li&amp;gt;
        *       &amp;lt;li&amp;gt;level -- The depth of the node in the tree (root = 1).&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
        * &amp;lt;p&amp;gt;Each tree starts with all sampled data points assigned to the root node (i.e. level = 1, nodeId = 1)
        * As the trees grow, data points are assigned to deeper branches, and eventually to leaf nodes, where
        * they are ultimately subsumed (summarized) and removed from the dataset.
        * &amp;lt;p&amp;gt;At the end of the forest growing process only the tree skeleton remains -- all the datapoints having
        * been summarized by the resulting branch and leaf nodes.
        * @field treeId The unique id of the tree in the forest.
        * @field nodeId The id of this node within the tree.
        * @field parentId The node id of this node&amp;apos;s parent.
        * @field isLeft Indicates whether this node is the left child or the right child of the parent.
        * @field wi The work item with which this record is associated.
        * @field id The record id of the sample during tree construction.  Will be zero once the record has
        *           been replaced by a skeleton node (i.e. branch or leaf).
        * @field number The field number on which the branch splits
        * @field value The value of the data field, or the splitValue for a branch node.
        * @field level The level of the node within its tree.  Root is 1.
        * @field origId The sample index (id) of the original X data that this sample came from.
        * @field depend The dependent value associated with this id.
        * @field support The number of data samples subsumed by this node.
        * @field ir The &amp;apos;impurity&amp;apos; reduction achieved by this branch.
        * @field observWeight The observation weight associated with this observation.
        */
        EXPORT TreeNodeDat := RECORD
        t_TreeID treeId;
        t_NodeID nodeId;
        t_NodeID parentId;
        BOOLEAN  isLeft;             // If true, this is the parent&amp;apos;s left split
        GenField;                    // Instance Independent Data - one attribute
        UNSIGNED2     level;         // Level of the node in tree.  Root is 1.
        t_Discrete    origId;        // The sample index (id) of the original X data that this sample came from
        t_FieldReal   depend;        // Instance Dependent value
        t_RecordId   support:=0;    // Number of data samples subsumed by this node
        t_FieldReal  ir:=0;            // Impurity reduction at this node (branches only)
        t_FieldReal  observWeight:=1; // Weight assigned to this observation
        END;

        /**
        * Main data structure for processing Boosted Forest.
        * &amp;lt;p&amp;gt;The structure is the same as for random forests, but with an extra
        * field gbLevel that represents the level of the gradient boosted forest
        * nodes within the boosting hierarchy.
        * &amp;lt;p&amp;gt;Each set of nodes representing a forest is organized hierarchically based
        * on that field.
        * &amp;lt;p&amp;gt;Each level of the Boosted Forest contains a random forest.  The
        * results from each random forest are added together to get the final result
        * for the GBF.
        */
        EXPORT BfTreeNodeDat := RECORD(TreeNodeDat)
        UNSIGNED2 bfLevel;
        END;
        /**
        * The probability that a given sample is of a given class
        *
        * @field wi The work-item identifier.
        * @field id The record-id of the sample.
        * @field class The class label.
        * @field cnt The number of trees that predicted this class label.
        * @field prob The percentage of trees that assigned this class label,
        *             which is a rough stand-in for the probability that the label
        *             is correct.
        */
        EXPORT ClassProbs := RECORD
        t_Work_Item wi;  // Work-item id
        t_RecordID id;  // Sample identifier
        t_Discrete class; // The class label
        t_Discrete cnt; // The number of trees that assigned this class label
        t_FieldReal prob; // The percentage of trees that assigned this class label
        // which is a rough stand-in for the probability that the
        // label is correct.
        END;

        /**
        * NodeSummary provides information to identify a given tree node
        *
        * @field wi The work-item id for this node.
        * @field treeId The tree identifier within this work-item.
        * @field nodeId The node within the tree and work-item.
        * @field parentId The nodeId of this nodes parent node.
        * @field isLeft Boolean indicator of whether this is the Left child (TRUE) or
        *         Right child (FALSE) of the parent.
        * @field support The number of data samples that reached this node.
        */
        EXPORT NodeSummary := RECORD
        t_Work_Item wi;
        t_TreeID treeId;
        t_NodeID nodeId;
        t_NodeID parentId;     // Note that for any given (wi, treeId, nodeId), parentId and isLeft
        //   will be constant, but we need to carry them through to maintain
        //   the integrity of the nodes&amp;apos; relationships.
        BOOLEAN isLeft:=True;
        t_RecordId support;   // The number of data samples reaching this node.
        END;
        /**
        * SplitDat is used to hold information about a potential split.
        * It is based on the NodeSummary record type above.  It adds the following fields
        *
        * @field number The field number of the Independent data that is being used to split.
        * @field splitVal The value by which to split the data.
        * @field isOrdinal TRUE indicates that it is an ordered value and will use a
        *                  greater-than-or-equal split (i.e. value &amp;gt;= splitVal).
        *                  FALSE indicates that the values are nominal
        *                  (i.e. categorical) and will use an equal-to split (i.e. value = splitVal)
        */
        EXPORT SplitDat := RECORD(NodeSummary)
        t_FieldNumber number;  // This is the field number that is being split
        t_FieldReal splitVal;  // This is the value at which to split &amp;lt;= splitval =&amp;gt; LEFT &amp;gt;splitval
        // =&amp;gt; right
        BOOLEAN isOrdinal;     // We need to carry this along
        t_FieldReal ir;        // Impurity reduction at this split
        END;

        /**
        * NodeImpurity carries identifying information for a node as well as its impurity level
        * It is based on the NodeSummary record type above, but includes an assessment of the
        * &amp;apos;impurity&amp;apos; of the data at this node (i.e. GINI, Variance, Entropy).
        *
        * @field impurity The level of impurity at the given node.  Zero is most pure.
        */
        EXPORT NodeImpurity := RECORD(NodeSummary)
        t_FieldReal impurity;  // The level of impurity of the given node.  Zero is most pure.
        END;

        /**
        * Provides a summary of each work item for use in building the forest.
        *
        * @field wi The work-item identifier.
        * @field numSamples The number of samples within this work-item
        * @field numFeatures The number of features (i.e. number fields in the Independent
        *                    data for this work-item.
        * @field featuresPerNode The number of features to be randomly chosen at each level
        *                         of tree building.  It is a function of, the user parameter
        *                         &amp;apos;featuresPerNode&amp;apos; and the number of features in the work-item
        *                         numFeatures.
        */
        EXPORT wiInfo := RECORD
        t_Work_Item   wi;               // Work-item Id
        t_RecordId    numSamples;       // Number of samples for this wi&amp;apos;s data
        t_FieldNumber numFeatures;      // Number of features for this wi&amp;apos;s data
        t_Count       featuresPerNode;  // Features per node may be different for each work-item
        //   because it is based on numFeatures as well as the
        //   featuresPerNodeIn parameter to the module.
        END;
        /**
        * Model Statistics Record
        *
        * Provides descriptive information about a Model
        *
        * @field wi The work-item whose model is described
        * @field treeCount The number of trees in the forest
        * @field minTreeDepth The depth of the shallowest tree
        * @field maxTreeDepth The depth of the deepest tree
        * @field avgTreeDepth The average depth of all trees
        * @field minTreeNodes The number of nodes in the smallest tree
        * @field maxTreeNodes The number of nodes in the biggest tree
        * @field avgTreeNodes The average number of nodes for all trees
        * @field totalNodes The number of nodes in the forest
        * @field minSupport The minimum sum of support for all trees.
        *                   Support indicates the number of training datapoints
        *                   that arrived at a given leaf node
        * @field maxSupport The maximum sum of support for all trees
        * @field agvSupport The average sum of support for all trees
        * @field avgSupportPerLeaf The average number of data points per
        *                     leaf across the forest
        * @field maxSupportPerLeaf The maximum data points at any single
        *                     leaf across the forest
        * @field avgLeafDepth The average depth for all leaf nodes
        *                     for all trees
        * @field minLeafDepth The minimum depth for all leaf nodes
        *                     for all trees
        */
        EXPORT ModelStats := RECORD
        t_Work_Item wi;
        UNSIGNED treeCount;
        UNSIGNED minTreeDepth;
        UNSIGNED maxTreeDepth;
        REAL avgTreeDepth;
        UNSIGNED minTreeNodes;
        UNSIGNED maxTreeNodes;
        REAL avgTreeNodes;
        UNSIGNED totalNodes;
        UNSIGNED minSupport;
        UNSIGNED maxSupport;
        REAL avgSupport;
        REAL avgSupportPerLeaf;
        UNSIGNED maxSupportPerLeaf;
        REAL avgLeafDepth;
        UNSIGNED minLeafDepth;
        UNSIGNED bfLevel := 1;
        END; // ModelStats
        /**
        * Feature Importance Record
        * describes the importance of each feature.
        * @field wi The work-item associated with this information.
        * @field number The feature number.
        * @field importance The &amp;apos;importance&amp;apos; metric.  Higher value is more
        *                   important.
        * @field uses The number of times the feature was used in the forest.
        */
        EXPORT FeatureImportanceRec := RECORD
        t_Work_Item wi;
        t_FieldNumber number;
        t_FieldReal importance;
        UNSIGNED uses;
        END;

        /**
        * ClassWeightsRecord holds the weights associated with each
        * class label.
        *
        * @field wi The work-item.
        * @field classLabel The subject class label.
        * @field weight The weight associated with this class label.
        **/
        EXPORT ClassWeightsRec := RECORD
        t_work_item wi;
        t_Discrete classLabel;
        t_FieldReal weight;
        END;

        /**
        * Structure used to describe the Scorecards for LUCI format export.
        *
        * For a single scorecard model, a single LUCI_Scorecard record is used.
        * For multiple scorecards, one record is required per scorecard.
        * One L2SC or L2FO record will be generated per scorecard, and additionally
        * One L2SE record will be generated for each scorecard with a non-blank
        * &amp;apos;filter_expr&amp;apos;.
        *
        * @field wi_num The work-item number on which to base this scorecard or &amp;apos;1&amp;apos; if only one
        *               work-item / scorecard us used.
        * @field scorecard_name The LUCI name for this scorecard.
        * @field filter_expr Optional -- An expression on the LUCI input dataset layout that selects
        *                    the records to be included in this scorecard (e.g. &amp;apos;state_id = 2&amp;apos;).
        *                    If the expression contains strings, the single-quotes must be preceded
        *                    by a backslash escape character (e.g. &amp;apos;state = \&amp;apos;NY\&amp;apos;&amp;apos;).
        *                    The filter expression must follow ECL Boolean expression syntax.
        *                    It should be blank if all records are to be used.  See L2SE LUCI
        *                    record format, Scorecard-Election-Criteria for more details.
        * @field fieldMap    A DATASET(Field_Mapping) as returned from the FromField macro that maps the Field Names
        *                    (as used in the LUCI definition) to the field numbers (as used in the ML model).
        *                    Note: must be the same set of fields used in training the forest for this work item.
        */
        EXPORT LUCI_Scorecard := RECORD
        UNSIGNED wi_num := 1;
        STRING scorecard_name;
        STRING filter_expr := &amp;apos;&amp;apos;;
        DATASET(Field_Mapping) fieldMap;
        END;
        END; // LT_Types&amp;#10;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;classificationforest&quot;
        name=&quot;ClassificationForest&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/ClassificationForest.ecl&quot;
        ts=&quot;1621960363000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
        ############################################################################## */
        IMPORT $ AS LT;
        IMPORT LT.LT_Types AS Types;
        IMPORT ML_Core;
        IMPORT ML_Core.Types as CTypes;
        IMPORT ML_Core.interfaces AS Interfaces;
        IMPORT LT.internal AS int;

        NumericField := CTypes.NumericField;
        DiscreteField := CTypes.DiscreteField;
        Layout_Model2 := CTypes.Layout_Model2;
        TreeNodeDat := Types.TreeNodeDat;
        t_Discrete := CTypes.t_Discrete;
        t_Work_Item := CTypes.t_Work_Item;
        t_RecordID := CTypes.t_RecordId;
        ClassProbs := Types.ClassProbs;
        IClassify2 := Interfaces.IClassify2;


        /**
        * Classification using Random Forest algorithm.
        * &amp;lt;p&amp;gt;This module implements Random Forest classification as described by
        * Breiman, 2001 with extensions.
        * (see https://www.stat.berkeley.edu/~breiman/randomforest2001.pdf)
        *
        * &amp;lt;p&amp;gt;Random Forests provide a very effective method for classification
        * with few assumptions about the nature of the data.  They are known
        * to be one of the best out-of-the-box methods as there are few assumptions
        * made regarding the nature of the data or its relationship to classes.
        * Random Forests can effectively manage large numbers
        * of features, and will automatically choose the most relevant features.
        * Random Forests inherently support multi-class problems.  Any number of
        * class labels can be used.
        *
        * &amp;lt;p&amp;gt;This implementation supports both Numeric (discrete or continuous) and
        * Nominal (unordered categorical values) for the independent (X) features.
        * There is therefore, no need to one-hot encode categorical features.
        * Nominal features should be identified by including their feature &amp;apos;number&amp;apos;
        * in the set of &amp;apos;nominalFields&amp;apos; in GetModel.
        *
        * &amp;lt;p&amp;gt;RegressionForest supports the Myriad interface meaning that multiple
        * independent models can be computed with a single call (see ML_Core.Types
        * for information on using the Myriad feature).
        *
        * &amp;lt;p&amp;gt;Notes on use of NumericField and DiscreteField layouts:
        * &amp;lt;ul&amp;gt;
        * &amp;lt;li&amp;gt;Work-item ids (&amp;apos;wi&amp;apos; field) are not required to be sequential, though they must be positive
        *   numbers.  It is a good practice to assign wi = 1 when only one work-item is used.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;Record Ids (&amp;apos;id&amp;apos; field) are not required to be sequential, though slightly faster performance
        *   will result if they are sequential (i.e. 1 .. numRecords) for each work-item.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;Feature numbers (&amp;apos;number&amp;apos; field) are not required to be sequential, though slightly faster
        *   performance will result if they are (i.e. 1 .. numFeatures) for each work-item.&amp;lt;/li&amp;gt;
        * &amp;lt;/ul&amp;gt;
        *
        * @param numTrees The number of trees to create in the forest for each work-item.
        *                 This defaults to 100, which is adequate for most cases.  Increasing
        *                 this parameter generally results in less variance in accuracy between
        *                 runs, at the expense of greater run time.
        * @param featuresPerNode The number of features to choose among at each split in
        *                 each tree.  This number of features will be chosen at random
        *                 from the full set of features.  The default (0) uses the square
        *                 root of the number of features provided, which works well
        *                 for most cases.
        * @param maxDepth The deepest to grow any tree in the forest.  The default is
        *                 100, which is adequate for most purposes.  Increasing this value
        *                 for very large and complex problems my provide slightly greater
        *                 accuracy at the expense of much greater runtime.
        * @param nominalFields An optional set of field &amp;apos;numbers&amp;apos; that represent Nominal (i.e. unordered,
        *                      categorical) values.  Specifying the nominal fields improves run-time
        *                      performance on these fields and may improve accuracy as well.  Binary fields
        *                      (fields with only two values) need not be included here as they can be
        *                      considered either ordinal or nominal.  The default is to treat all fields as
        *                      ordered.
        *                      Note that this feature should only be used if all of the independent
        *                      data for all work-items use the same record format, and therefore have the same
        *                      set of nominal fields.
        * @param balanceClasses An optional Boolean parameter.  If true, it indicates that the voting among
        *                       trees should be biased inversely to the frequency of the class for which it
        *                       is voting.  This may help in scenarios where there are far more samples of
        *                       certain classes than of others.  The default is to not balance (i.e. FALSE).
        */
        EXPORT ClassificationForest(UNSIGNED numTrees=100,
        UNSIGNED featuresPerNode=0,
        UNSIGNED maxDepth=100,
        SET OF UNSIGNED nominalFields=[],
        BOOLEAN balanceClasses=FALSE) := MODULE(LT.LearningForest(numTrees, featuresPerNode, maxDepth), IClassify2)
        /**
        * Fit and return a model that maps independent data (X) to its predicted class (Y).
        *
        * @param independents  The set of independent data in NumericField format.
        * @param dependents The set of classes in DiscreteField format that correspond to the independent data
        *           i.e. same &amp;apos;id&amp;apos;.
        * @param nominalFields An optional set of field &amp;apos;numbers&amp;apos; that represent Nominal (i.e. unordered,
        *                      categorical) values.  Specifying the nominal fields improves run-time
        *                      performance on these fields and my improve accuracy as well.  Binary fields
        *                      (fields with only two values) need not be listed here as they can be
        *                      considered either ordinal or nominal.  Example: [3,5,7].
        * @return Model in Layout_Model2 format describing the fitted forest.
        * @see ML_Core.Types.NumericField, ML_Core.Types.DiscreteField, ML_Core.Types.Layout_Model2
        */
        EXPORT DATASET(Layout_Model2) GetModel(DATASET(NumericField) independents, DATASET(DiscreteField) dependents) := FUNCTION
        genX := NF2GenField(independents, nominalFields);
        genY := DF2GenField(dependents);
        myRF := int.RF_Classification(genX, genY, numTrees, featuresPerNode, maxDepth);
        model := myRF.GetModel;
        RETURN model;
        END;
        /**
        * Classify a set of data points using a previously fitted model
        *
        * @param model A model previously returned by GetModel in Layout_Model2 format.
        * @param observations The set of independent data to classify in NumericField format.
        * @return A DiscreteField dataset that indicates the predicted class of each item
        * in observations.
        */
        EXPORT DATASET(DiscreteField) Classify(DATASET(Layout_Model2) model, DATASET(NumericField) observations) := FUNCTION
        genX := NF2GenField(observations);
        myRF := int.RF_Classification();
        classes := myRF.Classify(genX, model, balanceClasses);
        RETURN classes;
        END;

        /**
        * Calculate the &amp;apos;probability&amp;apos; that each data point is in each class.
        * &amp;lt;p&amp;gt;Probability is approximated by computing the proportion of trees that
        * voted for each class for each data point, so should not be treated
        * as a reliable measure of true probability.
        *
        * @param model A model previously returned by GetModel in Layout_Model2 format.
        * @param observations The set of independent data to classify in NumericField format.
        * @return DATASET(ClassProbs), one record per datapoint (i.e. id) per class
        *         label.  Class labels with zero votes are omitted.
        * @see LT_Types.ClassProbs
        *
        */
        EXPORT DATASET(ClassProbs) GetClassProbs(DATASET(Layout_Model2) model, DATASET(NumericField) observations) := FUNCTION
        genX := NF2GenField(observations);
        myRF := int.RF_Classification();
        probs := myRF.GetClassProbs(genX, model, balanceClasses);
        probsS := SORT(probs, wi, id, class); // Global sort
        RETURN probsS;
        END;

        /**
        * Extract the set of class weights from the model.
        * &amp;lt;p&amp;gt;Classes are weighted inversely proportional to their frequency in the
        * training data.  &amp;lt;p&amp;gt;Note that the class weights are based on a non-linear
        * &amp;apos;proportion&amp;apos; to avoid excess weight for classes with very low frequency.
        * &amp;lt;p&amp;gt;These weights are only used when the &amp;apos;balanceClasses&amp;apos; option is TRUE.
        *
        * @param mod A model as returned from GetModel.
        * @return DATASET(ClassWeightRec) representing weight for each class label.
        * @see LT_Types.ClassWeightRec
        */
        EXPORT  Model2ClassWeights(DATASET(Layout_Model2) mod) := FUNCTION
        myRF := int.RF_Classification();
        cw := myRF.Model2ClassWeights(mod);
        RETURN cw;
        END;
        END;&amp;#10;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;learningforest&quot;
        name=&quot;LearningForest&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/LearningForest.ecl&quot;
        ts=&quot;1621960363000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
        ############################################################################## */

        IMPORT $ AS LT;
        IMPORT LT.LT_Types AS Types;
        IMPORT ML_Core;
        IMPORT ML_Core.Types as CTypes;
        IMPORT $ as LT;
        IMPORT LT.internal AS int;

        GenField := Types.GenField;
        DiscreteField := CTypes.DiscreteField;
        NumericField := CTypes.NumericField;
        Layout_Model2 := CTypes.Layout_Model2;
        ModelStats := Types.ModelStats;
        TreeNodeDat := Types.TreeNodeDat;

        /**
        * This is the base module for Random Forests.
        * It implements the Random Forest algorithms as described by Breiman, 2001
        * (see https://www.stat.berkeley.edu/~breiman/randomforest2001.pdf).
        *
        * @param numTrees The number of trees to create as the forest for each work-item.
        *                 This defaults to 100, which is adequate for most cases.
        * @param featuresPerNode The number of features to choose among at each split in
        *                 each tree.  This number of features will be chosen at random
        *                 from the full set of features.  The default is the square
        *                 root of the number of features provided, which works well
        *                 for most cases.
        * @param maxDepth The deepest to grow any tree in the forest.  The default is
        *                 100, which is adequate for most purposes.  Increasing this value
        *                 for very large and complex problems my provide slightly greater
        *                 accuracy at the expense of much greater runtime.
        */
        EXPORT LearningForest(UNSIGNED numTrees=100,
        UNSIGNED featuresPerNode=0,
        UNSIGNED maxDepth=100) := MODULE
        // Map a NumericField dataset to GenField dataset
        SHARED DATASET(GenField) NF2GenField(DATASET(NumericField) ds, SET OF UNSIGNED nominalFields=[]) := FUNCTION
        dsOut := PROJECT(ds, TRANSFORM(GenField, SELF.isOrdinal := LEFT.number NOT IN nominalFields, SELF := LEFT));
        RETURN dsOut;
        END;
        // Map a DiscreteField dataset to GenField dataset
        SHARED DATASET(GenField) DF2GenField(DATASET(DiscreteField) ds) := FUNCTION
        dsOut := PROJECT(ds, TRANSFORM(GenField, SELF.isOrdinal := TRUE, SELF := LEFT));
        RETURN dsOut;
        END;
        /**
        * Get summary statistical information about the model.
        *
        * @param mod A model previously returned from GetModel.
        * @return A single ModelStats record per work-item, containing information about the model
        *         for that work-item.
        * @see LT_Types.ModelStats
        */
        EXPORT DATASET(ModelStats) GetModelStats(DATASET(Layout_Model2) mod) := FUNCTION
        myRF := int.RF_Base();
        RETURN myRF.GetModelStats(mod);
        END;
        /**
        * Extract the set of tree nodes from a model.
        *
        * @param mod A model as returned from GetModel.
        * @return Set of tree nodes representing the fitted forest in
        *         DATASET(TreeNodeDat) format.
        * @see LT_Types.TreeNodeDat
        */
        EXPORT DATASET(TreeNodeDat) Model2Nodes(DATASET(Layout_Model2) mod) := FUNCTION
        myRF := int.RF_Base();
        nodes0 := myRF.Model2Nodes(mod);
        nodes := SORT(nodes0, wi, treeId, level, nodeId, LOCAL);
        RETURN nodes;
        END;
        /**
        * &amp;lt;p&amp;gt;Determine the relative importance of features in the decision process of
        * the model.
        * Calculate feature importance using the Mean Decrease Impurity (MDI) method
        * from &amp;quot;Understanding Random Forests: by Gilles Loupe (https://arxiv.org/pdf/1407.7502.pdf)
        * and due to Breiman [2001, 2002].
        *
        * &amp;lt;p&amp;gt;Each feature is ranked by:
        * &amp;lt;pre&amp;gt;  SUM for each branch node in which feature appears (across all trees):
        *     (impurity_reduction * number of nodes split) / numTrees.&amp;lt;/pre&amp;gt;
        * @param mod The model to use for ranking of feature importance.
        * @return DATASET(FeatureImportanceRec), one per feature per wi.
        * @see LT_Types.FeatureImportanceRec
        */
        EXPORT FeatureImportance(DATASET(Layout_Model2) mod) := FUNCTION
        myRF := int.RF_Base();
        fi := myRF.FeatureImportance(mod);
        RETURN fi;
        END;
        SHARED empty_data := DATASET([], NumericField);
        /**
        * &amp;lt;p&amp;gt;Calculate a matrix of distances between data points in Random Forest Decision Space (RFDS).
        * This is an experimental method and may not
        * scale to large numbers of data point combinations.
        * Two sets of data points X1 and X2 are taken as parameters.  A
        * Decision Distance will be returned for every point in X1 to every
        * point in X2.  Therefore, if X1 has N points and X2 has M points, an
        * N x M matrix of results will be produced.  X2 may be omitted, in which
        * case, an N x N matrix will be produced with a Decision Distance for
        * every pair of points in X1.
        *
        * &amp;lt;p&amp;gt;This metric represents a distance measure in the RFDS.
        * As such, it provides a continuous measure of distance in a space that is
        * highly non-linear and discontinuous relative to the training data.
        * Distances in RFDS can be thought of as the number of binary decisions
        * that separate two points in the tree.  DD, however is a normalized
        * metric 0 &amp;lt;= DD &amp;lt; 1 that incorporates the depth of the decision tree.
        * It is also averaged over all of the trees in the forest.
        * It can possibly be viewed as an approximation of the relative Hamming Distances
        * between points.
        *
        * @param mod The Random Forest model on which to base the distances.
        * @param X1 DATASET(NumericField) of &amp;quot;from&amp;quot; points.
        * @param X2 (Optional) DATASET(NumericField) of &amp;quot;to&amp;quot; points.  If this
        *             parameter is omitted, the X1 will be used as both &amp;quot;to&amp;quot; and
        *             &amp;quot;from&amp;quot; points.
        * @return DATASET(NumericField) matrix where &amp;apos;id&amp;apos; is the id of the &amp;quot;from&amp;quot;
        *               point and &amp;apos;number&amp;apos; is the id of the &amp;quot;to&amp;quot; point.
        *               &amp;apos;value&amp;apos; contains the DD metric between &amp;quot;from&amp;quot; and &amp;quot;to&amp;quot; points.
        *               Note that if the same point is in X1 and X2, there will be
        *               redundant metrics, since DD is a symmetric measure (i.e.
        *               DD(x1, x2) = DD(x2, x1).
        */
        EXPORT DecisionDistanceMatrix(DATASET(Layout_Model2) mod, DATASET(NumericField) X1,
        DATASET(NumericField) X2=empty_data) := FUNCTION
        myRF := int.RF_Base();
        ddm := myRF.DecisionDistanceMatrix(mod, NF2GenField(X1), NF2GenField(X2));
        RETURN DDM;
        END;
        /**
        *
        * Uniqueness Factor is an experimental metric that determines how far a given point
        * is (in Random Forest Decision Distance) from a set of other points.
        * It may not scale to large numbers of data points.
        *
        * Uniqueness Factor looks at the Decision Distance from each point to every other
        * point in a set.
        *
        * It is similar to Decision Distance (above), but rather than providing a distance of
        * each &amp;quot;from&amp;quot; point to every &amp;quot;to&amp;quot; point, it provides the average distance of each &amp;quot;from&amp;quot;
        * point to all of the &amp;quot;to&amp;quot; points.
        *
        * Like Decision Distance, UF lies on the interval: 0 &amp;lt;= UF &amp;lt; 1.
        *
        * A high value of UF may indicate an anomolous data point, while a low value may indicate
        * &amp;quot;typicalness&amp;quot; of a data point.  It may therefore have utility for anomaly detection
        * or conversely, for the identification of class prototypes (e.g. the members of a class
        * with the lowest UF).  In a two-step process one could potentially compute class prototypes
        * and then look at the distance of a point from all class prototypes.  This could result
        * in a way to detect anomalies with respect to e.g., known usage patterns.
        *
        * @param mod The Random Forest model on which to base the distances.
        * @param X1 DATASET(NumericField) of &amp;quot;from&amp;quot; points.
        * @param X2 (Optional) DATASET(NumericField) of &amp;quot;to&amp;quot; points.  If this
        *             parameter is omitted, the X1 will be used as both &amp;quot;to&amp;quot; and
        *             &amp;quot;from&amp;quot; points.
        * @return DATASET(NumericField) matrix where &amp;apos;id&amp;apos; is the id of the &amp;quot;from&amp;quot;
        *               point and &amp;apos;value&amp;apos; contains the UF metric for the point.
        *               I.e. the average DD of the &amp;quot;from&amp;quot; point to all &amp;quot;to&amp;quot; points.
        *               The &amp;apos;number&amp;apos; field is not used and is set to 1.
        */
        EXPORT UniquenessFactor(DATASET(Layout_Model2) mod, DATASET(NumericField) X1, DATASET(NumericField) X2=empty_data) := FUNCTION
        myRF := int.RF_Base();
        uf := myRF.UniquenessFactor(mod, NF2GenField(X1), NF2GenField(X2));
        RETURN uf;
        END;

        /**
        * Compress and cleanup the model
        *
        * This function is provided to reduce the size of a model by compressing out
        * branches with only one child.  These branches are a result of the RF algorithm,
        * and do not affect the results of the model.
        * This is an expensive operation, which is why it is not done as a matter of
        * course.  It reduces the size of the model somewhat, and therefore slightly speeds
        * up any processing that uses the model, and reduces storage size.
        * You may want to compress the model if storage is at a premium, or if the model
        * is to be used many times (so that the slight performance gain is multiplied).
        * This also makes the model somewhat more readable, and could
        * be useful when analyzing the tree or converting it to another system
        * (e.g. LUCI) for processing.
        *
        * @param mod Model as returned from GetModel in Layout_Model2 format.
        * @return The Compressed Model.
        * @see ML_Core.Types.Layout_Model2
        *
        */
        EXPORT CompressModel(DATASET(Layout_Model2) mod) := FUNCTION
        myRF := int.RF_Base();
        cMod := myRF.CompressModel(mod);
        RETURN cMod;
        END;
        END;&amp;#10;
        &lt;/Attribute&gt;
        &lt;/Module&gt;
        &lt;Module key=&quot;_versions.ml_core&quot; name=&quot;_versions.ML_Core&quot;/&gt;
        &lt;Module key=&quot;_versions.ml_core.v3_2_2&quot; name=&quot;_versions.ML_Core.V3_2_2&quot;/&gt;
        &lt;Module key=&quot;_versions.ml_core.v3_2_2.ml_core&quot; name=&quot;_versions.ML_Core.V3_2_2.ML_Core&quot;&gt;
        &lt;Attribute key=&quot;types&quot;
        name=&quot;Types&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Types.ecl&quot;
        ts=&quot;1621960335000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2018 HPCC Systems®.  All rights reserved.
        ############################################################################## */
        //IMPORT $ AS ML_Core;
        //NamingTree := ML_Core.NamingTree;

        /**
        * This module provides the major data type definitions for use with the various
        * ML Bundles
        *
        */
        EXPORT Types := MODULE
        // The t_RecordID and t_FieldNumber are native nominal types of the ML
        // libraries and they currently allow for 2**64 rows with 2**32
        // features.
        //
        // If your needs are lower, then making these two smaller
        // will improve performance. In particular an unsigned4 for t_RecordID
        // supports 2**32 (more than 4 billion) rows and an unsigned2 for
        // t_FieldNumber allows 64K features.
        //
        // Some ML modules will use dense matrix operations form PBblas and
        // support only 4 billion (2**32) rows.
        //
        // The structures are also used for the myriad interface support.
        // The notion is to support a myriad of small problems that need the
        // steps applied.  Sort of a logical Single Instruction Multiple Data
        // parallel machine approach.  The work_item is used to group the
        // problem data.  If you have just one problem, the field should be
        // set to some positive constant like 1.
        //
        EXPORT t_RecordID := UNSIGNED8;
        EXPORT t_FieldNumber := UNSIGNED4;
        EXPORT t_FieldReal := REAL8;
        EXPORT t_FieldSign := INTEGER1;
        EXPORT t_Discrete := INTEGER4;
        EXPORT t_Item := UNSIGNED4; // Currently allows up to 4B different elements
        EXPORT t_Count := t_RecordID; // Possible to count every record
        EXPORT t_Work_Item := UNSIGNED2;  //TODO: change to be PBblas.Types.work_item_t
        EXPORT t_index := UNSIGNED4;  // Type of each index value (see Layout_Model2)
        EXPORT t_indexes := SET OF t_index; // Definition of the indexes field for Layout_Model2

        // Base record for Numeric and Discrete Fields
        EXPORT AnyField     := RECORD
        t_Work_Item wi; // Work-item id
        t_RecordID id;  // Observation identifier (i.e. row id for X and Y) -- 1 based
        t_FieldNumber number; // Feature number (i.e. column number) -- 1 based
        END;

        /**
        * The NumericField layout defines a matrix of Real valued data-points.
        * It acts as the primary Dataset layout for interacting with most ML Functions.
        * Each record represents a single cell in a matrix.  It is most often used
        * to represent a set of data-samples or observations, with the &amp;apos;id&amp;apos; field representing
        * the data-sample or observation, and the &amp;apos;number&amp;apos; field representing the
        * various fields within the observation.
        *
        * @field wi The work-item id, supporting the Myriad style interface.  This allows
        *           multiple independent matrixes to be contained within a single dataset,
        *           supporting independent ML activities to be processed in parallel.
        * @field id This field represents the row-number of this cell of the matrix.  It
        *           is also considered the record-id for observations / data-samples.
        * @field number This field represents the matrix column number for this cell.  It
        *               is also considered the field number of the observation
        * @field value The value of this cell in the matrix.
        *
        */
        EXPORT NumericField := RECORD(AnyField)
        t_FieldReal value;
        END;

        /**
        * The Discrete Field layout defines a matrix of Integer valued data-points.
        * It is similar to the NumericField layout above, except for only containing
        * discrete (integer) values.
        * It is typically used to convey the class-labels for classification algorithms.
        *
        * @field wi The work-item id, supporting the Myriad style interface.  This allows
        *           multiple independent matrixes to be contained within a single dataset,
        *           supporting independent ML activities to be processed in parallel.
        * @field id This field represents the row-number of this cell of the matrix.  It
        *           is also considered the record-id for observations / data-samples.
        * @field number This field represents the matrix column number for this cell.  It
        *               is also considered the field number of the observation
        * @field value The value of this cell in the matrix.
        *
        */
        EXPORT DiscreteField := RECORD(AnyField)
        t_Discrete value;
        END;

        /**
        * Layout for Model dataset (version 2)
        *
        * Generic Layout describing the model &amp;apos;learned&amp;apos; by a Machine Learning algorithm.
        *
        * Models for all new ML bundles are stored in this format.
        * Some older bundles may still use the Layout_Model (version 1)
        * layout.
        *
        * Models are thought of as opaque data structures.  They are
        * not designed to be understandable except to the bundle that
        * produced them.  Most bundles contain mechanisms to extract
        * useful information from the model.
        *
        * This version of the model is based on a Naming-Tree paradigm.
        * This provides a flexible generic mechanism for storage and
        * manipulation of models.
        *
        * For bundle developers (or the curious), the file modelOps2
        * provides a detailed description of
        * the theory and usage of this model layout as well as a set of
        * functions to manipulate models for use by bundle developers.
        *
        * @field wi The work-item-id
        * @field value The value of the cell
        * @field indexes The identifier for the cell -- a set of unsigned integers
        *                e.g., [1,2,1,3]
        */
        EXPORT Layout_Model2 := RECORD
        t_work_item wi;
        t_fieldReal value;
        t_indexes indexes;
        END;

        // Note: Layout_Model has been deprecated in favor of Layout_Model2, which
        // should be used as the basis of the model for new Bundles or Bundles
        // undergoing major revision.
        // Generic Layout describing the model &amp;apos;learned&amp;apos; by a Machine Learning algorithm.
        EXPORT Layout_Model := RECORD
        t_Work_Item wi;       // Work-item of the model
        t_RecordID  id;       // Identifies the component type within the model
        t_FieldNumber number; // meaning varies by ID
        t_FieldReal value;    // The model parameter value
        END;

        // Generic Layout describing the model &amp;apos;learned&amp;apos; by a Machine Learning algorithm.
        // See NamingTree.ecl for details on using this format.
        //EXPORT Layout_Model2 := NamingTree.ntNumeric;

        // Classification definitions
        EXPORT Classify_Result := RECORD(DiscreteField)
        REAL8 conf;  // Confidence - high is good
        END;
        EXPORT l_result := Classify_Result : DEPRECATED(&amp;apos;Use Classify_Result&amp;apos;);

        // Result structures for the common analytic methods (see Analysis.ecl)
        /**
        * Class_Stats
        *
        * Layout for data returned from Analysis.Regression.ClassStats
        *
        * @field wi Work-item identifier
        * @field classifier The field number associated with this dependent variable, for
        *                   multi-variate classification.  Otherwise 1.
        * @field class The class label associated with this record
        * @field classCount The number of times the class was seen in the data
        * @field classPct The percent of records with this class.
        */
        EXPORT Class_Stats := RECORD
        t_Work_Item wi;
        t_FieldNumber classifier; // Dependent column identifier for multi-variate
        t_Discrete class;
        t_Discrete classCount;
        t_FieldReal classPct;
        END;
        /**
        * Confusion_Detail
        *
        * Layout for storage of the confusion matrix for ML Classifiers
        * Each row represents a pairing of a predicted class and an actual class
        *
        * @field wi Work item identifier
        * @field classifier The field number associated with this dependent variable, for
        *                   multi-variate.  Otherwise 1.
        * @field actual_class The target class number -- the expected result.
        * @field predict_class The class number predicted by the ML algorithm
        * @field occurs The number of times this pairing of (actual / predicted) classes occurred
        * @field correct Boolean indicating if this represents a correct prediction (i.e.
        *                predicted = actual)
        * @field pctActual The percent of items that were actually of &amp;lt;actual_class&amp;gt; that
        *                  were predicted as &amp;lt;predict_class&amp;gt;.
        * @field pctPred Indicates the percent of items that were predicted as &amp;lt;predict_class&amp;gt;
        *                that were actually of &amp;lt;actual_class&amp;gt;.
        */
        EXPORT Confusion_Detail := RECORD
        t_work_item wi;
        t_FieldNumber classifier;   // Dependent column identifier
        t_Discrete actual_class;
        t_Discrete predict_class;
        UNSIGNED4 occurs;
        BOOLEAN correct;
        t_FieldReal pctActual := 0;
        t_FieldReal pctPred := 0;
        END;
        /** Classification_Accuracy
        *
        * Results layout for Analysis.Classification/Accuracy
        * @field wi Work item identifier
        * @field classifier The field number associated with this dependent variable, for
        *                   multi-variate.  Otherwise 1.
        * @field errCnt The number of errors (i.e. predicted &amp;lt;&amp;gt; actual)
        * @field recCnt The total number or records in the test set
        * @field Raw_Accuracy The percentage of samples properly classified (0.0 - 1.0)
        * @field PoD Power of Discrimination.  Indicates how this classification performed
        *           relative to a random guess of class.  Zero or negative indicates that
        *           the classification was no better than a random guess.  1.0 indicates a
        *           perfect classification.  For example if there are two equi-probable classes,
        *           then a random guess would be right about 50% of the time.  If this
        *           classification had a Raw Accuracy of 75%, then its PoD would be .5
        *           (half way between a random guess and perfection).
        * @field PoDE Power of Discrimination Extended.  Indicates how this classification
        *           performed relative to guessing the most frequent class (i.e. the trivial
        *           solution).  Zero or negative indicates that this classification is no
        *           better than the trivial solution.  1.0 indicates perfect classification.
        *           For example, if 95% of the samples were of class 1, then the trivial
        *           solution would be right 95% of the time.  If this classification had a
        *           raw accuracy of 97.5%, its PoDE would be .5 (i.e. half way between
        *           trivial solution and perfection).
        * @field Hamming_Loss Hamming loss. The percentage of records misclassified.
        *           Useful for multilabel classification. It is equal to 1 - Raw_Accuracy.
        *
        */
        EXPORT Classification_Accuracy := RECORD
        t_Work_Item wi;
        t_FieldNumber classifier;
        UNSIGNED recCnt;
        UNSIGNED errCnt;
        REAL Raw_Accuracy;
        REAL PoD;
        REAL PoDE;
        REAL Hamming_Loss;
        END;
        /**
        * Class_Accuracy
        *
        * Results layout for Analysis.Classification.AccuracyByClass
        * See https://en.wikipedia.org/wiki/Precision_and_recall for a more detailed
        * explanation.
        *
        * @field wi Work item identifier
        * @field classifier The field number associated with this dependent variable, for
        *                   multi-variate.  Otherwise 1.
        * @field class The class to which the analytics apply
        * @field precision The precision of the classification for this class
        *                  (i.e. True Positives / (True Positives + FalsePositives)).
        *                  What percentage of the items that we predicted as being
        *                  in this class are actually of this class?
        * @field recall The completeness of recall for this class
        *                  (i.e. True Positives / (True Positives + False Negatives))
        *                  What percentage of the items that are actually in this class
        *                  did we correctly predict as this class?
        * @field FPR The false positive rate for this class
        *                  (i.e. False Positives / (False Positives + True Negatives))
        *                  What percentage of the items not in this class did we falsely
        *                  predict as this class?
        * @field f_score The balanced F-score for this class
        *                  (i.e. 2 * (precision * recall) / (precision + recall))
        *                  The harmonic mean of precision and recall. Higher values are better.
        *
        */
        EXPORT Class_Accuracy := RECORD
        t_Work_Item wi;
        t_FieldNumber classifier;
        t_Discrete class;
        REAL precision;
        REAL recall;
        REAL FPR;
        REAL f_score;
        END;
        /**
        * AUC_Result
        *
        * Result layout for Analysis.Classification.AUC.
        *
        * Provides the area under the Receiver Operating Characteristic curve for the given
        * given data. This area is a measure of the classifier&amp;apos;s ability to distinguish between
        * classes.
        *
        * @field wi Work item identifier
        * @field classifier The field number associated with this dependent variable, for
        *                   multi-variate.  Otherwise 1.
        * @field class The class to which the analytics apply.
        * @field AUC The value of the Area Under the Receiver Operating Characteristic curve
        *            for this class. This value ranges between 0 and 1. A higher value is an
        *            indication of a better classifier.
        */
        EXPORT AUC_Result := RECORD
        t_Work_Item wi;
        t_FieldNumber classifier;
        t_Discrete class;
        t_FieldReal AUC;
        END;
        /**
        * Regression_Accuracy
        *
        * Results layout for Analysis.Regression.Accuracy
        *
        * @field wi Work item identifier
        * @field regressor The field number associated with this dependent variable, for
        *                   multi-variate.  Otherwise 1.
        * @field R2 The R-Squared value (Coefficient of Determination) for the regression.
        *           R-squared of zero or negative indicates that the regression has no predictive
        *           value.  R2 of 1 would indicate a perfect regression.
        * @field MSE Mean Squared Error = SUM((predicted - actual)^2) / N (number of datapoints)
        * @field RMSE Root Mean Squared Error = MSE^.5 (Square root of MSE)
        *
        */
        EXPORT Regression_Accuracy := RECORD
        t_Work_Item wi;
        t_FieldNumber regressor;
        t_FieldReal R2;
        t_FieldReal MSE;
        t_FieldReal RMSE;
        END;
        /**
        * Contingency_Table
        *
        * Contains the contingency table for every combination of feature and classifier.
        * Result layout for Analysis.FeatureSelection.Contingency
        *
        * @field wi Work item identifier
        * @field fnumber The feature number
        * @field snumber The sample number or the classifier number
        * @field fclass The feature label / class
        * @field sclass The sample (classifier) label / class
        * @field cnt The number of samples with feature label fclass and classifier label sclass
        *            Does not contain entries for combinations with no members.
        *
        */
        EXPORT Contingency_Table := RECORD
        t_Work_Item wi;
        t_FieldNumber fnumber;
        t_FieldNumber snumber;
        t_Discrete fclass;
        t_Discrete sclass;
        INTEGER cnt := COUNT(GROUP);
        END;
        /**
        * Chi2_Result
        *
        * Result layout for Analysis.FeatureSelection.Chi2
        * Contains chi2 value for every combination of feature and classifier per work item,
        * and its corresponding p value.
        *
        * @field wi Work item identifier
        * @field fnumber Feature number
        * @field snumber Sample number / number of classifier
        * @field dof The number of degrees of freedom
        * @field x2 The chi2 value for this combination. Higher values indicate more closely
        related variables
        * @field p The p-value, which is the area under the chi-square probability density function
        *          curve to the right of the specified x2 value. The probability that the variables
        *          are not closely related
        *
        */
        EXPORT Chi2_Result := RECORD
        t_Work_Item wi;
        t_FieldNumber fnumber;
        t_FieldNumber snumber;
        INTEGER dof;
        t_FieldReal x2;
        t_FieldReal p;
        END;
        /**
        * ARI_Result
        *
        * Result layout for Analysis.Clustering.ARI
        *
        * Contains the Adjusted Rand Index for each work item.
        *
        * @field wi Work item identifier
        * @field value The ARI for the model
        *
        */
        EXPORT ARI_Result := RECORD
        t_Work_Item wi;
        t_FieldReal value;
        END;
        /**
        * SampleSilhouette_Result
        *
        * Result layout for Analysis.Clustering.SampleSilhouetteScore
        *
        * Contains the silhouette score for each sample datapoint.
        *
        * @field wi Work item identifier
        * @field id Sample datapoint identifier
        * @field value Silhouette score
        *
        */
        EXPORT SampleSilhouette_Result := RECORD
        t_Work_Item wi;
        t_RecordID id;
        t_FieldReal value;
        END;
        /**
        * Silhouette_Result
        *
        * Result layout for Analysis.Clustering.SilhouetteScore
        *
        * Contains the silhouette score for each work item.
        *
        * @field wi Work item identifier
        * @field score Silhouette score
        *
        */
        EXPORT Silhouette_Result := RECORD
        t_Work_Item wi;
        t_FieldReal score;
        END;
        // End Analytic result structures

        // Clustering structures required by cluster analysis methods (See Analysis.ecl)
        /**
        * ClusterLabels format defines the distance space where
        * each cluster defined by a center and its closest samples.
        * It is the same as KMeans.Types.KMeans_Model.Labels.
        *
        * @field  wi      The model identifier.
        * @field  id      The sample identifier.
        * @field  label   The identifier of the closest center to the sample.
        */
        EXPORT ClusterLabels := RECORD
        t_Work_Item wi;      // Model Identifier
        t_RecordID  id;      // Sample Identifier
        t_RecordID  label;   // Center Identifier
        END;
        // End Clustering structures

        // Data diagnostic definition
        EXPORT Data_Diagnostic := RECORD
        t_work_item wi;
        BOOLEAN valid;                 // Flag indicating failure of ANY diagnostic tests for wi
        SET OF VARSTRING message_text; // List of failed diagnostic tests for a wi
        END;

        /**
        * Field_Mapping is the format produced by ToField for field-name mapping.
        *
        * @field orig_name The name of the field in the original layout
        * @field assigned_name The integer field number used in the ML algorithm stored as a STRING
        *
        */
        EXPORT Field_Mapping := RECORD
        STRING orig_name;      // The name of the field in the original layout
        STRING assigned_name;  // The integer field number used in the ML algorithm
        END;
        /**
        * LUCI Record -- A dataset of lines each containing a string
        * This is the DATASET format in which ML algorithm export LUCI files.
        *
        * @field line A single line in the LUCI csv file
        *
        */
        EXPORT LUCI_Rec := RECORD
        STRING line;
        END;
        /**
        * Classification_Scores
        *
        * The probability or confidence, per class, that a sample belongs to that class.
        *
        * @field wi The work-item identifier.
        * @field id The record-id of the sample.
        * @field classifier The field number associated with this dependent variable, for
        *                   multi-variate. Otherwise 1.
        * @field class The class label.
        * @field prob The percentage of trees that assigned this class label,
        *             which is a rough stand-in for the probability that the label
        *             is correct.
        */
        EXPORT Classification_Scores := RECORD
        t_Work_Item wi;
        t_RecordID id;
        t_FieldNumber classifier;
        t_Discrete class;
        t_FieldReal prob;
        END;
        END;&amp;#10;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;analysis&quot;
        name=&quot;Analysis&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Analysis.ecl&quot;
        ts=&quot;1621960335000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2018 HPCC Systems®.  All rights reserved.
        ############################################################################## */
        IMPORT $ AS ML_Core;
        IMPORT ML_Core.Types;
        IMPORT ML_Core.Math;

        DiscreteField := Types.DiscreteField;
        NumericField := Types.NumericField;
        t_Work_Item := Types.t_Work_Item;
        t_RecordId := Types.t_RecordId;
        t_FieldNumber := Types.t_FieldNumber;
        t_FieldReal := Types.t_FieldReal;
        t_Discrete := Types.t_Discrete;
        Class_Stats := Types.Class_Stats;
        Confusion_Detail := Types.Confusion_Detail;
        Classification_Accuracy := Types.Classification_Accuracy; // Return structure for
        // Classification.Accuracy
        Class_Accuracy := Types.Class_Accuracy; // Return structure for Classification.AccuracyByClass
        Regression_Accuracy := Types.Regression_Accuracy; // Return structure for Regression.Accuracy
        Contingency_Table := Types.Contingency_Table; // Return structure for FeatureSelection.Contingency
        Chi2_Result := Types.Chi2_Result; // Return structure for FeatureSelection.Chi2
        ClusterLabels := Types.ClusterLabels; // Parameter structure for Clustering.ARI
        ARI_Result := Types.ARI_Result; // Return structure for Clustering.ARI
        SampleSilhouette_Result := Types.SampleSilhouette_Result; // Return structure for Clustering.SampleSilhouetteScore
        Silhouette_Result := Types.Silhouette_Result; // Return structure for Clustering.SilhouetteScore
        AUC_Result := Types.AUC_Result; // Return structure for Classification.AUC
        Classification_Scores := Types.Classification_Scores; // Parameter structure for Classification.AUC

        /**
        * Analyze and assess the effectiveness of a Machine
        * Learning model.
        * &amp;lt;p&amp;gt;Sub-modules provide support for both Classification and Regression.
        *
        * &amp;lt;p&amp;gt;Each of the functions in this module support multi-work-item (i.e. Myriad interface) data, as well as
        * multi-variate data (supported by some ML bundles).  The number field, which is usually
        * = 1 for uni-variate data is used to distinguish multiple regressors in the case of multi-
        * variate models.
        *
        **/
        EXPORT Analysis := MODULE
        /**
        * This sub-module provides functions for analyzing and assessing the effectiveness of
        * an ML Classification model.  It can be used with any ML Bundle that supports classification.
        */
        EXPORT Classification := MODULE
        /**
        * Given a set of expected dependent values, assess the number and percentage of records that
        * were of each class.
        *
        * @param actual The set of training-data or test-data dependent values in DATASET(DiscreteField)
        *               format.
        * @return DATASET(Class_Stats), one record per work-item, per classifier (i.e. number field) per
        *         class.
        * @see ML_Core.Types.Class_Stats
        **/
        EXPORT DATASET(Class_Stats) ClassStats(DATASET(DiscreteField) actual) := FUNCTION
        // Returns for each class: label, count, pct
        recStats := TABLE(actual, {wi, number, cnt := COUNT(GROUP)}, wi, number);
        cStats := TABLE(actual, {wi, number, value, cnt := COUNT(GROUP)}, wi, number, value);
        outStats := JOIN(cStats, recStats, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number,
        TRANSFORM(Class_Stats,
        SELF.classifier := LEFT.number,
        SELF.class := LEFT.value,
        SELF.classCount := LEFT.cnt,
        SELF.classPct := LEFT.cnt / RIGHT.cnt,
        SELF := LEFT), LOOKUP);
        RETURN outStats;
        END; // ClassStats
        // Function to compare predicted and actual values and include them in a record set containing both,
        // as well as a &amp;apos;correct&amp;apos; indicator, which is TRUE whenever the two match.
        SHARED CompareClasses(DATASET(DiscreteField) predicted, DATASET(DiscreteField) actual) := FUNCTION
        // Distribute predicted and actual by HASH32(wi, id)
        predD := DISTRIBUTE(predicted, HASH32(wi, id));
        actD := DISTRIBUTE(actual, HASH32(wi, id));
        cmp := JOIN(predD, actD, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number AND LEFT.id = RIGHT.id,
        TRANSFORM({t_Work_Item wi, t_FieldNumber number, t_Discrete pred, t_discrete actual, BOOLEAN correct},
        SELF.pred := LEFT.value,
        SELF.actual := RIGHT.value,
        SELF.correct := LEFT.value = RIGHT.value,
        SELF := LEFT), LOCAL);
        // cmp is distributed by HASH32(wi, id)
        RETURN cmp;
        END; // CompareClasses
        /**
        * Returns the Confusion Matrix, counting the number of cases for each combination of predicted Class and
        * actual Class.
        *
        * @param predicted The predicted values for each id in DATASET(DiscreteField) format.
        * @param actual The actual (i.e. expected) values for each id in DATASET(DiscreteField) format.
        * @return DATASET(Confusion_Detail).  One record for each combination of work-item, number (i.e. classifier),
        *         predicted class, and actual class.
        * @see ML_Core.Types.Confusion_Detail
        *
        **/
        EXPORT DATASET(Confusion_Detail) ConfusionMatrix(DATASET(DiscreteField) predicted, DATASET(DiscreteField) actual) := FUNCTION
        cmp := CompareClasses(predicted, actual);
        // Count the number of samples that were actually of each class
        actualClassTots := TABLE(cmp, {wi, number, actual, tot := COUNT(GROUP)}, wi, number, actual);
        // Count the number of samples that were predicted for each class
        predClassTots := TABLE(cmp, {wi, number, pred, tot := COUNT(GROUP)}, wi, number, pred);
        // Count the number of samples for each combination of actual and predicted
        cm0 := TABLE(cmp, {wi, t_FieldNumber classifier := number,
        t_Discrete actual_class := actual, t_Discrete predict_class := pred,
        UNSIGNED4 occurs := COUNT(GROUP), BOOLEAN correct := pred = actual}, wi, number, actual, pred);
        // Now calculate the proportions (of both actual and predicted values for each combination)
        cm1 := JOIN(cm0, actualClassTots, LEFT.wi = RIGHT.wi AND LEFT.classifier = RIGHT.number
        AND LEFT.actual_class = RIGHT.actual,
        TRANSFORM({RECORDOF(LEFT), t_FieldReal pctActual},
        SELF.pctActual := LEFT.occurs / RIGHT.tot,
        SELF := LEFT), LOOKUP);
        cm2 := JOIN(cm1, predClassTots, LEFT.wi = RIGHT.wi AND LEFT.classifier = RIGHT.number
        AND LEFT.predict_class = RIGHT.pred,
        TRANSFORM({RECORDOF(LEFT), t_FieldReal pctPred},
        SELF.pctPred := LEFT.occurs / RIGHT.tot,
        SELF := LEFT), LOOKUP);
        cm := PROJECT(cm2, Confusion_Detail);
        RETURN cm;
        END; // ConfusionMatrix
        /**
        * Assess the overall accuracy of the classification predictions.
        *
        * &amp;lt;p&amp;gt;ML_Core.Types.Classification_Accuracy provides a detailed description of the return values.
        *
        * @param predicted The predicted values for each id in DATASET(DiscreteField) format.
        * @param actual The actual (i.e. expected) values for each id in DATASET(DiscreteField) format.
        * @return DATASET(Classification_Accuracy).  One record for each combination of work-item, and
        *         number (i.e. classifier).
        * @see ML_Core.Types.Classification_Accuracy
        *
        **/
        EXPORT DATASET(Classification_Accuracy) Accuracy(DATASET(DiscreteField) predicted, DATASET(DiscreteField) actual) := FUNCTION
        // Returns Raw, PoD, PoDE
        cStats := ClassStats(actual);
        numClasses := TABLE(cStats, {wi, classifier, UNSIGNED4 num_classes := COUNT(GROUP)}, wi, classifier);
        mostCommon0 := SORT(cStats, wi, classifier, -classCount);
        mostCommon := DEDUP(mostCommon0, wi, classifier);
        globStats := JOIN(numClasses, mostCommon, LEFT.wi = RIGHT.wi AND LEFT.classifier = RIGHT.classifier,
        TRANSFORM({numClasses, UNSIGNED4 highestCnt},
        SELF.highestCnt := RIGHT.classCount,
        SELF := LEFT));
        cmp := CompareClasses(predicted, actual);
        cmpStats := TABLE(cmp, {wi, number, UNSIGNED4 corrCnt := COUNT(GROUP, correct), UNSIGNED4 totCnt := COUNT(GROUP)}, wi, number);
        outStats := JOIN(cmpStats, globStats, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.classifier,
        TRANSFORM(Classification_Accuracy,
        SELF.classifier := LEFT.number,
        SELF.errCnt := LEFT.totCnt - LEFT.corrCnt,
        SELF.recCnt := LEFT.totCnt,
        SELF.Raw_accuracy := LEFT.corrCnt / LEFT.totCnt,
        SELF.PoD := (LEFT.corrCnt -  LEFT.totCnt / RIGHT.num_classes) /
        (LEFT.totCnt - LEFT.totCnt / RIGHT.num_classes),
        SELF.PoDE := (LEFT.corrCnt - RIGHT.highestCnt) /
        (LEFT.totCnt - RIGHT.highestCnt),
        SELF.Hamming_Loss := SELF.errCnt / LEFT.totCnt,
        SELF := LEFT), LOOKUP);
        RETURN outStats;
        END; // Accuracy
        /**
        * Provides per class accuracy / relevance statistics (e.g. Precision / Recall,
        * False-positive Rate).
        *
        * &amp;lt;p&amp;gt;ML_Core.Types.Class_Accuracy provides a detailed description of the return values.
        *
        * @param predicted The predicted values for each id in DATASET(DiscreteField) format.
        * @param actual The actual (i.e. expected) values for each id in DATASET(DiscreteField) format.
        * @return DATASET(Class_Accuracy).  One record for each combination of work-item, number (i.e. classifier),
        *         and class.
        * @see ML_Core.Types.Class_Accuracy
        *
        **/
        EXPORT DATASET(Class_Accuracy) AccuracyByClass(DATASET(DiscreteField) predicted, DATASET(DiscreteField) actual) := FUNCTION
        // Returns Precision, Recall, False Positive Rate(FPR)
        allClasses0 := SORT(actual, wi, number, value);
        allClasses := DEDUP(actual, wi, number, value);
        cmp := CompareClasses(predicted, actual);
        // For each class, replicate all of the items not of that class so that we can analyze that class
        // with respect to its non-members (i.e. negatives).
        allClassPts := JOIN(cmp, allClasses, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number,
        TRANSFORM({cmp, UNSIGNED class},
        SELF.class := RIGHT.value,
        SELF := LEFT), MANY, LOOKUP);
        allClassSumm := TABLE(allClassPts, {wi, number, class,
        UNSIGNED4 precDenom := COUNT(GROUP, pred = class),
        UNSIGNED4 TP := COUNT(GROUP, pred = class AND actual = class),
        UNSIGNED4 FP := COUNT(GROUP, pred = class AND actual != class),
        UNSIGNED4 recallDenom := COUNT(GROUP, actual = class),
        UNSIGNED4 TN := COUNT(GROUP, actual != class AND pred != class),
        UNSIGNED4 FN := COUNT(GROUP, actual = class AND pred != class),
        }, wi, number, class);
        cStats := PROJECT(allClassSumm, TRANSFORM(Class_Accuracy,
        SELF.classifier := LEFT.number,
        SELF.precision := LEFT.TP / (LEFT.TP + LEFT.FP),
        SELF.recall := LEFT.TP / (LEFT.TP + LEFT.FN),
        SELF.FPR := LEFT.FP / (LEFT.FP + LEFT.TN),
        SELF.f_score := 2 * (SELF.precision * SELF.recall) / (SELF.precision + SELF.recall),
        SELF := LEFT));
        RETURN cStats;
        END; // AccuracyByClass
        /**
        * AUC
        *
        * Area under the Receiver Operating Characteristics (ROC) curve, is a measure of
        * how well a classifier is able to distinguish between classes. The ROC curve is
        * a plot of the true positive rate vs. the false positive rate with varying threshold
        * values.
        *
        * The value of this metric ranges from 0 to 1. Higher values are an indication of better
        * classifiers.
        *
        * @param scores The probability or confidence per class that a sample belongs to that class in
        *               DATASET(Classification_Scores) format
        * @param actual The actual class to which a sample belongs in DATASET(DiscreteField) format
        * @return DATASET(AUC_Result) The AUC score, per class, per classifier, per work item
        * @see ML_Core.Types.AUC_Result, ML_Core.Types.Classification_Score
        *
        **/
        EXPORT DATASET(AUC_Result) AUC(DATASET(Classification_Scores) scores, DATASET(DiscreteField) actual) := FUNCTION
        // Create a set of all classes (per classifier, per work item)
        classes := TABLE(actual, {wi, number, value}, wi, number, value);
        // Combine the actual labels and their probabilities
        // The actual labels are joined with a set of all classes, where each sample is matched with all classes
        // in which the selected label is marked isTrue, and the probabilities are obtained from scores. When a
        // score is not available, its probability is taken as 0.
        combined := JOIN(actual, classes,
        LEFT.wi = RIGHT.wi and
        LEFT.number = RIGHT.number,
        TRANSFORM({RECORDOF(scores), BOOLEAN isTrue},
        SELF.wi := LEFT.wi,
        SELF.id := LEFT.id,
        SELF.classifier := LEFT.number,
        SELF.class := RIGHT.value,
        SELF.prob := 0,
        SELF.isTrue := IF(LEFT.value=RIGHT.value, TRUE, FALSE)));
        // Combining with scores to populate the probability field. LEFT OUTER is used in the JOIN condition to
        // ensure that all classes are included.
        combined2 := JOIN(combined, scores,
        LEFT.wi = RIGHT.wi and
        LEFT.classifier = RIGHT.classifier and
        LEFT.id = RIGHT.id and
        LEFT.class = RIGHT.class,
        TRANSFORM({RECORDOF(combined)},
        SELF.prob := RIGHT.prob,
        SELF := LEFT), LEFT OUTER);
        // Dataset of all pairs of positive and negative points per, class, per classifier, per work item.
        // Only positive samples are taken from the left set and negative samples are taken from the right.
        // If the score of the left sample is greater than the right sample, it is considered correct
        // and hence marked 1. If the left score is smaller than that of the right, it is considered
        // incorrect and marked 0. It they are equal, it is marked 0.5.
        pairs := JOIN(combined2, combined2,
        LEFT.wi=RIGHT.wi and
        LEFT.classifier=RIGHT.classifier and
        LEFT.class=RIGHT.class and
        LEFT.isTrue = TRUE and
        RIGHT.isTrue = FALSE,
        TRANSFORM({t_Work_Item wi, t_FieldNumber classifier, t_Discrete class, REAL value},
        SELF.wi := LEFT.wi,
        SELF.classifier := LEFT.classifier,
        SELF.class := LEFT.class,
        SELF.value := IF(LEFT.prob = RIGHT.prob, 0.5, IF(LEFT.prob &amp;gt; RIGHT.prob, 1, 0))));
        // The average of these marked scores gives the probability that a random positive sample is scored
        // higher than a random negative sample which is equal to AUC
        RETURN TABLE(pairs,{wi,classifier,class,auc:=AVE(GROUP,value)},wi,classifier,class);
        END; // AUC
        END; // Classification
        /**
        * This sub-module provides functions for analyzing and assessing the effectiveness of
        * an ML Regression model.  It can be used with any ML Bundle that supports regression.
        *
        */
        EXPORT Regression := MODULE
        /**
        * Assess the overall accuracy of the regression predictions.
        *
        * &amp;lt;p&amp;gt;ML_Core.Types.Regression_Accuracy provides a detailed description of the return values.
        *
        * @param predicted The predicted values for each id in DATASET(DiscreteField) format.
        * @param actual The actual (i.e. expected) values for each id in DATASET(DiscreteField) format.
        * @return DATASET(Regression_Accuracy).  One record for each combination of work-item, and
        *         number (i.e. regressor).
        * @see ML_Core.Types.Regression_Accuracy
        *
        **/
        EXPORT DATASET(Regression_Accuracy) Accuracy(DATASET(NumericField) predicted, DATASET(NumericField) actual) := FUNCTION
        // Returns R-squared, MSE, RMSE
        meanAct := TABLE(actual, {wi, number, REAL mean := AVE(GROUP, value), cnt := COUNT(GROUP)}, wi, number);
        cmp := JOIN(actual, predicted, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number AND LEFT.id = RIGHT.id,
        TRANSFORM({t_Work_Item wi, t_FieldNumber number, t_FieldReal actual, t_FieldReal pred},
        SELF.actual := LEFT.value,
        SELF.pred := RIGHT.value,
        SELF := LEFT));
        calc0 := JOIN(cmp, meanAct, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number,
        TRANSFORM({cmp, REAL ts, REAL rs},
        SELF.ts := POWER(LEFT.actual - RIGHT.mean, 2), // Total squared
        SELF.rs := POWER(LEFT.actual - LEFT.pred, 2),  // Residual squared
        SELF := LEFT), LOOKUP);
        // R2 := 1 - (Residual Sum of Squares / Total Sum of Squares)
        calc1 := TABLE(calc0, {wi, number, R2 := 1 - SUM(GROUP, rs) / SUM(GROUP, ts), RSS := SUM(GROUP, rs)}, wi, number);
        result := JOIN(calc1, meanAct, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.number,
        TRANSFORM(Regression_Accuracy,
        SELF.MSE := LEFT.RSS / RIGHT.cnt,
        SELF.RMSE := POWER(SELF.MSE, .5),
        SELF.regressor := LEFT.number,
        SELF := LEFT), LOOKUP);
        RETURN result;
        END; // Accuracy
        END; // Regression
        /**
        * This sub module provides functions for assessing the features of a
        * dataset, to perform feature selection.
        */
        EXPORT FeatureSelection := MODULE
        /**
        * Contingency
        *
        * Provides the contingency table for each combination of feature and sample (classifier).
        * The contingency table represents the number of samples present in the data for each
        * combination of sample category and feature category. Can only be used when both
        * classifier and feature are discrete.
        *
        * The sets provided need not be sample / feature sets. They can be any two discrete
        * fields whose contingency table is needed.
        *
        * @param samples The samples or dependent values in DATASET(DiscreteField) format
        * @param features The features or independent values in DATASET(DiscreteField) format
        * @return DATASET(Contingency_Table) The contingency table for each combination of
        *         sample (classifier) and feature, per work item
        * @see ML_Core.Types.Contingency_Table
        *
        */
        EXPORT DATASET(Contingency_Table) Contingency(DATASET(DiscreteField) samples, DATASET(DiscreteField) features) := FUNCTION
        // To obtain the contingency tables, the samples and features are first combined into a
        // single table, with every feature mapped to every classifier
        combined := JOIN(samples, features,
        LEFT.wi=RIGHT.wi and LEFT.id=RIGHT.id,
        TRANSFORM({t_Work_Item wi, t_RecordId id, t_FieldNumber fnumber,
        t_FieldNumber snumber, t_Discrete fclass, t_Discrete sclass},
        SELF.wi := LEFT.wi,
        SELF.id := LEFT.id,
        SELF.fnumber := RIGHT.number,
        SELF.snumber := LEFT.number,
        SELF.fclass := RIGHT.value,
        SELF.sclass := LEFT.value));
        // This combined data is then grouped to obtain the contingency tables
        result := TABLE(combined, {wi,fnumber,snumber,fclass,sclass,cnt:=COUNT(GROUP)},
        wi,fnumber,snumber,fclass,sclass);
        RETURN result;
        END; //Contingency
        /**
        * Chi2
        *
        * Provides Chi2 coefficient and number of degrees of freedom for each combination
        * of feature and classifier.
        *
        * Chi squared test is a statistical measure that helps establish the dependence of
        * two categorical variables. In machine learning, it can be used to determine whether
        * a classifier is dependent on a certain feature, and thus helps in feature selection.
        * This test can only be used when both variables are categorical.
        *
        * @param samples The samples or dependent values in DATASET(DiscreteField) format
        * @param features The features or independent values in DATASET(DiscreteField) format
        * @return DATASET(Chi2_Result) Chi square values and degrees of freedom for each
        *         combination of feature and classifier, per work item.
        * @see ML_Core.Types.Chi2_Result
        *
        **/
        EXPORT DATASET(Chi2_Result) Chi2(DATASET(DiscreteField) features, DATASET(DiscreteField) samples) := FUNCTION
        ct := Contingency(samples, features);
        // Sums of rows
        featureSums := TABLE(ct, {wi,fnumber,snumber,fclass,c:=SUM(GROUP,cnt)},wi,fnumber,snumber,fclass);
        // Sums of columns
        sampleSums := TABLE(ct, {wi,fnumber,snumber,sclass,c:=SUM(GROUP,cnt)},wi,fnumber,snumber,sclass);
        // Total sum
        allSum := TABLE(ct, {wi,fnumber,snumber,c:=SUM(GROUP,cnt)},wi,fnumber,snumber);
        // The expected contingency table from the above sums (1)
        ex1 := JOIN(featureSums, sampleSums,
        LEFT.wi=RIGHT.wi and LEFT.fnumber=RIGHT.fnumber and LEFT.snumber=RIGHT.snumber,
        TRANSFORM({t_Work_Item wi, t_FieldNumber fnumber, t_FieldNumber snumber,
        t_Discrete fclass, t_Discrete sclass, REAL8 value},
        SELF.wi := LEFT.wi,
        SELF.value := LEFT.c * RIGHT.c,
        SELF.fnumber := LEFT.fnumber,
        SELF.snumber := LEFT.snumber,
        SELF.fclass := LEFT.fclass,
        SELF.sclass := RIGHT.sclass));
        // The expected contingency table from the above sums (2)
        ex2 := JOIN(ex1, allSum,
        LEFT.wi=RIGHT.wi and LEFT.fnumber=RIGHT.fnumber and LEFT.snumber=RIGHT.snumber,
        TRANSFORM(RECORDOF(ex1),
        SELF.value := LEFT.value/RIGHT.c,
        SELF := LEFT));
        // Degrees of freedom calculation dof = (ROWS - 1)*(COLS - 1)
        // Number of rows
        dof1 := TABLE(featureSums, {wi,fnumber,snumber,dof:=COUNT(GROUP)-1}, wi, fnumber,snumber);
        // Number of cols
        dof2 := TABLE(sampleSums, {wi,fnumber,snumber,dof:=COUNT(GROUP)-1}, wi, fnumber,snumber);
        // DOF
        dof3 := JOIN(dof1,dof2,
        LEFT.wi=RIGHT.wi and
        LEFT.fnumber=RIGHT.fnumber and
        LEFT.snumber=RIGHT.snumber,
        TRANSFORM(RECORDOF(dof1),
        SELF.dof := LEFT.dof*RIGHT.dof,
        SELF := LEFT));
        // Chi square calculation from expected and observed contingency tables.
        // LEFT OUTER JOIN flag is used as the contingency table does not contain entries for
        // combinations where no samples are available. The expected contingency table contains
        // entries for all combinations of sample and feature classes, hence the OUTER condition
        // is used to produce entries for all combinations of sample and feature classes.
        chi2_1 := JOIN(ex2, ct,
        LEFT.wi=RIGHT.wi and
        LEFT.fnumber=RIGHT.fnumber and
        LEFT.snumber=RIGHT.snumber and
        LEFT.fclass=RIGHT.fclass and
        LEFT.sclass=RIGHT.sclass,
        TRANSFORM(RECORDOF(ex2),
        SELF.value := POWER(RIGHT.cnt-LEFT.value,2)/LEFT.value,
        SELF := LEFT), LEFT OUTER);
        // Group by wi, fnumber, snumner
        chi2_2 := TABLE(chi2_1, {wi,fnumber,snumber,x2:=SUM(GROUP,value)},wi,fnumber,snumber);
        // Combine with calculated dof
        result := JOIN(chi2_2, dof3,
        LEFT.wi=RIGHT.wi and
        LEFT.fnumber=RIGHT.fnumber and
        LEFT.snumber=RIGHT.snumber,
        TRANSFORM(Chi2_Result,
        SELF.wi := LEFT.wi,
        SELF.fnumber := LEFT.fnumber,
        SELF.snumber := LEFT.snumber,
        SELF.dof := RIGHT.dof,
        SELF.x2 := LEFT.x2,
        SELF.p := 1 - Math.Distributions.Chi2_CDF(LEFT.x2, RIGHT.dof)));
        RETURN result;
        END; //Chi2
        END; // FeatureSelection
        /**
        * This sub module provides various tests that help evaluate the effectiveness of clustering
        * algorithms.
        */
        EXPORT Clustering := MODULE
        /**
        * ARI
        *
        * The Rand index is a measure of the similarity between
        * two data clusterings. Adjusted Rand Index (ARI) is a
        * version of rand index which is corrected for chance.
        * This measure assumes values between -1 and 1. It produces values close to zero
        * for random clusterings, values close to 1 for good clusterings
        * and values close to -1 for clusterings that are worse than random guesses.
        *
        * @param predicted The labels predicted by the model in DATASET(ClusteringLabels) Format
        * @param actual The actual labels, or the &amp;apos;Ground Truth&amp;apos; in DATASET(ClusteringLabels) Format
        * @return DATASET(ARI_Result) The adjusted rand index per work item
        * @see ML_Core.Types.ClusterLabels, ML_Core.Types.ARI_Result
        *
        **/
        EXPORT DATASET(ARI_Result) ARI(DATASET(ClusterLabels) predicted, DATASET(ClusterLabels) actual) := FUNCTION
        // Convert input parameter to DiscreteField to use as input for contingency
        conv1 := PROJECT(predicted, TRANSFORM(Types.DiscreteField,
        SELF.wi := LEFT.wi,
        SELF.number := 1,
        SELF.id := LEFT.id,
        SELF.value := LEFT.label));

        conv2 := PROJECT(actual, TRANSFORM(Types.DiscreteField,
        SELF.wi := LEFT.wi,
        SELF.number := 1,
        SELF.id := LEFT.id,
        SELF.value := LEFT.label));
        // Get contingency table
        ct := FeatureSelection.contingency(conv1, conv2);
        // Produce the sums required for computation of ARI
        // Row sums choose 2 (Number of pair combinations i.e nC2)
        rowSumsC2 := TABLE(ct, {wi, fclass, c:=SUM(GROUP,cnt)*(SUM(GROUP,cnt)-1)/2}, wi, fclass);
        // Column sums choose 2
        colSumsC2 := TABLE(ct, {wi, sclass, c:=SUM(GROUP,cnt)*(SUM(GROUP,cnt)-1)/2}, wi, sclass);
        // Total sum choose 2
        allSumC2 := TABLE(ct, {wi, REAL8 value:=SUM(GROUP,cnt)*(SUM(GROUP,cnt)-1)/2}, wi);
        // Sum of obtained row sums
        a := TABLE(rowSumsC2, {wi, REAL8 value:=SUM(GROUP,c)}, wi);
        // Sum of obtained column sums
        b := TABLE(colSumsC2, {wi, REAL8 value:=SUM(GROUP,c)}, wi);
        // Convert all items &amp;apos;n&amp;apos; of contingency table to &amp;apos;nC2&amp;apos;
        ct1 := PROJECT(ct, TRANSFORM(RECORDOF(ct),
        SELF.cnt := LEFT.cnt*(LEFT.cnt-1)/2,
        SELF := LEFT));
        // Sums of combinations of diagonal elements, obtained from above
        nij := TABLE(ct1, {wi, REAL8 value:=SUM(GROUP,cnt)}, wi);
        // Check for trivial cases for each work item
        n_samples := TABLE(ct, {wi, INTEGER value:=SUM(GROUP,cnt)});
        n_classes0 := TABLE(actual, {wi, label}, wi, label);
        n_classes := TABLE(n_classes0, {wi, INTEGER value:=COUNT(GROUP)}, wi);
        n_clusters0 := TABLE(predicted, {wi, label}, wi, label);
        n_clusters := TABLE(n_clusters0, {wi, INTEGER value:=COUNT(GROUP)}, wi);
        // Criterion for checking --
        // n_classess = n_clusters = 1 or
        // n_classess = n_clusters = 0 or
        // n_classess = n_clusters = n_samples
        isTrivial := JOIN(n_classes, n_clusters,
        LEFT.wi = RIGHT.wi,
        TRANSFORM({t_Work_Item wi, INTEGER a, INTEGER b,
        INTEGER c, BOOLEAN value},
        SELF.wi := LEFT.wi,
        SELF.a := n_samples(wi = SELF.wi)[1].value,
        SELF.b := LEFT.value,
        SELF.c := RIGHT.value,
        SELF.value := IF(((SELF.b = SELF.c AND
        (SELF.b = 1 OR SELF.b = 0)) OR
        (SELF.b = SELF.c AND
        SELF.c = SELF.a)),
        TRUE, FALSE)));
        // Compute ARI using information obtained
        ari := JOIN([a,b,nij,allSumC2],
        LEFT.wi = RIGHT.wi,
        TRANSFORM({t_Work_Item wi, INTEGER a, INTEGER b,
        INTEGER nij, INTEGER n, t_FieldReal value},
        SELF.wi := LEFT.wi,
        SELF.a := ROWS(LEFT)[1].value,
        SELF.b := ROWS(LEFT)[2].value,
        SELF.nij := ROWS(LEFT)[3].value,
        SELF.n := ROWS(LEFT)[4].value,
        SELF.value := IF(isTrivial(wi = SELF.wi)[1].value, 1,
        (SELF.nij - SELF.a*SELF.b/SELF.n)/
        (0.5*(SELF.a + SELF.b) - SELF.a*SELF.b/SELF.n))),
        SORTED(wi));
        // Remove unnecessary fields
        ari1 := TABLE(ari,{wi,value});
        RETURN ari1;
        END; // ARI
        /**
        * SampleSilhouetteScore
        *
        * Silhouette analysis measures the closeness of a point, both with its assigned cluster
        * and with other clusters. It provides an easy way of finding the optimum value for
        * k during k-means clustering. Silhouette values lie in the range of (-1, 1). A value of +1
        * indicates that the sample point is far away from its neighboring cluster and very
        * close to the cluster to which it is assigned.
        *
        * The euclidian distance metric is used to measure the distances between points.
        *
        * @param samples The datapoints / independent data in DATASET(NumericField) format
        * @param labels The labels assigned to these datapoints in DATASET(ClusterLabels) format
        * @result DATASET(SampleSilhouette_Result) The silhouette coefficient per sample, per work item
        * @see ML_Core.Types.SampleSilhouette_Result
        *
        */
        EXPORT DATASET(SampleSilhouette_Result) SampleSilhouetteScore(DATASET(NumericField) samples,
        DATASET(ClusterLabels) labels) := FUNCTION
        // Combine labels and samples
        points := JOIN(samples, labels,LEFT.wi = RIGHT.wi and LEFT.id = RIGHT.id);
        // Finding a values
        // Create all pairs of points with same cluster
        // ( Also calculate squared distance between their individual features as a
        //   step to calculate the distance between them )
        a1 := JOIN(points,points,
        LEFT.wi=RIGHT.wi and
        LEFT.number=RIGHT.number and
        LEFT.id &amp;lt;&amp;gt; RIGHT.id and
        LEFT.label=RIGHT.label,
        TRANSFORM({t_Work_Item wi, t_RecordId id1, t_RecordId id2,
        t_RecordId number, t_RecordId label, t_FieldReal sq_diff},
        SELF.wi := LEFT.wi,
        SELF.id1 := LEFT.id,
        SELF.id2 := RIGHT.id,
        SELF.number := LEFT.number,
        SELF.label := LEFT.label,
        SELF.sq_diff := POWER(LEFT.value-RIGHT.value,2)));
        // Find distance between these points
        a2 := TABLE(a1, {wi,id1,id2,label,dist:=SQRT(SUM(GROUP,sq_diff))},wi,id1,id2,label);
        // Find average distance for each point
        a3 := TABLE(a2, {wi, id:=id1, label,value:=AVE(GROUP,dist)}, wi,id1,label);
        // Finding b values
        // Form all pairs of points from different clusters
        // (Also calculate the squared difference between individual features)
        b1 := JOIN(points,points,
        LEFT.wi=RIGHT.wi and
        LEFT.number=RIGHT.number and
        LEFT.id &amp;lt;&amp;gt; RIGHT.id and
        LEFT.label &amp;lt;&amp;gt; RIGHT.label,
        TRANSFORM({t_Work_Item wi, t_RecordId id1, t_RecordId id2, t_RecordId Llabel,
        t_RecordId number, t_RecordId Rlabel, t_FieldReal sq_diff},
        SELF.wi := LEFT.wi,
        SELF.id1 := LEFT.id,
        SELF.id2 := RIGHT.id,
        SELF.number := LEFT.number,
        SELF.Llabel := LEFT.label,
        SELF.Rlabel := RIGHT.label,
        SELF.sq_diff := POWER(LEFT.value-RIGHT.value,2)));
        // Find distance between these pairs
        b2 := TABLE(b1,
        {wi,id1,id2,Llabel,Rlabel,dist:=SQRT(SUM(GROUP,sq_diff))},
        wi,id1,id2,Llabel,Rlabel);
        // Average these to find average distance of each point from every cluster
        b3 := TABLE(b2,
        {wi,id:=id1,Llabel,Rlabel,avgDist:=AVE(GROUP,dist)},
        wi,id1,Llabel,Rlabel);
        // Find minimum to get the minimum average distance to another cluster
        // for each point, which is the b value
        b4 := TABLE(b3,
        {wi,id,label:=Llabel,value:=MIN(GROUP,avgDist)},
        wi,id,Llabel);
        // The Silhouette coefficient / score for each sample datapoint
        sampleCoeffs := JOIN(a3,b4,
        LEFT.id=RIGHT.id and LEFT.wi=RIGHT.wi,
        TRANSFORM({t_Work_Item wi, t_RecordId id, t_RecordId label, t_FieldReal value},
        SELF.wi := LEFT.wi,
        SELF.id := LEFT.id,
        SELF.label := LEFT.label,
        SELF.value := (RIGHT.value-LEFT.value)/MAX(RIGHT.value,LEFT.value)));
        // Remove unnecessary fields
        sampleCoeffs2 := TABLE(sampleCoeffs,{wi,id,value});
        // Find single clusters
        singleClusters := TABLE(points,{wi, label, cnt:=COUNT(GROUP)}, wi,label)(cnt=1);
        // Silhouette coefficients for these clusters = 1
        singleCoeffs := JOIN(points, singleClusters,
        LEFT.wi=RIGHT.wi and
        LEFT.label=RIGHT.label,
        TRANSFORM({t_Work_Item wi, t_RecordId id, t_FieldReal value},
        SELF.wi := LEFT.wi,
        SELF.id := LEFT.id,
        SELF.value := 1));
        // Combine all scores
        result := MERGE([sampleCoeffs2, singleCoeffs], SORTED(wi,id,value));
        RETURN result;
        END; // SampleSilhouetteScore
        /**
        * SilhouetteScore
        *
        * Silhouette analysis measures the closeness of a point, both with its assigned cluster
        * and with other clusters. It provides an easy way of finding the optimum value for
        * k during k-means clustering. Silhouette values lie in the range of (-1, 1). A value of +1
        * indicates that the sample point is far away from its neighboring cluster and very
        * close to the cluster to which it is assigned.
        *
        * The euclidian distance metric is used to measure the distances between points.
        *
        * This function produces an average over SampleSilhouetteScore
        *
        * @param samples The datapoints / independent data in DATASET(NumericField) format
        * @param labels The labels assigned to these datapoints in DATASET(ClusterLabels) format
        * @result DATASET(Silhouette_Result) The silhouette coefficient per work item
        * @see ML_Core.Types.SampleSilhouette_Result, ML_Core.Analysis.SampleSilhouetteScore
        *
        */
        EXPORT DATASET(Silhouette_Result) SilhouetteScore(DATASET(NumericField) samples, DATASET(ClusterLabels) labels) := FUNCTION
        sampleCoeffs := SampleSilhouetteScore(samples,labels);
        totalCoeffs := TABLE(sampleCoeffs, {wi,score:=AVE(GROUP,value)}, wi);
        RETURN totalCoeffs;
        END; // SilhouetteScore
        END; // Clustering
        END; // Analysis&amp;#10;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;constants&quot;
        name=&quot;Constants&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Constants.ecl&quot;
        ts=&quot;1621960335000000&quot;&gt;
        /**
        * Useful constants used in ML.
        */
        EXPORT Constants := MODULE
        /**
        * Constant PI
        */
        EXPORT Pi := 3.1415926535897932384626433;
        /**
        * Constant square root of 2
        */
        EXPORT Root_2 := 1.4142135623730950488016887;

        END;&amp;#10;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;modelops2&quot;
        name=&quot;ModelOps2&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/ModelOps2.ecl&quot;
        ts=&quot;1621960335000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
        ############################################################################## */
        IMPORT $ AS ML_Core;
        IMPORT ML_Core.Types;

        NumericField := Types.NumericField;
        Layout_Model2 := Types.Layout_Model2;
        t_indexes := Types.t_indexes;
        t_Work_Item := Types.t_Work_Item;
        t_FieldReal := Types.t_FieldReal;

        /**
        * This module provides a set of operations to provide manipulation of machine
        * learning models (version 2) in the Types.Layout_Model2 format.
        *
        * &amp;lt;p&amp;gt;Layout_Model2 defines a flexible structure that allows storage of model information for
        * any Machine Learning algorithm.
        *
        * &amp;lt;p&amp;gt;The model is based on a &amp;quot;Naming Tree&amp;quot; paradigm.
        *
        * &amp;lt;p&amp;gt;The naming tree is a data structure that allows a hierarchical name (e.g.
        * object-id) to be attached to each data-cell.  Examples of naming-trees are
        * OID trees such as those used in various network identifiers such as MIBs.
        *
        * &amp;lt;p&amp;gt;This structure is used within ML to store model information.  It is a
        * useful format for several reasons:&amp;lt;ul&amp;gt;
        * &amp;lt;li&amp;gt;It has the flexibility to store complex sets of data in a generic way.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;It easily stores scalar as well as matrix oriented data.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;It allows a model to contain data elements within scopes that are
        *   defined at different level.  For example, part of the model may be defined
        *   globally, another may be common for a bundle, while another section is
        *   specific to a given module.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;It readily allows composite models to be created by encapsulating
        *   entire complex models (or sets of models) within branches of another model.
        *   The individual models can then be extracted from the composite model, and
        *   passed to the modules that created them.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
        *
        * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Theory of Operation&amp;lt;/b&amp;gt;
        *
        * &amp;lt;p&amp;gt;The naming tree (NT) is conceptually simple.  Each cell is identified by a
        * hierarchical numbering scheme of arbitrary depth.  Take, for example, the following
        * NT:
        *&amp;lt;pre&amp;gt;
        * 1
        *   1.1
        *     1.1.1
        *     1.1.2
        *   1.2
        *     1.2.1
        *     1.2.2
        * 2
        *&amp;lt;/pre&amp;gt;
        * This tree defines the following leaf (scalar) elements: 1.1.1, 1.1.2, 1.2.1, 1.2.2, 2.
        * &amp;lt;p&amp;gt;Note that the deepest node on any branch is considered a leaf, and branches can be of
        * variable depth.  Note also that there is no explicit creation of branch nodes.  The
        * branches are implicitly defined by the ids of the leafs.
        * &amp;lt;p&amp;gt;In this example, node 1.1 can be thought as representing an array, thought it could
        * also be thought of as a structure of two distinct scalars, depending on whether the user
        * expects a variable length list under 1.1 (i.e. 1.1.1 - 1.1.N) or a fixed set of cells.
        * &amp;lt;p&amp;gt;Likewise node 1 can be thought of as a matrix (1.r.c, where r is the row index and c
        * is the column index), in cases where r and c are of variable size.
        *
        * &amp;lt;p&amp;gt;This naming tree also supports the myriad interface, allowing multiple independent
        * work-items to be represented, each of which may duplicate the same structure.
        *
        * &amp;lt;p&amp;gt;The id is represented by an ECL SET of Unsigned identifiers (e.g. [1,2,1] represents the OID 1.2.1).
        *
        * &amp;lt;p&amp;gt;Each cell is defined by three fields: wi (work-item-id), value (the cell contents) and
        * indexes (the id).
        * &amp;lt;p&amp;gt;A naming tree can be constructed as an inline dataset.  For example, the following
        * creates the tree in the example above:
        &amp;lt;pre&amp;gt;
        *   DATASET([{1, 3.2, [1,1,1]},
        *            {1, .0297, [1,1,2]},
        *            {1, 2.0, [1,2,1]},
        *            {1, 1550, [1,2,2]},
        *            {1, 8.1, [2]}], Layout_Model2);
        * &amp;lt;/pre&amp;gt;
        * &amp;lt;p&amp;gt;There are attributes in this module to assist with manipulation of naming trees:&amp;lt;ul&amp;gt;
        * &amp;lt;li&amp;gt;Creating a NT from a NumericField matrix.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;Extracting a NumericField matrix from an NT branch.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;Inserting an NT onto a branch of another NT.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;Extracting an NT from a branch of an NT.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
        *
        * @see Types.Layout_Model2
        */
        EXPORT ModelOps2 := MODULE
        SHARED empty_array := DATASET([], Layout_Model2);
        /**
        * Extract an inner sub-tree from an existing model.
        * &amp;lt;p&amp;gt;Work-item = 0 (default) will extract all work-items
        * &amp;lt;p&amp;gt;This is the opposite of Insert.
        *
        * For example:
        * &amp;lt;pre&amp;gt;
        * If I have a tree:
        *  1
        *  2
        *  3
        *   3.1
        *   3.2
        * &amp;lt;/pre&amp;gt;
        * and I extract from index 3, it will return the Naming Tree:
        * &amp;lt;pre&amp;gt;
        *  1
        *  2
        * &amp;lt;/pre&amp;gt;
        * &amp;lt;p&amp;gt;containing the two sub-cells of the original index 3
        *
        * @param mod The model from which to extract the sub-tree.
        * @param fromIndx The index from which to extract the subtree.
        * @param fromWi The work-item to extract or 0 to extract the same
        *               sub-tree from all work-items.
        * @return A model containing all of the sub-cells below fromIndx
        *         with the indexes adjusted to the top of the tree.
        *
        */
        EXPORT DATASET(Layout_Model2) Extract(DATASET(Layout_Model2) mod,
        t_indexes fromIndx, t_work_item fromWi=0) := FUNCTION
        Layout_Model2 extract_indexes(Layout_Model2 a, UNSIGNED prefixSize) := TRANSFORM
        outIndex := a.indexes[prefixSize+1.. ];
        SELF.indexes := outIndex;
        SELF         := a;
        END;
        prefixSize := COUNT(fromIndx);
        filter := mod.indexes[..prefixSize] = fromIndx AND (fromWi = 0 OR mod.wi = fromWi);
        outMod    := PROJECT(mod(filter), extract_indexes(LEFT, prefixSize));
        return outMod;
        END;
        /**
        * Extend the indices of a model to fit within a deeper model.
        *
        * &amp;lt;p&amp;gt;For example, a cell with index [1,2] could be moved to index [1,2,3,1,2]
        * by using atIndex := [1,2,3].
        *
        * @param mod The model whose indexes are to be extended.
        * @param atIndex The prefix indexes to be prepended to the indexes of each cell
        *                in mod.
        * @return A model with extended indexes.
        *
        */
        EXPORT DATASET(Layout_Model2) ExtendIndices(DATASET(Layout_Model2) mod, t_indexes atIndex) := FUNCTION
        Layout_Model2 extend_indexes(Layout_Model2 t) := TRANSFORM
        indxs := atIndex + t.indexes;
        SELF.indexes := indxs;
        SELF         := t;
        END;
        outMod := PROJECT(mod, extend_indexes(LEFT));
        return outMod;
        END;
        /**
        * Insert a model into a sub-tree of an existing model.
        *
        * &amp;lt;p&amp;gt;Extends the indexes of the provided model to fit onto a branch
        * of another model, and concatenates the two models. This is the opposite of
        * extract.
        * For example:
        * &amp;lt;pre&amp;gt;
        * If I have a model:
        * 1
        * 2
        * and a second model:
        * 1
        * 2
        * 3
        * That I would like to insert into the first tree at index 3, I would
        * end up with the tree:
        * 1
        * 2
        * 3
        *  3.1
        *  3.2
        *  3.3
        * &amp;lt;/pre&amp;gt;
        * Example code:
        * &amp;lt;pre&amp;gt;
        * mod3 := Insert(mod1, mod2, [3]);
        * &amp;lt;/pre&amp;gt;
        * @param mod1 The first (base) model.
        * @param mod2 The sub-model that is to be inserted into mod1.
        * @param atIndx The index prefix (in mod1) that will contain the cells from mod2.
        * @return a new model containing the cells from both models.
        *
        */
        EXPORT DATASET(Layout_Model2) Insert(DATASET(Layout_Model2) mod1, DATASET(Layout_Model2) mod2, t_indexes atIndx) := FUNCTION
        mod2a := ExtendIndices(mod2, atIndx);
        RETURN mod1 + mod2a;
        END;
        /**
        * Convert a two-level model or model sub-tree into a NumericField dataset.
        *
        * &amp;lt;p&amp;gt;The last two indexes of the model subtree are used as the indexes for the NumericField
        * matrix.  The second to last index corresponds to the NF&amp;apos;s id field and the
        * last index corresponds to the NF&amp;apos;s number field.
        *
        * @param mod The model from which to extract the NumericField matrix.
        * @param fromIndx The index from which to extract the matrix. Example: [3,1,5].
        *                  The default is from the top of the tree i.e. [].
        * @return NumericField matrix in DATASET(NumericField) format.
        *
        */
        EXPORT DATASET(NumericField) ToNumericField(DATASET(Layout_Model2) mod, t_indexes fromIndx = []) := FUNCTION
        NumericField mod_to_nf(Layout_Model2 t) := TRANSFORM
        prefixSize := COUNT(fromIndx);
        suffix := t.indexes[prefixSize+1.. ];
        SELF.id := suffix[1];
        SELF.number := suffix[2];
        SELF := t;
        END;
        prefixSize := COUNT(fromIndx);
        filter := mod.indexes[..prefixSize] = fromIndx;
        outCells := ASSERT(mod(filter), COUNT(indexes) = prefixSize + 2, &amp;apos;ModelOps2.ToNumericField: Extracted indexes must be exactly 2 dimensional.  Found &amp;apos;
        + (COUNT(indexes) - prefixSize), FAIL);
        outMod := PROJECT(outCells, mod_to_nf(LEFT));
        return outMod;
        END;
        /**
        * Convert a NumericField dataset to a 2 level model (or model subtree).
        *
        * &amp;lt;p&amp;gt;A two level model is created and appended to atIndex.
        * &amp;lt;p&amp;gt;The first new index will contain the value of the NumericField&amp;apos;s
        * id field, and the second will contain the value of the NumericField&amp;apos;s
        * number field.
        * &amp;lt;p&amp;gt;Example: If I have a NumericField with id=1 and number=3, and I use
        * atIndex = [3,1,5], it will create a Naming Tree cell with indexes:
        * [3,1,5,1,3].
        *
        * @param nf A NumericField dataset to be converted.
        * @param atIndex The index at which to place the new subtree e.g., [3,1,5].
        * @return DATASET(ntNumeric) Naming Tree.
        *
        */
        EXPORT DATASET(Layout_Model2) FromNumericField(DATASET(NumericField) nf, t_indexes atIndex=[]) := FUNCTION
        Layout_Model2 nf_to_mod(NumericField n) := TRANSFORM
        indexes := atIndex + [n.id, n.number];
        SELF.indexes := indexes;
        SELF         := n;
        END;
        outMod := PROJECT(nf, nf_to_mod(LEFT));
        RETURN outMod;
        END;
        /**
        * Get a single record (cell) from a model by index.
        *
        * @param mod The model (DATASET(layout_model2)) from which to extract the cell.
        * @param indxs The id of the cell to extract (e.g. [3,1,5]).
        * @param wi_num The work-item number to extract the cell from, default = 1.
        * @return The model cell (Layout_Model2) or an empty cell (wi=0) if not found.
        *
        */
        EXPORT Layout_Model2 GetItem(DATASET(Layout_Model2) mod, t_indexes indxs, wi_num=1) := FUNCTION
        RETURN mod(indexes=indxs AND wi=wi_num)[1];
        END;
        /**
        * Add a single record (cell) to an model at a given set of coordinates.
        *
        * @param mod The model to which to add a cell.
        * @param wi The work-item associated with the cell.
        * @param indexes The indices for the cell.
        * @param value The value of the cell.
        * @return Model with the added cell.
        *
        */
        EXPORT DATASET(Layout_Model2) SetItem(DATASET(Layout_Model2) mod, t_work_item wi, t_indexes indexes, t_fieldReal value) := FUNCTION
        RETURN mod + DATASET([{wi, value, indexes}], Layout_Model2);
        END;
        END;&amp;#10;
        &lt;/Attribute&gt;
        &lt;/Module&gt;
        &lt;Module key=&quot;_versions.ml_core.v3_2_2.ml_core.interfaces&quot; name=&quot;_versions.ML_Core.V3_2_2.ML_Core.Interfaces&quot;&gt;
        &lt;Attribute key=&quot;iclassify2&quot;
        name=&quot;IClassify2&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Interfaces/IClassify2.ecl&quot;
        ts=&quot;1621960335000000&quot;&gt;
        IMPORT $.^ AS ML_Core;
        IMPORT ML_Core.Types AS Types;

        Layout_Model2 := Types.Layout_Model2;
        Classify_Result := Types.Classify_Result;
        NumericField := Types.NumericField;
        DiscreteField := Types.DiscreteField;
        Confusion_Detail := Types.Confusion_Detail;
        Classification_Accuracy := Types.Classification_Accuracy;
        Class_Accuracy := Types.Class_Accuracy;

        /**
        * Interface definition for Classification (Version 2).
        * Classification learns a function that maps a set of input data
        * to one or more output class-label (i.e. Discrete) variables.
        * The resulting learned function is known as the model.
        * That model can then be used repetitively to predict the class(es)
        * for each sample when presented with new input data.
        * Actual implementation modules will probably take configuration
        * parameters to control the classification process.
        * The Classification modules also expose attributes for assessing
        * the effectiveness of the classification.
        */
        EXPORT IClassify2 := MODULE, VIRTUAL
        /**
        * Calculate the model to fit the independent data to the observed
        * classes (i.e. dependent data).
        * @param indepenedents The observed independent (explanatory) values.
        * @param dependents The observed dependent(class label) values.
        * @return The encoded model.
        * @see Types.Layout_Model2
        * @see Types.NumericField
        * @see Types.DiscreteField
        */
        EXPORT DATASET(Layout_Model2) GetModel(DATASET(NumericField) independents,
        DATASET(DiscreteField) dependents);
        /**
        * Classify the observations using a model.
        * @param model The model, which must be produced by a corresponding
        * getModel function.
        * @param observations New observations (independent data) to be classified.
        * @return Predicted class values.
        *
        */
        EXPORT DATASET(DiscreteField) Classify(DATASET(Layout_Model2) model,
        DATASET(NumericField) observations);
        /**
        * Return accuracy metrics for the given set of test data
        * &amp;lt;p&amp;gt;This is equivalent to calling Predict followed by
        * Analysis.Classification.Accuracy(...).
        *
        * &amp;lt;p&amp;gt;Provides accuracy statistics as follows:&amp;lt;ul&amp;gt;
        * &amp;lt;li&amp;gt;errCount -- The number of misclassified samples.&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;errPct -- The percentage of samples that were misclasified (0.0 - 1.0).&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;RawAccuracy -- The percentage of samples properly classified (0.0 - 1.0).&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;PoD -- Power of Discrimination.  Indicates how this classification performed
        *           relative to a random guess of class.  Zero or negative indicates that
        *           the classification was no better than a random guess.  1.0 indicates a
        *           perfect classification.  For example if there are two equiprobable classes,
        *           then a random guess would be right about 50% of the time.  If this
        *           classification had a Raw Accuracy of 75%, then its PoD would be .5
        *           (half way between a random guess and perfection).&amp;lt;/li&amp;gt;
        * &amp;lt;li&amp;gt;PoDE -- Power of Discrimination Extended.  Indicates how this classification
        *           performed relative to guessing the most frequent class (i.e. the trivial
        *           solution).  Zero or negative indicates that this classification is no
        *           better than the trivial solution.  1.0 indicates perfect classification.
        *           For example, if 95% of the samples were of class 1, then the trivial
        *           solution would be right 95% of the time.  If this classification had a
        *           raw accuracy of 97.5%, its PoDE would be .5 (i.e. half way between
        *           trivial solution and perfection).&amp;lt;/li&amp;gt;
        * &amp;lt;p&amp;gt;Normally, this should be called using data samples that were not included in the
        * training set.  In that case, these statistics are considered Out-of-Sample error
        * statistics.  If it is called with the X and Y from the training set, it provides
        * In-Sample error statistics, which should never be used to rate the classification model.
        *
        *
        * @param model The encoded model as returned from GetModel.
        * @param actuals The actual class values associated with the observations.
        * @param observations The independent (explanatory) values on which to base the test.
        * @return DATSET(Classification_Accuracy), one record per work-item.
        * @see Types.Classification_Accuracy
        *
        */
        EXPORT DATASET(Classification_Accuracy) Accuracy(DATASET(Layout_Model2) model,
        DATASET(DiscreteField) actuals, DATASET(NumericField) observations
        ) := FUNCTION
        predicted := Classify(model, observations);
        RETURN ML_Core.Analysis.Classification.Accuracy(predicted, actuals);
        END;
        /**
        * Return class-level accuracy by class metrics for the given
        * set of test data.
        * &amp;lt;p&amp;gt;This is equivalent to calling Predict followed by
        * Analysis.Classification.AccuracyByClass(...).
        *
        * @param model The encoded model as returned from GetModel.
        * @param actuals The actual class values associated with the observations.
        * @param observations The independent (explanatory) values on which to base the test
        * @return DATASET(Class_Accuracy), one record per work-item per class.
        * @see Types.Class_Accuracy.
        *
        */
        EXPORT DATASET(Class_Accuracy) AccuracyByClass(DATASET(Layout_Model2) model,
        DATASET(DiscreteField) actuals,
        DATASET(NumericField) observations
        ) := FUNCTION
        predicted := Classify(model, observations);
        RETURN ML_Core.Analysis.Classification.AccuracyByClass(predicted, actuals);
        END;
        /**
        * Return the confusion matrix for a set of test data.
        * This is equivalent to calling Predict follwed by
        * Analysis.Classification.ConfusionMatrix(...).
        * &amp;lt;p&amp;gt;The confusion matrix indicates the number of datapoints that were classified correctly or incorrectly
        * for each class label.
        * &amp;lt;p&amp;gt;The matrix is provided as a matrix of size numClasses x numClasses with fields as follows:&amp;lt;ul&amp;gt;
        *   &amp;lt;li&amp;gt;&amp;apos;wi&amp;apos; -- The work item id&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;&amp;apos;pred&amp;apos; -- the predicted class label (from Classify).&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;&amp;apos;actual&amp;apos; -- the actual (target) class label.&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;&amp;apos;samples&amp;apos; -- the count of samples that were predicted as &amp;apos;pred&amp;apos;, but should have been &amp;apos;actual&amp;apos;.&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;&amp;apos;totSamples&amp;apos; -- the total number of samples that were predicted as &amp;apos;pred&amp;apos;.&amp;lt;/li&amp;gt;
        *   &amp;lt;li&amp;gt;&amp;apos;pctSamples&amp;apos; -- the percentage of all samples that were predicted as &amp;apos;pred&amp;apos;, that should
        *                have been &amp;apos;actual&amp;apos; (i.e. samples / totSamples)&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
        *
        * &amp;lt;p&amp;gt;This is a useful tool for understanding how the algorithm achieved the overall accuracy.  For example:
        * were the common classes mostly correct, while less common classes often misclassified?  Which
        * classes were most often confused?
        *
        * This should be called with test data that is independent of the training data in order to understand
        * the out-of-sample (i.e. generalization) performance.
        *
        * @param model The encoded model as returned from GetModel.
        * @param actuals The actual class values.
        * @param observations The independent (explanatory) values.
        * @return DATASET(Confusion_Detail), one record per cell of the confusion matrix.
        * @see Types.Confusion_Detail.
        */
        EXPORT DATASET(Confusion_Detail) ConfusionMatrix(DATASET(Layout_Model2) model,
        DATASET(DiscreteField) actuals, DATASET(NumericField) observations
        ) := FUNCTION
        predicted := Classify(model, observations);
        RETURN ML_Core.Analysis.Classification.ConfusionMatrix(predicted, actuals);
        END;
        END;&amp;#10;
        &lt;/Attribute&gt;
        &lt;/Module&gt;
        &lt;Module key=&quot;_versions.learningtrees.v1_1_1.learningtrees.internal&quot; name=&quot;_versions.LearningTrees.V1_1_1.LearningTrees.internal&quot;&gt;
        &lt;Attribute key=&quot;rf_base&quot;
        name=&quot;RF_Base&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Base.ecl&quot;
        ts=&quot;1621960363000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
        ############################################################################## */
        IMPORT $.^ AS LT;
        IMPORT LT.Internal AS int;
        IMPORT LT.LT_Types as Types;
        IMPORT ML_Core as ML;
        IMPORT ML.Types AS CTypes;
        IMPORT std.system.Thorlib;
        IMPORT ML_Core.ModelOps2;

        GenField := Types.GenField;
        ModelStats := Types.ModelStats;
        t_Work_Item := CTypes.t_Work_Item;
        t_Count := CTypes.t_Count;
        t_RecordId := CTypes.t_RecordID;
        t_FieldNumber := CTypes.t_FieldNumber;
        t_TreeId := t_FieldNumber;
        Layout_Model := CTypes.Layout_Model;
        wiInfo := Types.wiInfo;
        TreeNodeDat := Types.TreeNodeDat;
        NumericField := CTypes.NumericField;
        DiscreteField := CTypes.DiscreteField;
        Layout_Model2 := CTypes.Layout_Model2;
        FeatureImportanceRec := Types.FeatureImportanceRec;
        nfNull := DATASET([], NumericField);

        /**
        * Base Module for Random Forest algorithms.  Modules for RF Classification or Regression
        * are based on this one.
        * The random forest algorithm used is based on Brieman 2001 with extensions.
        * It provides the attributes to set up the forest as well as storing of the resulting forest
        * in a common model format.  It also provides various analytic methods.
        *
        * Theory of Operation
        *
        * The heart of the random forest algorithm is the building of a forest model (multiple
        * diverse decision trees) by segmenting the training data through binary splits that
        * increase the uniformity of the dependent variable as the tree is developed.
        * In random forest, the trees are developed until the data after the final split is
        * totally pure (i.e. all members have the same value of the dependent variable), or
        * a maximum tree depth is encountered (configurable -- see maxDepth parameter).  If a
        * maximum depth is encountered with an impure group on either or both sides, the remaining
        * points are aggregated through an appropriate means (implementation dependent).
        * When a pure group is obtained (either through purity or aggregation), the data points
        * in that group are summarized by a &amp;quot;leaf node&amp;quot;.  Each tree is therefore composed of
        * split-nodes (i.e. branches) and leaf-nodes.
        * The resulting forest model can then be used to perform predictions of the dependent
        * variable given hitherto unseen samples of the independent variable.  In the case of
        * a Regression Forest, the unobserved dependent variable is predicted as a continuous
        * number.  In the case of a Classification Forest, the dependent variable takes the form
        * of a discrete class identifier, and the prediction method is called &amp;quot;Classify&amp;quot;.
        * This implementation allows the independent variables to be continuous or discrete,
        * and supports both ordered variables (e.g. quantitative -- real-numbers, integers) and
        * categorical (aka &amp;quot;nominal&amp;quot;) variables, which can represent qualitative info such as
        * type, color, state, which are encoded with integer values. These different types of
        * independent variables are encoded using the GenField dataset layout.
        * Once a forest model has been created, new values are predicted by running each
        * datapoint down the tree for each tree in the forest, arriving at a single leaf for
        * each datapoint in each tree.  The final prediction is arrived at by aggregating
        * the leaf value of all the trees in the forest for that point.  Depending on whether
        * we are classifying or predicting a continous value (i.e. regression), a different
        * aggregation method is used.  For classification, a voting method is used.  The most
        * commonly predicted class is the final result.  For regression, the mean of all the
        * trees&amp;apos; predictions is returned as the final result.
        * Each tree can be thought of as an &amp;apos;overfit&amp;apos; model since they will fit to not only
        * the &amp;apos;signal&amp;apos; in the data, but also the &amp;apos;noise&amp;apos;.  The aggregation across the forest
        * averages out most of the noise (due to the diversity of the trees).  This is a
        * key strength of the random forest algorithm as it makes it robust against over-fitting.
        * The diversity of the forest is achieved in a number of ways:
        * 1) Each tree is built using a bootstrap of the original data.  That is, for each
        *    tree, the data is sampled with replacement, resulting in a different set of
        *    points used to create the tree.  On average, aroung 30% of the datapoints will
        *    be missing from each tree due to replication of other points.
        * 2) Each split node is created based on a random subset of features (the best split
        *    for each subset is used).  This randomly eliminates some possible branches
        *    for each split and causes each tree to grow in a unique fashion.
        * 3) Unless auto-binning is disabled, for variables with many values (e.g. continuous)
        *    the possible split points are randomly sampled so that only a smaller set of
        *    points are considered for each split.  This technique provides better performance
        *    while increasing the diversity of the trees in the forest, and is sometimes referred-
        *    to as &amp;quot;extremely randomized foests&amp;quot;.  This is the default mode of operation as it
        *    seems to provide strong benefits without significant down-side.
        * This base module provides the common methods for building and using the forest model,
        * while the derived modules (e.g. ClassificationForest and RegressionForest) overlay
        * virtual attributes that perform work specific to the type of forest.
        * The basic steps in building the tree are:
        * - Organize the input data:
        *   - Identify the work-items and number of training records and features
        *   - Ensure that the record ids are sequential
        *   - Create a map of each of the feature numbers for each work-item
        * - Generate random bootstrap samples for each tree
        * - Create numTree tree root nodes
        * - Replicate the training data bootstraps to each tree root
        * - Build the trees, one layer at a time by:
        *   - Randomly choose the featuresPerNode features to evaluate for a given level
        *   - Evaluate all possible splits on those features to find the feature and split-point
        *     that results in the most pure pair of sub-groups.  The criteria for evaluating
        *     splits is different for the different forest types.
        *   - Choose the best split, and create a split-node (branch) based on that split.
        *   - Create a left and right child node at the next level under the split-node.
        *   - Reallocate the data points from the node to the left or right child nodes.
        *   - If any group is pure (i.e. same dependent value for all members) or we&amp;apos;ve reached
        *     maxDepth, replace all the datapoints in that node with a single leaf node.
        * - At the end of the process, all the datapoints will have been absorbed by leaf nodes,
        *   and the resulting trees will contain only split-nodes and leaf-nodes.
        * - Note that a single common data structure (see LT_Types.TreeNodeData) is used to
        *   represent:
        *   - Data-points that need to be processed for a node (only during tree growing)
        *   - A split-node
        *   - A leaf-node
        * - The resulting tree-nodes representing the forest are converted to a Forest Model
        *   for later use in prediction or analysis.
        */
        EXPORT RF_Base(DATASET(GenField) X_in=DATASET([], GenField),
        DATASET(GenField) Y_In=DATASET([], GenField),
        UNSIGNED numTrees=100,
        UNSIGNED featuresPerNodeIn=0,
        UNSIGNED maxDepth=255,
        DATASET(NumericField) observWeights=nfNull) := MODULE
        SHARED haveObsWeights := EXISTS(observWeights);
        // Resequence ids to go from 1-numRecords.
        SHARED resequenceByWi(DATASET(GenField) dat) := FUNCTION
        // Dat should be evenly distributed at this point
        xGen := RECORD(GenField)
        t_RecordId newId := 0;
        END;
        xDat := PROJECT(dat, TRANSFORM(xGen, SELF := LEFT));
        xGen setNewIds(xGen l, xGen r) := TRANSFORM
        newId := IF(l.wi != r.wi, 1, IF(r.id = l.id, l.newId, l.newId + 1));
        SELF.newId := newId;
        SELF := r;
        END;
        xDatS := SORT(xDat, wi, id);
        xDat2 := ITERATE(xDatS, setNewIds(LEFT, RIGHT));
        outDat0 := PROJECT(xDat2, TRANSFORM(GenField, SELF.id := LEFT.newId, SELF := LEFT));
        outDat := DISTRIBUTE(outDat0, HASH32(wi, id));
        return outDat;
        END;
        SHARED autoBin := TRUE;
        SHARED autobinSize := 10;
        SHARED maxU4 := 4294967295; // Maximum value for an Unsigned 4
        SHARED maxR8 := 1.797693e+308; // Maximum value for a REAL8
        SHARED autobinSizeScald := autobinSize * maxU4; // Scaled auto-bin size for efficiency
        SHARED XD := DISTRIBUTE(X_in, HASH32(wi, id));
        SHARED YD := DISTRIBUTE(Y_in, HASH32(wi, id));
        SHARED XSD := SORT(XD, wi, id, number, LOCAL);
        SHARED YSD := SORT(YD, wi, LOCAL);  // Sort Y by work-item
        SHARED Rand01 := RANDOM()/maxU4; // Random number between zero and one.

        // P log P calculation for entropy.  Note that Shannon entropy uses log base 2 so the division by LN(2) is
        // to convert the base from e to 2.
        SHARED P_Log_P(REAL P) := IF(P=1, 0, -P* LN(P) / LN(2));

        SHARED empty_model := DATASET([], Layout_Model2);
        SHARED empty_data := DATASET([], GenField);
        // Abbreviations for Model Index definitions
        SHARED FM := Types.Forest_Model;
        SHARED FM1 := FM.Ind1;
        SHARED FMN3 := FM.Ind3_nodes;
        // Calculate work-item metadata
        // Each work-item needs its own metadata (i.e. numSamples, numFeatures, .  Construct that here.
        SHARED wiSamples := TABLE(YSD, {wi, numSamples := COUNT(GROUP), maxId := MAX(GROUP, id)}, wi);
        idFeatures := TABLE(XSD, {wi, id, numFeats := COUNT(GROUP), maxFNum := MAX(GROUP, number)}, wi, id, LOCAL);
        SHARED wiFeatures := TABLE(idFeatures, {wi, numFeatures := MAX(GROUP, numFeats), maxNum := MAX(GROUP, maxFNum)}, wi);
        wiMeta0 := JOIN(wiSamples, wiFeatures, LEFT.wi = RIGHT.wi, TRANSFORM({wiSamples, UNSIGNED numFeatures},
        SELF.numFeatures := RIGHT.numFeatures, SELF := LEFT));
        wiInfo makeMeta(wiMeta0 lr) := TRANSFORM
        // If featuresPerNode was passed in as zero (default), use the square root of the number of features,
        // which is a good rule of thumb.  In general, with multiple work-items of different sizes, it is best
        // to default featuresPerNode.
        fpt0 := IF(featuresPerNodeIn &amp;gt; 0, featuresPerNodeIn, TRUNCATE(SQRT(lr.numFeatures)));
        // In no case, let features per tree be greater than the number of features.
        SELF.featuresPerNode := MIN(fpt0, lr.numFeatures);
        SELF := lr;
        END;
        SHARED wiMeta := PROJECT(wiMeta0, makeMeta(LEFT));
        SHARED needsReseqTest := SUM(wiSamples, ABS(numSamples - maxId)) != 0;
        SHARED X := IF(needsReseqTest, resequenceByWi(XSD), XSD);
        SHARED Y := IF(needsReseqTest, resequenceByWi(YSD), YSD);
        // Create a map of feature number -&amp;gt; sequential feature number (1-numFeatures) for each wi.
        // Note: at this point, there has to be a record with id=1 for each work-item.
        // Overload the id field (which is not needed here) with a sequential id (1-numFeatures)
        // so that we can map between the two
        allFeatures := SORT(X(id=1), wi, number);
        allFeaturesG := GROUP(allFeatures, wi);
        featureMap0 := PROJECT(allFeaturesG, TRANSFORM(GenField, SELF.id := COUNTER, SELF := LEFT));
        SHARED featureMap := UNGROUP(featureMap0);
        SHARED needFeatureRenumbering := COUNT(featureMap) != SUM(wiFeatures, maxNum);
        SHARED allowNoProgress := IF(featuresPerNodeIn &amp;lt; MAX(featureMap, id), TRUE, FALSE);
        // If FALSE, tree will terminate when no progess can be made on any
        // feature.  For RF, should be TRUE since it may get a better choice
        // of features at the next level.  Set FALSE if featuresPerNode &amp;gt;= numFeatures,
        // since we will always be choosing from all features.
        // Data structure to hold the sample indexes (i.e Bootstrap Sample) for each treeId
        SHARED sampleIndx := RECORD
        t_TreeID treeId;
        t_RecordId id;     // Id within this tree
        t_RecordId origId; // The id of this sample in the original X,Y
        END;

        // treeSampleIndx has  &amp;lt;samples&amp;gt; sample indexes for each tree, sorted by tree.  This represents
        // the &amp;quot;Bootstrap Sample&amp;quot; for each tree using sampling with replacement.
        // It is used during tree initialization, and is also needed for analytics / validation so that
        // &amp;quot;out-of-bag&amp;quot; (OOB) samples can be created.  Use all cluster nodes to build the index, and
        // leave it distributed by tree-id.

        // Note: The approach is somewhat strange, but done for distributed performance.
        // Start from the samples.  Generate enough samples so that there are enough for the work-item
        // with the most samples.  We&amp;apos;ll use truncations of these samples for the same treeId across work-items.
        // So we only need to create the sampling index once per treeId.
        SHARED maxSampleSize := MAX(wiMeta, numSamples); // maximum samples for any work-item
        SHARED maxfeaturesPerNode := MAX(wiMeta, featuresPerNode); // maximum features for any work-item
        dummy := DATASET([{0,0,0}], sampleIndx);
        // Create one dummy sample per tree
        treeDummy := NORMALIZE(dummy, numTrees, TRANSFORM(sampleIndx, SELF.treeId := COUNTER, SELF := []));
        // Distribute by treeId to create the samples in parallel
        treeDummyD := DISTRIBUTE(treeDummy, treeId);
        // Now generate samples for each treeId in parallel
        // In the event that there is only one tree in the forest, the best result will
        // be gotten by using the full data (i.e. no sampling).
        treeSampleIndxSampled := NORMALIZE(treeDummyD, maxSampleSize, TRANSFORM(sampleIndx,
        SELF.origId := (RANDOM()%maxSampleSize) + 1,
        SELF.id := COUNTER,
        SELF := LEFT));
        treeSampleIndxNonSampled := NORMALIZE(treeDummyD, maxSampleSize, TRANSFORM(sampleIndx,
        SELF.origId := COUNTER,
        SELF.id := COUNTER,
        SELF := LEFT));
        SHARED treeSampleIndx := IF(numTrees &amp;gt; 1, treeSampleIndxSampled, treeSampleIndxNonSampled);
        // Function to randomly select features to use for each level of the tree building.
        // Each node is assigned a random subset of the features.
        SHARED DATASET(TreeNodeDat) SelectVarsForNodes(DATASET(TreeNodeDat) nodeDat) := FUNCTION
        // At this point, nodeDat should have one instance per id per node per tree per wi, distributed by (wi, treeId)
        // Nodes should be sorted by (at least) wi, treeId, nodeId at this point.
        // We are trying to choose featuresPerNode features out of the full set of features for each tree node
        // First, extract the set of treeNodes
        nodes := DEDUP(nodeDat, wi, treeId, nodeId, LOCAL);  // Now we have one record per node
        // Now, extend the the tree data.  Add a random number field and create &amp;lt;features&amp;gt; records for each tree.
        xTreeNodeDat := RECORD(TreeNodeDat)
        UNSIGNED numFeatures;
        UNSIGNED featuresPerNode;
        UNSIGNED rnd;
        END;
        // Note that each work-item may have a different value for numFeatures and featuresPerNode
        xTreeNodeDat makeXNodes(treeNodeDat l, wiInfo r) := TRANSFORM
        SELF.numFeatures := r.numFeatures;
        SELF.featuresPerNode := r.featuresPerNode;
        SELF := l;
        SELF := [];
        END;
        xNodes := JOIN(nodes, wiMeta, LEFT.wi = RIGHT.wi, makeXNodes(LEFT, RIGHT), LOOKUP, FEW);
        xTreeNodeDat getFeatures(xTreeNodeDat l, UNSIGNED c) := TRANSFORM
        // Choose twice as many as we need, so that when we remove duplicates, we will (almost always)
        // have at least the right number.  This is more efficient than enumerating all and picking &amp;lt;featuresPerNode&amp;gt;
        // from that set because numFeatures &amp;gt;&amp;gt; featuresPerNode.  We will occasionally get a tree that
        // has less than &amp;lt;featuresPerNode&amp;gt; variables, but that should only add to the diversity.
        nf := l.numFeatures;
        SELF.number := (RANDOM()%nf) + 1;
        SELF.rnd := RANDOM();
        SELF := l;
        END;
        // Create twice as many features as we need, so that when we remove duplicates, we almost always
        // have at least as many as we need.
        nodeVars0 := NORMALIZE(xNodes, LEFT.featuresPerNode * 2, getFeatures(LEFT, COUNTER));
        nodeVars1 :=  GROUP(nodeVars0, wi, treeId, nodeId, LOCAL);
        nodeVars2 := SORT(nodeVars1, wi, treeId, nodeId, number); // Note: implicitly local because of GROUP
        // Get rid of any duplicate features (we sampled with replacement so may be dupes)
        nodeVars3 := DEDUP(nodeVars2, wi, treeId, nodeId, number);
        // Now we have up to &amp;lt;featuresPerNode&amp;gt; * 2 unique features per node.  We need to whittle it down to
        // no more than &amp;lt;featuresPerNode&amp;gt;.
        nodeVars4 := SORT(nodeVars3, wi, treeId, nodeId, rnd); // Mix up the features
        // Filter out the excess vars and transform back to TreeNodeDat.  Set id (not yet used) just as an excuse
        // to check the count and skip if needed.
        nodeVars5 := UNGROUP(PROJECT(nodeVars4, TRANSFORM(TreeNodeDat,
        SELF.id := IF(COUNTER &amp;lt;= LEFT.featuresPerNode, 0, SKIP),
        SELF := LEFT)));
        // If the user provided features numbers that were not sequential, we need to map these feature numbers
        // (which are sequential) to the actual numbers the user provided.
        renumberFeatures(DATASET(TreeNodeDat) dat) := FUNCTION
        rnDat := JOIN(dat, featureMap, LEFT.wi = RIGHT.wi AND LEFT.number = RIGHT.id,
        TRANSFORM(TreeNodeDat, SELF.number := RIGHT.number, SELF := LEFT), LOOKUP);
        RETURN rnDat;
        END;
        nodeVars := IF(needFeatureRenumbering, renumberFeatures(nodeVars5), nodeVars5);
        // At this point, we have &amp;lt;featuresPerNode&amp;gt; records for almost every node.  Occasionally one will have less
        // (but at least 1).
        // Now join with original nodeDat (one rec per tree node per id) to create one rec per tree node per id per
        // selected feature.
        nodeVarDat := JOIN(nodeDat, nodeVars, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM(TreeNodeDat, SELF.number := RIGHT.number, SELF := LEFT), LOCAL);
        RETURN nodeVarDat;
        END;

        // Sample with replacement &amp;lt;samples&amp;gt; items from X,Y for each tree
        SHARED DATASET(TreeNodeDat) GetBootstrapForTree(DATASET(TreeNodeDat) trees) := FUNCTION
        // At this point, trees contains one record per tree for each wi
        // Use the bootstrap (treeSampleIndxs) built at the module level

        // Note: At this point, trees and treeSampleIndx are both sorted and distributed by
        // treeId
        // We need to add the sample size from the wi to the dataset in order to filter appropriately
        xtv := RECORD(TreeNodeDat)
        t_RecordId numSamples;
        END;
        xTrees := JOIN(trees, wiMeta, LEFT.wi = RIGHT.wi, TRANSFORM(xtv, SELF.numSamples := RIGHT.numSamples,
        SELF := LEFT), LOOKUP, FEW);
        // Expand the trees to include the sample index for each tree.
        // Size is now &amp;lt;numTrees&amp;gt;  * &amp;lt;maxSamples&amp;gt; per wi
        // Note: this is a many to many join.
        treeDat0 := JOIN(xTrees, treeSampleIndx, LEFT.treeId = RIGHT.treeId,
        TRANSFORM(xtv, SELF.origId := RIGHT.origId, SELF.id := RIGHT.id, SELF := LEFT),
        MANY, LOOKUP);
        // Filter treeDat0 to remove any samples with origId &amp;gt; numSamples for that wi.
        // The number of samples will not (in all cases) be = the desired sample size, but shouldn&amp;apos;t create any bias.
        // This was our only need for numSamples, so we project back to TreeNodeDat format
        treeDat1 := PROJECT(treeDat0(origId &amp;lt;= numSamples), TreeNodeDat);
        // Now redistribute by wi and &amp;lt;origId&amp;gt; to match the Y data
        treeDat1D := DISTRIBUTE(treeDat1, HASH32(wi, origId));

        // Now get the  corresponding Y (dependent) value
        // While we&amp;apos;re at it, assign the data to the root (i.e. nodeId = 1, level = 1)
        treeDat2 := JOIN(treeDat1D, Y, LEFT.wi = RIGHT.wi AND LEFT.origId=RIGHT.id,
        TRANSFORM(TreeNodeDat, SELF.depend := RIGHT.value, SELF.nodeId := 1, SELF.level := 1,
        SELF.observWeight := 1.0, SELF := LEFT),
        LOCAL);
        treeDat2w := JOIN(treeDat2, observWeights, LEFT.wi = RIGHT.wi AND LEFT.origId = RIGHT.id,
        TRANSFORM(RECORDOF(LEFT), SELF.observWeight := IF(RIGHT.value &amp;gt; 0, RIGHT.value, 1.0),
        SELF := LEFT), LEFT OUTER, LOOKUP);
        treeDat := IF(haveObsWeights, treeDat2w, treeDat2);
        // At this point, we have one instance per tree  per sample, for each work-item, and each instance
        // includes the Y values for the selected indexes (i.e. depend)
        // TreeDat is distributed by work-item and sample id.
        RETURN treeDat;
        END;

        // Create the set of tree definitions -- One single node per tree (the root), with all tree samples associated with that root.
        SHARED DATASET(TreeNodeDat) InitTrees := FUNCTION
        // Create an empty tree data instance per work-item
        dummyTrees := PROJECT(wiMeta, TRANSFORM(TreeNodeDat, SELF.wi := LEFT.wi, SELF := []));
        // Use that to create &amp;quot;numTrees&amp;quot; dummy trees -- a dummy (empty) forest per wi
        trees := NORMALIZE(dummyTrees, numTrees, TRANSFORM(TreeNodeDat, SELF.treeId:=COUNTER, SELF.wi := LEFT.wi, SELF:=[]));
        // Distribute by wi and treeId
        treesD := DISTRIBUTE(trees, HASH32(wi, treeId));
        // Now, choose bootstrap sample of X,Y for each tree
        roots := GetBootstrapForTree(treesD);
        // At this point, each tree is fully populated with a single root node(i.e. 1).  All the data is associated with the root node.
        // Roots has each tree&amp;apos;s bootstrap sample of the dependent variable (selected for the tree).
        // Roots is distributed by wi and origId (original sample index)
        RETURN roots;
        END;

        // Grow one layer of the forest.  Virtual method to be overlaid by specific (Classification or Regression)
        // module
        SHARED VIRTUAL DATASET(TreeNodeDat) GrowForestLevel(DATASET(TreeNodeDat) nodeDat, t_Count treeLevel) := FUNCTION
        return DATASET([], TreeNodeDat);
        END;

        // Grow a Classification Forest from a set of roots containing all the data points (X and Y) for each tree.
        SHARED DATASET(TreeNodeDat) GrowForest(DATASET(TreeNodeDat) roots) := FUNCTION
        // Localize all the data by wi and treeId
        rootsD := DISTRIBUTE(roots, HASH32(wi, treeId));
        // Grow the forest one level at a time.
        treeNodes  := LOOP(rootsD, LEFT.id &amp;gt; 0, EXISTS(ROWS(LEFT)(COUNTER &amp;lt;= maxDepth)) , GrowForestLevel(ROWS(LEFT), COUNTER));
        return SORT(treeNodes, wi, treeId, level, nodeId);
        END;

        // Generate all tree nodes for classification
        EXPORT DATASET(TreeNodeDat) GetNodes := FUNCTION
        // First create a set of tree roots, each
        // with a unique bootstrap sample out of X,Y
        roots := InitTrees;
        // We now have a single root node for each tree (level = 1, nodeId = 1).  All of the data is
        // associated with the root for each tree.
        // Now we want to grow each tree by adding nodes, and moving the data
        // points to lower and lower nodes at each split.
        // When we are done, all of the data will be gone and all that will remain
        // is the skeleton of the decision tree with splits and leaf nodes.
        forestNodes := GrowForest(roots);
        // We now just have the structure of the decision trees remaining.  All data
        // is now summarized by the trees&amp;apos; structure into leaf nodes.
        RETURN forestNodes;
        END;

        // Find the corresponding leaf node for each X sample given an expanded forest model (set of tree nodes)
        EXPORT DATASET(TreeNodeDat) GetLeafsForData(DATASET(TreeNodeDat) tNodes, DATASET(GenField) X) := FUNCTION
        // Distribute X by wi and id.
        x_D := SORT(DISTRIBUTE(X, HASH32(wi, id)), wi, id, LOCAL);
        x_ids := DEDUP(x_D, wi, id, LOCAL);
        // Extend each root for each ID in X
        // Leave the extended roots distributed by wi, id.
        roots := tNodes(level = 1);
        rootsExt := JOIN(x_ids, roots, LEFT.wi = RIGHT.wi, TRANSFORM(TreeNodeDat, SELF.id := LEFT.id, SELF := RIGHT),
        MANY, LOOKUP);
        rootBranches := rootsExt(number != 0); // Roots are almost always branch (split) nodes.
        rootLeafs := rootsExt(number = 0); // Unusual but not impossible
        loopBody(DATASET(TreeNodeDat) levelBranches, UNSIGNED tLevel) := FUNCTION
        // At this point, we have one record per node, per id.
        // We extend each id down the tree one level at a time, picking the correct next nodes
        // for that id at each branch.
        // Next nodes are returned -- both leafs and branches.  The leafs are filtered out by the LOOP,
        // while the branches are sent on to the next round.
        // Ultimately, a leaf is returned for each id, which defines our final result.
        // Select the next nodes by combining the selected data field with each node
        // Note that:  1) we retain the id from the previous round, but the field number(number) is derived from the branch
        //             2) &amp;apos;value&amp;apos; in the node is the value to split upon, while value in the data (X) is the value of that datapoint
        //             3) NodeIds at level n + 1 are deterministic.  The child nodes at the next level&amp;apos;s nodeId is 2 * nodeId -1 for the
        //                left node, and 2 * nodeId for the right node.
        branchVals := JOIN(levelBranches, x_D, LEFT.wi = RIGHT.wi AND LEFT.id = RIGHT.id AND LEFT.number = RIGHT.number,
        TRANSFORM({TreeNodeDat, BOOLEAN branchLeft},
        SELF.branchLeft :=  ((LEFT.isOrdinal AND RIGHT.value &amp;lt;= LEFT.value) OR
        ((NOT LEFT.isOrdinal) AND RIGHT.value = LEFT.value)),
        SELF.parentId := LEFT.nodeId, SELF := LEFT),
        LOCAL);
        // Now, nextNode indicates the selected (left or right) nodeId at the next level for each branch
        // Now we use nextNode to select the node for the next round, for each instance
        nextLevelNodes := tNodes(level = tLevel + 1);
        nextLevelSelNodes := JOIN(branchVals, nextLevelNodes, LEFT.wi = RIGHT.wi AND
        LEFT.treeId = RIGHT.treeId AND LEFT.nodeId = RIGHT.parentId AND
        LEFT.branchLeft = RIGHT.isLeft,
        TRANSFORM(TreeNodeDat, SELF.id := LEFT.id, SELF := RIGHT), LOOKUP);
        // Return the selected nodes at the next level.  These nodes may be leafs or branches.
        // Any leafs will be filtered out by the loop.  Any branches will go on to the next round.
        // When there are no more branches to process, we are done.  The selected leafs for each datapoint
        // is returned. All nodes are left distributed by wi, id.
        RETURN nextLevelSelNodes;
        END;
        // The loop will return the deepest leaf node associated with each sample.
        selectedLeafs0 := LOOP(rootBranches, LEFT.number&amp;gt;0, EXISTS(ROWS(LEFT)),
        loopBody(ROWS(LEFT), COUNTER));
        selectedLeafs := selectedLeafs0 + rootLeafs;
        RETURN selectedLeafs;
        END; // GetLeafsForData
        /**
        * During RF training, we will occasionally hit a situation where all of the randomly selected
        * features for a level of the tree are constant for a node.  In this case, we are forced to insert
        * a dummy-split using a random feature from the selected subset in order to continue processing the
        * data.  We should see other useful features in subsequent rounds.  In this case, we set the splitVal
        * to MaxR8 (the maximum value for a REAL8 field) so that all data will take the left path.
        * This function removes such dummy splits and replaces that node with its child nodes, resulting
        * in a smaller tree which should be faster to process for prediction / classification of new points,
        * as well as any analytic operations.
        */
        SHARED DATASET(TreeNodeDat) CompressNodes(DATASET(TreeNodeDat) inNodes) := FUNCTION
        nodesS := SORT(DISTRIBUTE(inNodes, HASH32(wi, treeId)), wi, treeId, level, nodeId, LOCAL);
        // Assign a unique id to each node, independent of level.  We can re-use the id field
        // since it is not used at this point.  Note, these only need to be unique within a
        // tree, but using LOCAL PROJECT is efficient.  It will asssign a unique id to all
        // nodes across trees that are on the node.  Note that tree-nodes are distributed by
        // wi and treeId at this point.
        xNodes0 := PROJECT(nodesS, TRANSFORM(TreeNodeDat,
        SELF.id := COUNTER,
        SELF := LEFT), LOCAL);
        // Now add the parent&amp;apos;s unique ID to each record, so that the parent relationship is now
        // independent of level.
        xNodes := JOIN(xNodes0, xNodes0, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND LEFT.level = RIGHT.level + 1
        AND LEFT.parentId = RIGHT.nodeId,
        TRANSFORM({TreeNodeDat, t_RecordID parentGuid},
        SELF.parentGuid := RIGHT.id;
        SELF := LEFT), LEFT OUTER, LOCAL);
        compressOneLevel(DATASET({xNodes}) cNodes, UNSIGNED tLevel) := FUNCTION
        // Find the nodes that need to be compressed out at this level
        compressNodes := SORT(cNodes(level = tLevel AND value = maxR8 AND number != 0 ), wi, treeId, id, LOCAL);
        // Find the children of the nodes to be compressed, and link them to the compressNode&amp;apos;s parent
        // Note that there should only be one child for each compress node and it should be the left node,
        // but it needs to be also assigned the compressNode&amp;apos;s isLeft.
        childNodes := SORT(cNodes(level = tLevel + 1), wi, treeId, parentGuid, LOCAL);
        replaceNodes := JOIN(compressNodes, childNodes, LEFT.wi = RIGHT.wi AND
        LEFT.treeId = RIGHT.treeId AND LEFT.id = RIGHT.parentGuid,
        TRANSFORM({compressNodes},
        SELF.parentGuid := LEFT.parentGuid,
        SELF.isLeft := LEFT.isLeft,
        SELF := RIGHT), LOCAL);
        // Eliminate the compressNodes and the child nodes and replace with the new child nodes
        outLevelNodes := cNodes(level = tLevel AND (value != maxR8 OR number = 0));
        outNextLevelNodes := JOIN(childNodes, replaceNodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.id = RIGHT.id,
        TRANSFORM(LEFT), LEFT ONLY, LOCAL);
        outNodes := outLevelNodes + replaceNodes + outNextLevelNodes + cNodes(level &amp;gt; tLevel + 1);
        RETURN outNodes;
        END; // CompressOneLevel
        newNodes := LOOP(xNodes, maxDepth, LEFT.level &amp;gt;= COUNTER,
        compressOneLevel(ROWS(LEFT), COUNTER));
        // At this point, we have the correct set of nodes, but their level and local id&amp;apos;s might be messed up.
        // They are linked by the global id, but we need to fix up all the levels and localid&amp;apos;s by traversing
        // the tree from the top down using the global ids.
        fixupOneLevel(DATASET({newNodes}) fNodes, UNSIGNED tLevel) := FUNCTION
        // Start with the nodes for this level.  For the top-level (root), we use a different method
        // (i.e. no parent) in case the root was originally a compressed node and the current root therefore
        // has the level set wrong.
        fNodesS := SORT(fNodes, wi, treeId, parentGuid, -isLeft, LOCAL);
        levelNodes0 := IF(tLevel = 1, fNodesS(parentGuid = 0), fNodesS(level=tLevel));
        // Make sure that the level is set correctly for these items, and re-assign the local id (nodeId).
        levelNodes := PROJECT(levelNodes0, TRANSFORM({levelNodes0},
        SELF.level := tLevel, SELF.nodeId := COUNTER, SELF := LEFT), LOCAL);
        // Now find all the children and set their level to tLevel + 1, and set the local parentId to the parent&amp;apos;s nodeId
        fNodesS2:= SORT(fNodes, wi, treeId, parentGuid, LOCAL);
        nextLevelNodes := JOIN(levelNodes, fNodesS2, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.id = RIGHT.parentGuid,
        TRANSFORM({levelNodes}, SELF.parentId := LEFT.nodeId, SELF.level := tLevel + 1,
        SELF := RIGHT),
        LOCAL);
        outNodes := levelNodes + nextLevelNodes + fNodes(level &amp;gt; tLevel + 1);
        RETURN outNodes;
        END; // fixupOneLevel
        outNodes := LOOP(newNodes, maxDepth, LEFT.level &amp;gt;= COUNTER,
        fixupOneLevel(ROWS(LEFT), COUNTER));
        outNodesS := SORT(outNodes, wi, treeId, level, nodeId, LOCAL);
        RETURN PROJECT(outNodesS, TreeNodeDat);
        END; // CompressNodes
        /**
        * Extract the set of tree nodes from a model
        *
        */
        EXPORT DATASET(TreeNodeDat) Model2Nodes(DATASET(Layout_Model2) mod) := FUNCTION
        // Extract nodes from model as NumericField dataset
        nfNodes := ModelOps2.ToNumericField(mod, [FM1.nodes]);
        // Distribute by wi and id for distributed processing
        nfNodesD := DISTRIBUTE(nfNodes, HASH32(wi, id));
        nfNodesG := GROUP(nfNodesD, wi, id, LOCAL);
        nfNodesS := SORT(nfNodesG, wi, id, number);
        TreeNodeDat makeNodes(NumericField rec, DATASET(NumericField) recs) := TRANSFORM
        SELF.wi := rec.wi;
        SELF.treeId := recs[FMN3.treeId].value;
        SELF.level := recs[FMN3.level].value;
        SELF.nodeId := recs[FMN3.nodeId].value;
        SELF.parentId := recs[FMN3.parentId].value;
        SELF.isLeft := recs[FMN3.isLeft].value = 1;
        SELF.number := recs[FMN3.number].value;
        SELF.value := recs[FMN3.value].value;
        SELF.isOrdinal := recs[FMN3.isOrd].value = 1;
        SELF.depend := recs[FMN3.depend].value;
        SELF.support := recs[FMN3.support].value;
        SELF.ir := recs[FMN3.ir].value;
        SELF := [];
        END;
        // Rollup individual fields into TreeNodeDat records.
        nodes := ROLLUP(nfNodesS, GROUP, makeNodes(LEFT, ROWS(LEFT)));
        // Distribute by wi and TreeId
        //nodes := DISTRIBUTE(nodes0, HASH32(wi, treeId));
        RETURN nodes;
        END;
        /**
        * Extract the set of sample indexes (i.e. bootstrap samples for each tree)
        * from a model
        *
        */
        EXPORT Model2Samples(DATASET(Layout_Model2) mod) := FUNCTION
        nfSamples := ModelOps2.ToNumericField(mod, [FM1.samples]);
        samples := PROJECT(nfSamples, TRANSFORM(sampleIndx, SELF.treeId := LEFT.id,
        SELF.id := LEFT.number,
        SELF.origId := LEFT.value));
        return samples;
        END;
        /**
        * Convert the set of nodes describing the forest to a Model Format
        *
        */
        EXPORT DATASET(Layout_Model2) Nodes2Model(DATASET(TreeNodeDat) nodes) := FUNCTION
        NumericField makeMod({TreeNodeDat, UNSIGNED recordId} d, UNSIGNED c) := TRANSFORM
        SELF.wi := d.wi;
        indx1 := CHOOSE(c, FMN3.treeId, FMN3.level, FMN3.nodeId,
        FMN3.parentId, FMN3.isLeft, FMN3.number,
        FMN3.value, FMN3.isOrd,
        FMN3.depend, FMN3.support, FMN3.ir);
        SELF.value := CHOOSE(c, d.treeId, d.level, d.nodeId, d.parentId,
        (UNSIGNED)d.isLeft, d.number, d.value, (UNSIGNED)d.isOrdinal,
        d.depend, d.support, d.ir);
        SELF.number := indx1;
        SELF.id := d.recordId;
        END;
        // Add a record id to nodes
        nodesExt := PROJECT(nodes, TRANSFORM({TreeNodeDat, UNSIGNED recordId}, SELF.recordId := COUNTER, SELF := LEFT));
        // Make into a NumericField dataset
        nfMod := NORMALIZE(nodesExt, 11, makeMod(LEFT, COUNTER));
        // Insert at position [modInd.nodes] in the ndArray
        mod := ModelOps2.FromNumericField(nfMod, [FM1.nodes]);
        RETURN mod;
        END;
        /**
        * Convert the set of tree sample indexes to a Model Format
        *
        */
        SHARED Indexes2Model := FUNCTION
        nfIndexes := PROJECT(treeSampleIndx, TRANSFORM(NumericField,
        SELF.wi := 0, // Not used
        SELF.id := LEFT.treeId,
        SELF.number := LEFT.id,
        SELF.value := LEFT.origId));
        indexes := ModelOps2.FromNumericField(nfIndexes, [FM1.samples]);
        return indexes;
        END;
        /**
        * Get forest model
        *
        * RF uses the Layout_Model2 format, which is implemented as an N-Dimensional
        * numeric array (i.e. ndArray.NumericArray).
        *
        * See LT_Types for the format of the model
        *
        */
        EXPORT DATASET(Layout_Model2) GetModel := FUNCTION
        nodes := GetNodes;
        mod1 := Nodes2Model(nodes);
        mod2 := Indexes2Model;
        mod := mod1 + mod2;
        RETURN mod;
        END;

        /**
        * Compress and cleanup the model
        *
        * This function is provided to reduce the size of a model by compressing out
        * branches with only one child.  These branches are a result of the RF algorithm,
        * and do not affect the results of the model.
        * This is an expensive operation, which is why it is not done as a matter of
        * course.  It reduces the size of the model somewhat, and therefore slightly speeds
        * up any processing that uses the model, and reduces storage size.
        * You may want to compress the model if storage is at a premium, or if the model
        * is to be used many times (so that the slight performance gain is multiplied).
        * This also makes the model somewhat more readable, and could
        * be useful when analyzing the tree or converting it to another system
        * (e.g. LUCI) for processing.
        *
        */
        EXPORT DATASET(Layout_Model2) CompressModel(DATASET(Layout_Model2) mod) := FUNCTION
        nodes := Model2Nodes(mod);
        cNodes := CompressNodes(nodes);
        remainderMod := mod(indexes[1] != FM1.nodes);
        cMod := Nodes2Model(cNodes) + remainderMod;
        return cMod;
        END;

        // ModelStats
        EXPORT GetModelStats(DATASET(Layout_Model2) mod) := FUNCTION
        nodes := Model2Nodes(mod);
        treeStats := TABLE(nodes, {wi, treeId, nodeCount := COUNT(GROUP), depth := MAX(GROUP, level)},
        wi, treeId);
        leafStats := TABLE(nodes(number=0), {wi, treeId, nodeCount := COUNT(GROUP), depth := AVE(GROUP, level),
        totSupt := SUM(GROUP, support),
        maxSupt := MAX(GROUP, support),
        minDepth := MIN(GROUP, level)}, wi, treeId);
        treeSumm := TABLE(treeStats, {wi,
        treeCount := COUNT(GROUP),
        minTreeDepth := MIN(GROUP, depth),
        maxTreeDepth := MAX(GROUP, depth),
        avgTreeDepth := AVE(GROUP, depth),
        minTreeNodes := MIN(GROUP, nodeCount),
        maxTreeNodes := MAX(GROUP, nodeCount),
        avgTreeNodes := AVE(GROUP, nodeCount),
        totalNodes := SUM(GROUP, nodeCount)}, wi);
        leafSumm := TABLE(leafStats, {wi, treeCount := COUNT(GROUP),
        avgLeafs := AVE(GROUP, nodeCount),
        minSupport := MIN(GROUP, totSupt),
        maxSupport := MAX(GROUP, totSupt),
        avgSupport := AVE(GROUP, totSupt),
        avgSupportPerLeaf := SUM(GROUP, totSupt) / SUM(GROUP, nodeCount),
        maxSupportPerLeaf := MAX(GROUP, maxSupt),
        avgLeafDepth := AVE(GROUP, depth),
        minLeafDepth := MIN(GROUP, minDepth)}, wi);
        allStats := JOIN(treeSumm, leafSumm, LEFT.wi = RIGHT.wi, TRANSFORM(ModelStats,
        SELF := LEFT,
        SELF := RIGHT));
        RETURN allStats;
        END;
        /**
        * Feature Importance (intenal)
        *
        * Computes feature importance based on TreeNodeDat input
        *
        */
        EXPORT FeatureImportanceNodes(DATASET(TreeNodeDat) nodes) := FUNCTION
        treeCount := MAX(nodes, treeId);
        featureStats := TABLE(nodes(number &amp;gt; 0), {wi, number, importance := SUM(GROUP, ir * support)/treeCount,
        uses := COUNT(GROUP)}, wi, number);
        fi := SORT(PROJECT(featureStats, TRANSFORM(FeatureImportanceRec, SELF := LEFT)), wi, -importance);
        RETURN fi;
        END;

        /**
        * Feature Importance
        *
        * Calculate feature importance using the Mean Decrease Impurity (MDI) method
        * from &amp;quot;Understanding Random Forests: by Gilles Loupe (https://arxiv.org/pdf/1407.7502.pdf)
        * and due to Breiman [2001, 2002]
        *
        * Each feature is ranked by:
        *   SUM for each branch node in which feature appears (across all trees):
        *     impurity_reduction * number of nodes split
        *
        */
        EXPORT FeatureImportance(DATASET(Layout_Model2) mod) := FUNCTION
        nodes := Model2Nodes(mod);
        fi := FeatureImportanceNodes(nodes);
        RETURN fi;
        END;
        // Extended tree node record
        SHARED xTreeNodeDat := RECORD(TreeNodeDat)
        SET OF UNSIGNED pathNodes;
        END;
        // Add to nodes a globally unique nodeId (i.e. &amp;apos;id&amp;apos;) as well as a set of ids for each
        // node representing the full path from the root, root and current inclusive.
        // Note that id only needs to be unique within a tree, so we use a LOCAL PROJECT.
        SHARED GetExtendedNodes(DATASET(TreeNodeDat) nodes) := FUNCTION
        nodesS := SORT(DISTRIBUTE(nodes, HASH32(wi, treeId)), wi, treeId, level, nodeId, LOCAL);
        // Calculate the ancestor id&amp;apos;s one layer at a time from the root down.
        // Root just assigns its own id.  Others append their own id to the parent&amp;apos;s id.
        xNodes0 := PROJECT(nodesS, TRANSFORM(xTreeNodeDat,
        SELF.id := COUNTER,
        SELF.pathNodes := [SELF.id],
        SELF := LEFT), LOCAL);
        loopBody(DATASET(xTreeNodeDat) n, UNSIGNED lev) := FUNCTION
        assignNodes := n(level = lev);
        parentNodes := n(level = lev - 1);
        newNodes := JOIN(assignNodes, parentNodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.parentId = RIGHT.nodeId,
        TRANSFORM(xTreeNodeDat,
        SELF.pathNodes := RIGHT.pathNodes + LEFT.pathNodes,
        SELF := LEFT), LEFT OUTER, LOCAL);
        outNodes := n(level != lev) + newNodes;
        RETURN outNodes;
        END;
        maxLevel := MAX(nodesS, level);
        // Loop for each level
        xNodes := LOOP(xNodes0, maxLevel, loopBody(ROWS(LEFT), COUNTER));
        RETURN xNodes;
        END;
        SHARED dPath := RECORD
        t_Work_Item wi;
        t_RecordId id;
        t_TreeId treeId;
        SET OF UNSIGNED4 pathNodes;
        END;
        // Returns a record for each datapoint, for each tree, that includes the path for
        // the datapoint from the root to the leaf that it falls into.
        SHARED GetDecisionPaths(DATASET(TreeNodeDat) nodes, DATASET(GenField) X) := FUNCTION
        leafs := GetLeafsForData(nodes, X);
        xnodes := GetExtendedNodes(nodes);
        dps := JOIN(leafs, xnodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND LEFT.level = RIGHT.level AND
        LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM(dPath,
        SELF.wi := LEFT.wi,
        SELF.id := LEFT.id,
        SELF.treeId := LEFT.treeId,
        SELF.pathNodes := RIGHT.pathNodes), LEFT OUTER);
        return dps;
        END;
        /**
        * Decision Distance Matrix
        *
        * Calculate a Decision Distance (DD) Matrix with one cell for each pair of points in [X1, X2].
        * If X2 is omitted, then the matrix will have one cell per pair of points in X1.
        * If X1 has N ids and X2 has M ids, then N x M records will be produced.
        * If only X1 is provided, then N x N records will be produced
        * This metric provides a number between zero and one, with zero indicating that the points
        * are very similar, and one representing maximal dissimilarity.
        * This is a distance measure within the decision space of the given random forest model.
        * 1 - DD conversely represents a similarity measure known as MeanSimilarityMeasure(MSM)
        *
        * DD(x1, x2) := 1 - MSM(x1, x2)
        * MSM(x1, x2) := MEAN for all trees (SM(tree, x1, x2)
        * SM(tree, x1, x2) := Maximum Level at which Path(tree, X1)
        *                     and Path(tree, X2) are equal / (|Path(tree, X1)| + |Path(tree, X2)| / 2)
        * Path(x) := The set of nodes from the root of the tree to the Leaf(x) inclusive.
        * |Path(x)| := The length of the set Path(x)
        *
        */
        EXPORT DecisionDistanceMatrix(DATASET(Layout_Model2) mod, DATASET(GenField) X1, DATASET(GenField) X2=empty_data) := FUNCTION
        nodes := Model2Nodes(mod);
        paths1 := SORT(GetDecisionPaths(nodes, X1), id);
        paths2 := IF(EXISTS(X2), SORT(GetDecisionPaths(nodes, X2), id), paths1);
        // Form an N x M upper triangular matrix for each tree, with values being the SM.
        sm := JOIN(paths1, paths2, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId,
        TRANSFORM({t_TreeId treeId, NumericField},
        SELF.id := LEFT.id,
        SELF.number := RIGHT.id,
        SELF.value := int.CommonPrefixLen(LEFT.pathNodes, RIGHT.pathNodes) / ((COUNT(LEFT.pathNodes) + COUNT(RIGHT.pathNodes))/2),
        SELF := LEFT));
        // Now average across trees
        // First redistribute by id, so that information for all trees for an id is on one node
        smD := DISTRIBUTE(sm, HASH32(wi, id));
        dd := TABLE(smD, {wi, id, number, REAL8 ddVal := 1 - AVE(GROUP, value)}, wi, id, number, LOCAL);
        // Return as NumericField array.
        ddm := PROJECT(dd, TRANSFORM(NumericField, SELF.value := LEFT.ddVal, SELF := LEFT), LOCAL);
        RETURN ddm;
        END; // DecisionDistanceMatrix
        /**
        * Uniqueness Factor
        *
        * Calculate how isolated each datapoint is in the decision space of the random forest
        * 0 &amp;lt; UF &amp;lt; 1, low values indicate that the datapoint is similar to other datapoints.
        * high values indicate uniqueness.
        *
        * Calculated as: SUM for all other points(Decision Distance) / (Number of Points - 1)
        *
        */
        EXPORT UniquenessFactor(DATASET(Layout_Model2) mod, DATASET(GenField) X1, DATASET(GenField) X2=empty_data) := FUNCTION
        // Get the Decision Distance Matrix
        ddm := DecisionDistanceMatrix(mod, X1, X2);
        ddmD := DISTRIBUTE(ddm, HASH32(wi, id));
        // Sum the distance for each point to every other point
        uf0 := TABLE(ddmD, {wi, id, totVal := AVE(GROUP, value)}, wi, id, LOCAL);
        uf := PROJECT(uf0, TRANSFORM(NumericField,
        SELF.number := 1,
        SELF.value := LEFT.totVal,
        SELF.wi := LEFT.wi,
        SELF.id := LEFT.id));
        RETURN uf;
        END; // Uniqueness Factor
        END; // RF_Base&amp;#10;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;commonprefixlen&quot;
        name=&quot;CommonPrefixLen&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/CommonPrefixLen.ecl&quot;
        ts=&quot;1621960363000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
        ############################################################################## */
        /**
        * Return the the length of the longest common prefix between two id-lists
        *
        * General Function on a list (i.e. ordered set)
        *
        * @param s1 The first list (SET OF UNSIGNED4)
        * @param s2 The second list (SET OF UNSIGNED4)
        *
        * @return The prefix size
        */
        EXPORT UNSIGNED4 CommonPrefixLen(SET OF UNSIGNED4 s1, SET OF UNSIGNED4 s2) := BEGINC++
        #option pure
        uint32_t * st1 = (uint32_t *) s1;
        uint32_t * st2 = (uint32_t *) s2;
        uint32_t i;
        uint32_t maxPrefix = lenS1 &amp;lt; lenS2 ? lenS1 / sizeof(uint32_t) : lenS2 / sizeof(uint32_t);
        for (i=0; i &amp;lt; maxPrefix; i++) {
        if (st1[i] != st2[i]) {
        return i;
        }
        }
        return maxPrefix;
        ENDC++;&amp;#10;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;rf_classification&quot;
        name=&quot;RF_Classification&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/LearningTrees/V1_1_1/LearningTrees/internal/RF_Classification.ecl&quot;
        ts=&quot;1621960363000000&quot;&gt;
        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2017 HPCC Systems®.  All rights reserved.
        ############################################################################## */
        IMPORT $.^ AS LT;
        IMPORT LT.internal AS int;
        IMPORT LT.LT_Types AS Types;
        IMPORT ML_Core as ML;
        IMPORT ML.Types AS CTypes;
        IMPORT std.system.Thorlib;
        IMPORT ML_Core.ModelOps2;

        GenField := Types.GenField;
        TreeNodeDat := Types.TreeNodeDat;
        SplitDat := Types.SplitDat;
        NodeImpurity := Types.NodeImpurity;
        wiInfo := Types.wiInfo;t_Work_Item := CTypes.t_Work_Item;
        t_Count := CTypes.t_Count;
        t_RecordId := CTypes.t_RecordID;
        t_FieldNumber := CTypes.t_FieldNumber;
        t_TreeId := t_FieldNumber;
        t_FieldReal := CTypes.t_FieldReal;
        t_Discrete := CTypes.t_Discrete;
        Layout_Model := CTypes.Layout_Model;
        t_NodeId := Types.t_NodeId;
        DiscreteField := CTypes.DiscreteField;
        NumericField := CTypes.NumericField;
        Layout_Model2 := CTypes.Layout_Model2;
        ClassProbs := Types.ClassProbs;
        ClassWeightsRec := Types.ClassWeightsRec;
        nfNull := DATASET([], NumericField);

        /**
        * Classification Forest Module
        *
        * This module provides a Random Forest Classifier based on Breiman, 2001
        * with extensions.
        *
        * See RF_Base for a description of the Theory of Operation of this module.
        */
        EXPORT RF_Classification(DATASET(GenField) X_in=DATASET([], GenField),
        DATASET(GenField) Y_In=DATASET([], GenField),
        UNSIGNED numTrees=100,
        UNSIGNED featuresPerNode=0,
        UNSIGNED maxDepth=255,
        DATASET(NumericField) observWeights=nfNull)
        := MODULE(int.RF_Base(X_in, Y_in, numTrees,
        featuresPerNode, maxDepth, observWeights))
        SHARED minImpurity := .0000001;   // Nodes with impurity less than this are considered pure.
        SHARED classWeights := FUNCTION
        minClassWeight := .25; // Offset so that no weight can approach zero.
        // The weight of each class is assigned as a logarithmic inverse of the class frequency
        Y_DS := DISTRIBUTE(Y_in, HASH32(wi, value));
        classCounts := TABLE(Y_DS, {wi, value, cnt := COUNT(GROUP)}, wi, value);
        // Calculate the weights as classWeight(class) := -LN(&amp;lt;proportion of records of class&amp;gt;) + minClassWeight
        classWeights := JOIN(classCounts, wiMeta, LEFT.wi = RIGHT.wi, TRANSFORM(classWeightsRec,
        SELF.wi := LEFT.wi,
        SELF.classLabel := LEFT.value,
        SELF.weight := -LN(LEFT.cnt / RIGHT.numSamples) + minClassWeight), LOOKUP);
        return classWeights;
        END;
        // Find the best split for a given set of nodes.  In this case, it is the one with the highest information
        // gain.  Every possible split point is considered for each independent variable in the tree.
        // For nominal variables, the split is an equality split on one of the possible values for that variable
        // (i.e. split into = s and != s).  For ordinal variables, the split is an inequality (i.e. split into &amp;lt;= s and &amp;gt; s)
        // For each node, the split with the highest Information Gain (IG) is returned.
        SHARED DATASET(SplitDat) findBestSplit(DATASET(TreeNodeDat) nodeVarDat, DATASET(NodeImpurity) parentEntropy) := FUNCTION
        // Calculate the Information Gain (IG) for each split.
        // IG := Entropy(H) of Parent - Entropy(H) of the proposed split := H-parent - SUM(prob(child) * H-child) for each child group of the split
        // IV := -SUM(Prob(x) * Log2(Prob(x)) for all values of X independent variable
        // H := -SUM(Prob(y) * Log2(Prob(y)) for all values of Y dependent variable
        // At this point, nodeVarDat has one record per node per selected feature per id
        // Start by getting a list of all the values for each feature per node
        featureVals := TABLE(nodeVarDat, {wi, treeId, nodeId, number, value, isOrdinal,
        cnt := COUNT(GROUP),
        BOOLEAN rmVal := 0}, // rmVal is used later in computing split points
        wi, treeId, nodeId, number, value, isOrdinal, LOCAL);

        // Calculate the number of values per feature per node.
        features := TABLE(featureVals, {wi, treeId, nodeId, number, isOrdinal, tot := SUM(GROUP, cnt),
        vals := COUNT(GROUP)},
        wi, treeId, nodeId, number, isOrdinal, LOCAL);
        // We want to eliminate constant features (i.e. features with only one value for a node) from
        // consideration.  But we have to guard against the case where all of the selected features are
        // constant.  To do that, we save one constant feature per node in case we have to resort to
        // using it later.
        constantFeatures := features(vals = 1);
        dummySplits := DEDUP(constantFeatures, wi, treeId, nodeId, LOCAL);
        goodFeatures := features(vals &amp;gt; 1);
        // Calculate split points for each feature such that:
        // - for ordered features, the split value is the midpoint between actual values
        // - for ordered features, we remove the first value so that we have N-1 split points if there are N values.
        // - for categorical featues, no changes are made.  Each value is a valid split point (using equality).
        splitPoints0 := SORT(featureVals, wi, treeId, nodeId, number, value, LOCAL);
        // Compute the split points mid-way between values.  Use rmVal to mark the initial value for each feature
        // for later removal.
        {featureVals} doOneIter({featureVals} l, {featureVals} r) := TRANSFORM
        // is this the first record of the group (i.e. wi, treeId, nodeId, number)?
        BOOLEAN firstRec := NOT (l.wi = r.wi AND l.treeId = r.treeId AND
        l.nodeId = r.nodeId AND l.number = r.number);
        // If it&amp;apos;s an ordered feature, and not the first record, use the midpoint.
        SELF.value := IF(r.isOrdinal AND not firstRec, (l.value + r.value)/2, r.value);
        // If this is an ordered feature and it is the first record of the group, mark it for deletion.
        SELF.rmVal := r.isOrdinal AND firstRec;
        SELF := r;
        END;
        splitPoints1 := ITERATE(splitPoints0, doOneIter(LEFT, RIGHT), LOCAL);
        splitPoints := splitPoints1(rmVal = FALSE);
        // Auto-binning occurs here (if enabled). If there are more values for
        // a feature than autobinSize, randomly select potential split values with probability:
        // 1/(number-of-values / autobinSize).
        // Note: For efficiency, we use autobinSize * 2**32-1 so that we can directly compare to RANDOM()
        //       without having to divide by 2**32-1
        // Non-selected split points are marked via rmVal
        // Note that any constant features are also eliminated by the use of goodFeatures.
        splitInfo0 := JOIN(splitPoints, goodFeatures, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId
        AND LEFT.nodeId = RIGHT.nodeId AND LEFT.number = RIGHT.number,
        TRANSFORM({featureVals},
        SELF.rmVal := LEFT.isOrdinal AND
        autoBin = TRUE AND RIGHT.vals &amp;gt; autobinSize AND
        RANDOM() &amp;gt; autobinSizeScald/RIGHT.vals,
        SELF := LEFT), LOCAL);
        // Now get rid of all the marked split points.
        splitInfo := splitInfo0(rmVal = FALSE);
        // Replicate each datapoint for the node to every possible split for that node
        // Mark each datapoint as being left or right of the split.  Handle both Ordinal and Nominal cases.
        allSplitDat := JOIN(nodeVarDat, splitInfo, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId
        AND RIGHT.nodeId = LEFT.nodeId AND LEFT.number = RIGHT.number,
        TRANSFORM({TreeNodeDat, t_FieldReal splitVal},
        SELF.splitVal := RIGHT.value,
        SELF.isLEFT := IF((LEFT.isOrdinal AND LEFT.value &amp;lt;= SELF.splitVal)
        OR (NOT LEFT.isOrdinal AND LEFT.value = SELF.splitVal),TRUE, FALSE),
        SELF := LEFT), LOCAL);
        // Calculate the entropy of the left and right groups of each split
        // Group by value of Y (depend) for left and right splits
        dependGroups := TABLE(allSplitDat, {wi, treeId, nodeId, number, splitVal, isLeft, depend,
        isOrdinal, UNSIGNED cnt := COUNT(GROUP),
        REAL weightSum := SUM(GROUP, observWeight)},
        wi, treeId, nodeId, number, splitVal, isLeft, depend, isOrdinal, LOCAL);
        // Sum up the number of data points for left and right splits
        dependSummary := TABLE(dependGroups, {wi, treeId, nodeId, number, splitVal, isLeft,
        REAL totWeights := SUM(GROUP, weightSum)},
        wi, treeId, nodeId, number, splitVal, isLeft, LOCAL);
        // Calculate p_log_p for each Y value for left and right splits
        dependRatios := JOIN(dependGroups, dependSummary,
        LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND LEFT.nodeId = RIGHT.nodeId AND
        LEFT.number = RIGHT.number AND LEFT.splitVal = RIGHT.splitVal
        AND LEFT.isLeft = RIGHT.isLeft,
        TRANSFORM({dependGroups, REAL prop, REAL plogp},
        SELF.prop := LEFT.weightSum / RIGHT.totWeights, SELF.plogp := P_Log_P(SELF.prop),
        SELF := LEFT),
        LOCAL);
        // Sum the p_log_p&amp;apos;s for each Y value to get the entropy of the left and right splits.
        lr_entropies := TABLE(dependRatios, {wi, treeId, nodeId, number, splitVal, isLeft, isOrdinal, tot := SUM(GROUP, cnt),
        entropy := SUM(GROUP, plogp)},
        wi, treeId, nodeId, number, splitVal, isLeft, isOrdinal, LOCAL);
        // Now calculate the weighted average of entropies of the two groups (weighted by number of datapoints in each)
        // Note that &amp;apos;tot&amp;apos; is number of datapoints for each side of the split.
        entropies0 := TABLE(lr_entropies, {wi, treeId, nodeId, number, splitVal, isOrdinal,
        REAL totEntropy := SUM(GROUP, entropy * tot) / SUM(GROUP, tot)},
        wi, treeId, nodeId, number, splitVal, isOrdinal, LOCAL);
        entropies := SORT(entropies0, wi, treeId, nodeId, totEntropy, LOCAL);
        // We only care about the split with the lowest entropy for each tree node.  Since the parentEntropy
        // is constant for a given tree node, the split with the lowest entropy will also be the split
        // with the highest Information Gain.
        lowestEntropies := DEDUP(entropies, wi, treeId, nodeId, LOCAL);
        // Now calculate Information Gain
        // In order to stop the tree-building process when there is no split that gives information-gain
        // we set &amp;apos;number&amp;apos; to zero to indicate that there is no best split when we hit that case.
        // That happens when the data is not fully separable by the independent variables.
        // Not that field ir (impurity reduction) is a generic term that encompasses ig.
        // In the case where there are no valid (non constant) features to split on, we mark the node by
        // setting &amp;apos;number&amp;apos; to maxU4 so we can fix it up later.
        ig := JOIN(lowestEntropies, parentEntropy, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM({entropies, t_NodeID parentId, BOOLEAN isLeft, REAL ir, t_RecordId support},
        SELF.ir := IF(LEFT.number &amp;gt; 0, RIGHT.impurity - LEFT.totEntropy, 0),
        SELF.number := IF(LEFT.number = 0 AND allowNoProgress, maxU4, IF(SELF.ir &amp;gt; 0 OR allowNoProgress,
        LEFT.number, 0)),
        SELF.wi := RIGHT.wi,
        SELF.treeId := RIGHT.treeId,
        SELF.nodeId := RIGHT.nodeId,
        SELF.parentId := RIGHT.parentId,
        SELF.isLeft := RIGHT.isLeft,
        SELF.support := RIGHT.support,
        SELF := LEFT
        ),
        RIGHT OUTER, LOCAL);
        // Choose the split with the greatest information gain for each node.
        // In the case where we had no non-constant splits we fill in with an arbitrary one of the constant
        // splits so that we can keep the tree growing with the next set of selected features on the next
        // round.  Otherwise, the tree would be truncated.
        bestSplits := JOIN(ig, dummySplits, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM(SplitDat,
        SELF.number := IF(LEFT.number = maxU4, RIGHT.number, LEFT.number),
        SELF.splitVal := IF(LEFT.number = maxU4, maxR8, LEFT.splitVal), // Force LEFT
        SELF.isOrdinal := IF(LEFT.number = maxU4, RIGHT.isOrdinal, LEFT.isOrdinal),
        SELF := LEFT), LEFT OUTER, LOCAL);

        RETURN bestSplits;
        END;
        // Grow one layer of the forest
        SHARED DATASET(TreeNodeDat) GrowForestLevel(DATASET(TreeNodeDat) nodeDat, t_Count treeLevel) := FUNCTION
        // At this point, nodes contains one element per wi, treeId, nodeId and id within the node.
        // The number field is not used at this point, nor is the value field.  The depend field has
        // the dependent value (Y) for each id.
        // Calculate the Impurity for each node.
        // NodeValCounts has one record per node, per value of the dependent variable (Y)
        nodeValCounts := TABLE(nodeDat, {wi, treeId, nodeId, depend, parentId, isLeft, cnt:= COUNT(GROUP),
        REAL weightSum := SUM(GROUP, observWeight)},
        wi, treeId, nodeId, depend, parentId, isLeft, LOCAL);

        // NodeCounts is the count of data items for the node
        nodeCounts := TABLE(nodeValCounts, {wi, treeId, nodeId, tot:= SUM(GROUP, cnt),
        REAL totWeights := SUM(GROUP, weightSum)},
        wi, treeId, nodeId, LOCAL);
        // Now we can calculate the information entropy for each node
        // Entropy is defined as SUM(plogp(proportion of each Y value)) for each Y value
        nodeEntInfo := JOIN(nodeValCounts, nodeCounts, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM({nodeValCounts, REAL4 prop, REAL4 plogp}, SELF.prop:= LEFT.weightSum/RIGHT.totWeights,
        SELF.plogp:= P_LOG_P(LEFT.weightSum/RIGHT.totWeights),
        , SELF:=LEFT), LOCAL);
        // Note that for any (wi, treeId, nodeId), parentId and isLeft will be constant, but we need to carry
        //   them forward.
        nodeEnt0 := TABLE(nodeEntInfo, {wi, treeId, nodeId, parentId, isLeft,
        entropy := SUM(GROUP, plogp),
        t_RecordId tot := SUM(GROUP, cnt)},
        wi, treeId, nodeId, parentId, isLeft, LOCAL);
        // Node impurity
        nodeImp := PROJECT(nodeEnt0, TRANSFORM(NodeImpurity, SELF.impurity := LEFT.entropy,
        SELF.support := LEFT.tot,
        SELF := LEFT));

        // Filtering pure and non-pure nodes. We translate any pure nodes and their associated data into a leaf node.
        // Impure nodes need further splitting, so they are passed into the next phase.
        // If we are at maxDepth, consider everything pure enough.
        pureEnoughNodes := nodeImp(impurity &amp;lt; minImpurity OR treeLevel = maxDepth);  // Nodes considered pure enough.

        // Eliminate any data associated with the leafNodes from the original node data.  What&amp;apos;s left
        // is the data for the impure nodes that still need to be split
        toSplitNodes := JOIN(nodeCounts, pureEnoughNodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM(TreeNodeDat, SELF := LEFT, SELF := []),
        LEFT ONLY, LOCAL);
        // Choose a random set of feature on which to split each node
        // At this point, we have one record per tree, node, and number (for selected features)
        toSplitVars := SelectVarsForNodes(toSplitNodes);

        // Now, extend the values of each of those features (X) for each id
        // Use the indices to get the corresponding X value for each field.
        // Redistribute by id to match up with the original X data
        toSplitDat0 := JOIN(toSplitVars, nodeDat, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId, TRANSFORM(TreeNodeDat, SELF.number := LEFT.number,
        SELF := RIGHT), LOCAL);
        // Redistribute by id to match up with the original X data, and sort to align the JOIN.
        toSplitDat1:= SORT(DISTRIBUTE(toSplitDat0, HASH32(wi, origId)), wi, origId, number, LOCAL);
        toSplitDat2 := JOIN(toSplitDat1, X, LEFT.wi = RIGHT.wi AND LEFT.origId=RIGHT.id AND LEFT.number=RIGHT.number,
        TRANSFORM(TreeNodeDat, SELF.value := RIGHT.value, SELF.isOrdinal := RIGHT.isOrdinal, SELF := LEFT),
        LOCAL);
        // Now redistribute the results by treeId for further analysis.  Sort for further analysis.
        toSplitDat := DISTRIBUTE(toSplitDat2, HASH32(wi, treeId));

        // Filter nodeImp so that only the &amp;quot;not pure enough&amp;quot; nodes are included.  This is important
        // because we use this as the set of nodes for which we need to find best splits.
        parentNodeImp := nodeImp(impurity &amp;gt;= minImpurity AND treeLevel &amp;lt; maxDepth);

        // Now try all the possible splits and find the best
        bestSplits := findBestSplit(toSplitDat, parentNodeImp);

        // Reasonable splits were found
        goodSplits := bestSplits(number != 0);
        // No split made any progress, or we are at maxDepth for the tree
        badSplits := bestSplits(number = 0);

        // Remove from toSplitDat any cells that are 1) from a bad split or 2) for a feature that was
        // not chosen as the best split. Call it goodSplitDat.
        goodSplitDat := JOIN(toSplitDat, goodSplits, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId AND LEFT.number = RIGHT.number, TRANSFORM(LEFT), LOCAL);
        // Now, create a split node and two child nodes for each split.
        // First move the data to new child nodes.
        // Start by finding the data samples that fit into the left and the right

        leftIds := JOIN(goodSplits, goodSplitDat, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId AND LEFT.number = RIGHT.number AND
        ((RIGHT.isOrdinal AND RIGHT.value &amp;lt;= LEFT.splitVal) OR
        (NOT RIGHT.isOrdinal AND RIGHT.value = LEFT.splitVal)),
        TRANSFORM({t_Work_Item wi, t_TreeId treeId, t_NodeId nodeId, t_RecordId id},
        SELF.treeId := LEFT.treeId, SELF.nodeId := LEFT.nodeId, SELF.id := RIGHT.id,
        SELF.wi := RIGHT.wi),
        LOCAL);
        // Assign the data ids to either the left or right branch at the next level
        // All of the node data for the left split (i.e. for Ordinal data: where val &amp;lt;= splitVal,
        //  for Nominal data: where val = splitVal) is marked LEFT.
        // All the node data for the right split(i.e. for Ordinal data: where val &amp;gt; splitVal,
        //  for Nominal data: where val &amp;lt;&amp;gt; splitVal) is marked NOT LEFT
        // Note that nodeIds only need to be unique within a level.
        // Left ids are assigned every other value (1, 3, 5, ...) to leave room for the rights,
        // which will be left plus 1 for a given parent node.  This provides an inexpensive way to assign
        // ids at the next level (though it opens the door for overflow of nodeId).  We handle that
        // case later.
        // Note that &amp;apos;number&amp;apos; is set to zero for next level data.  New features will be selected next time around.
        LR_nextLevel := JOIN(goodSplitDat, leftIds, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId AND LEFT.id = RIGHT.id,
        TRANSFORM(TreeNodeDat, SELF.level := treeLevel + 1,
        SELF.nodeId := IF(RIGHT.treeId &amp;gt; 0, LEFT.nodeId * 2 - 1, LEFT.nodeId * 2),
        SELF.parentId := LEFT.nodeId,
        SELF.isLeft := IF(RIGHT.treeId &amp;gt; 0, TRUE, FALSE),
        SELF.number := 0;
        SELF := LEFT), LEFT OUTER, LOCAL);

        // Occasionally, recalculate the nodeIds to make them contiguous to avoid an overflow
        // error when the trees get very deep.  Note that nodeId only needs to be unique within
        // a level.  It is not required that they be a function of the parent&amp;apos;s id since parentId will
        // anchor the child to its parent.
        nextLevelIds := TABLE(LR_nextLevel, {wi, treeId, nodeId, t_NodeID newId := 0}, wi, treeId, nodeId, LOCAL);
        nextLevelIdsG := GROUP(nextLevelIds, wi, treeId, LOCAL);
        newIdsG := PROJECT(nextLevelIdsG, TRANSFORM({nextLevelIds}, SELF.newId := COUNTER, SELF := LEFT));
        newIds := UNGROUP(newIdsG);
        fixupIds := SORT(JOIN(LR_nextLevel, newIds, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM(TreeNodeDat, SELF.nodeId := RIGHT.newId, SELF := LEFT), LOCAL), wi, treeId, nodeId, LOCAL);
        maxNodeId := MAX(LR_nextLevel, nodeId);
        // 2**48 is the optimum wrap point.  It allows us to reorganize as infrequently as possible, yet will fit into
        // a Layout_Model2 field.
        nextLevelDat := IF(maxNodeId &amp;gt;= POWER(2, 48), fixupIds, LR_nextLevel);
        // Now reduce each splitNode to a single skeleton node with no data.
        // For a split node (i.e. branch), we only use treeId, nodeId, number (the field number to split on), value (the value to split on), and parent-id
        splitNodes := PROJECT(goodSplits, TRANSFORM(TreeNodeDat, SELF.level := treeLevel, SELF.wi := LEFT.wi,
        SELF.treeId := LEFT.treeId,
        SELF.nodeId := LEFT.nodeId, self.number := LEFT.number, self.value := LEFT.splitVal,
        SELF.isOrdinal := LEFT.isOrdinal,
        SELF.parentId := LEFT.parentId,
        SELF.isLeft := LEFT.isLeft,
        SELF.support := LEFT.support,
        SELF.ir := LEFT.ir,
        SELF := []));
        // Now handle the leaf nodes, which are the pure-enough nodes, plus the bad splits (i.e. no good
        // split left).
        // Handle the badSplit case: there&amp;apos;s no feature that will further split the data = mixed leaf node.
        // Classify the point according to the most frequent class, and create a leaf node to summarize it.
        mixedLeafs0 := JOIN(nodeValCounts, badSplits, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM(TreeNodeDat, SELF.wi := LEFT.wi, SELF.level := treeLevel,
        SELF.treeId := LEFT.treeId, SELF.nodeId := LEFT.nodeId,
        SELF.parentId := LEFT.parentId, SELF.isLeft := LEFT.isLeft, SELF.id := 0, SELF.number := 0,
        SELF.depend := LEFT.depend, SELF.support := LEFT.cnt, SELF := []), LOCAL);
        mixedLeafs1 := SORT(mixedLeafs0, wi, treeId, nodeId, -support, LOCAL);
        mixedLeafs := DEDUP(mixedLeafs1, wi, treeId, nodeId, LOCAL); // Finds the most common value
        // Create a single leaf node instance to summarize each pure node&amp;apos;s data
        // The leaf node instance only has a few significant attributes:  The tree and node id,
        // the dependent value, and the level, as well
        // as the support (i.e. the number of data points that fell into that leaf).
        pureNodes0 := JOIN(nodeValCounts, pureEnoughNodes, LEFT.wi = RIGHT.wi AND LEFT.treeId = RIGHT.treeId AND
        LEFT.nodeId = RIGHT.nodeId,
        TRANSFORM(TreeNodeDat, SELF.wi := LEFT.wi, SELF.level := treeLevel,
        SELF.treeId := LEFT.treeId, SELF.nodeId := LEFT.nodeId,
        SELF.parentId := LEFT.parentId,
        SELF.isLeft := LEFT.isLeft, SELF.id := 0, SELF.number := 0,
        SELF.depend := LEFT.depend, SELF.support := LEFT.cnt, SELF := []), LOCAL);
        // On the last time through, we might have some mixed nodes coming in as leaf nodes.  In that case, we need
        // to only output the class with the highest occurrence within the node.
        pureNodes1 := SORT(pureNodes0, wi, treeId, nodeId, -support, LOCAL);
        pureNodes2 := DEDUP(pureNodes1, wi, treeId, nodeId, LOCAL); // Finds the most common value
        pureNodes := IF(treeLevel = maxDepth, pureNodes2, pureNodes0);
        leafNodes := pureNodes + mixedLeafs;
        // Return the three types of nodes: leafs at this level, splits (branches) at this level, and nodes at
        // the next level (children of the branches).
        RETURN leafNodes + splitNodes + nextLevelDat;
        END;

        SHARED emptyClassWeights := DATASET([], classWeightsRec);
        // Get the probability of each sample belonging to each class,
        // given an expanded forest model (set of tree nodes)
        // Note that &amp;apos;probability&amp;apos; is used loosely here as a percentage
        // of trees that voted for each class.
        EXPORT DATASET(ClassProbs) FClassProbabilities(DATASET(TreeNodeDat) tNodes, DATASET(GenField) X,
        DATASET(classWeightsRec) classWts=emptyClassWeights) := FUNCTION
        modTreeCount := MAX(tNodes, treeId);  // Number of trees in the model
        selectedLeafs := GetLeafsForData(tNodes, X);
        // At this point, we have one leaf node per tree per datapoint (X)
        // The leaf nodes contain the final class in their &amp;apos;depend&amp;apos; field.
        // Now we need to count the votes for each class and id
        // Calculate raw (unweighted) probabilities
        probs0 := TABLE(selectedLeafs, {wi, id, depend, cnt := COUNT(GROUP), prob := COUNT(GROUP) / modTreeCount},
        wi, id, depend, LOCAL);
        // Function to calculate weighted probabilities.
        calcWeightedProbs := FUNCTION
        // Calculate prob * weight for each id
        wprobs0 := JOIN(probs0, classWts, LEFT.wi = RIGHT.wi AND
        LEFT.depend = RIGHT.classLabel,
        TRANSFORM({probs0}, SELF.prob := LEFT.prob * RIGHT.weight,
        SELF := LEFT), LOOKUP);
        // Normalize based on the sum of weighted probabilities for each id
        totWprobs := TABLE(wprobs0, {wi, id, tot := SUM(GROUP, prob)}, wi, id, LOCAL);
        wprobs := JOIN(wprobs0, totWprobs, LEFT.wi = RIGHT.wi AND LEFT.id = RIGHT.id,
        TRANSFORM({wprobs0}, SELF.prob := LEFT.prob / RIGHT.tot, SELF := LEFT), LOCAL);
        // Return prob = raw_prob * weight / SUM(raw_prob * weight) for each id
        return wprobs;
        END; // calcWeightedProbs
        // If weights were provided, use weighted probs, otherwise raw probs
        wprobs := IF(EXISTS(classWts), calcWeightedProbs, probs0);
        // Now one record per datapoint per value of depend (Y) with the count of &amp;apos;votes&amp;apos; and
        // proportion of votes (raw prob) or class weighted proportion for each depend value.
        RETURN PROJECT(wprobs, TRANSFORM(ClassProbs, SELF.class := LEFT.depend, SELF := LEFT));
        END; // FClassProbabilities

        // Produce a class for each X sample given an expanded forest model (set of tree nodes)
        EXPORT DATASET(DiscreteField) ForestClassify(DATASET(TreeNodeDat) tNodes,
        DATASET(GenField) X,
        DATASET(classWeightsRec) classWts=emptyClassWeights) := FUNCTION
        // Get the probabilities of each sample
        probs := FClassProbabilities(tNodes, X, classWts);
        probsExt := PROJECT(probs, TRANSFORM({probs, UNSIGNED rnd}, SELF.rnd := RANDOM(), SELF := LEFT), LOCAL);
        // Reduce to one record per datapoint, with the highest class probability winning
        probsS := SORT(probsExt, wi, id, -prob, rnd, LOCAL);
        // Keep the first leaf value for each wi and id.  That is the one with the highest probability
        selectedClasses := DEDUP(probsS, wi, id, LOCAL);
        // Transform to discrete field
        results := PROJECT(selectedClasses, TRANSFORM(DiscreteField, SELF.number := 1, SELF.value := LEFT.class, SELF := LEFT));
        RETURN results;
        END;
        /**
        * Extract the class weights dataset from the model
        *
        */
        EXPORT Model2ClassWeights(DATASET(Layout_Model2) mod) := FUNCTION
        modCW := ModelOps2.Extract(mod, [FM1.classWeights]);
        cw := PROJECT(modCW, TRANSFORM(classWeightsRec, SELF.wi := LEFT.wi, SELF.classLabel := LEFT.indexes[1],
        SELF.weight := LEFT.value));
        RETURN cw;
        END;

        // Use the supplied forest model to predict the ClassLabel(Y) for a set of X values.
        // Optionally use class balancing to weight the classes inversely proportional to their
        // frequency in the training data.
        EXPORT DATASET(DiscreteField) Classify(DATASET(GenField) X, DATASET(Layout_Model2) mod,
        BOOLEAN balanceClasses=FALSE) := FUNCTION
        tNodes := Model2Nodes(mod);
        classWts := Model2ClassWeights(mod);
        classes := IF(balanceClasses, ForestClassify(tNodes, X, classWts), ForestClassify(tNodes, X));
        RETURN classes;
        END;

        // Get Class Probabilities.
        // Note that probabilities here are the (optionally class weighted) proportion of trees that
        // &amp;apos;voted&amp;apos; for each class, for each X sample.
        EXPORT DATASET(ClassProbs) GetClassProbs(DATASET(GenField) X, DATASET(Layout_Model2) mod,
        BOOLEAN balanceClasses=FALSE) := FUNCTION
        tNodes := Model2Nodes(mod);
        classWts := Model2ClassWeights(mod);
        probs := IF(balanceClasses, FClassProbabilities(tNodes, X, classWts),FClassProbabilities(tNodes, X));
        RETURN probs;
        END;
        /**
        * Get forest model
        *
        * Overlays the GetModel function of RF Base to provide additional information
        * used only for classification.
        * Adds the class weights, which are only used for classification
        *
        * RF uses the Layout_Model2 format
        *
        * See LT_Types for the format of the model
        *
        */
        EXPORT DATASET(Layout_Model2) GetModel := FUNCTION
        nodes := GetNodes;
        mod1 := Nodes2Model(nodes);
        mod2 := Indexes2Model;
        baseMod := mod1 + mod2;
        naClassWeights := PROJECT(classWeights, TRANSFORM(Layout_Model2, SELF.wi := LEFT.wi,
        SELF.indexes := [FM1.classWeights, LEFT.classLabel],
        SELF.value := LEFT.weight));
        mod := baseMod + naClassWeights;
        RETURN mod;
        END;
        END; // RF_Classification
        &lt;/Attribute&gt;
        &lt;/Module&gt;
        &lt;Module key=&quot;_versions.ml_core.v3_2_2.ml_core.math&quot; name=&quot;_versions.ML_Core.V3_2_2.ML_Core.Math&quot;&gt;
        &lt;Attribute key=&quot;distributions&quot;
        name=&quot;Distributions&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Math/Distributions.ecl&quot;
        ts=&quot;1621960335000000&quot;&gt;
        //Normal, Student and Chi Squared distributions for tests
        IMPORT $.^.Constants AS Core_Const;
        IMPORT $ AS Math;
        /**
        * &amp;lt;p&amp;gt;Compute PDF, CDF, and PPF values for various Probability Distributions.
        * &amp;lt;p&amp;gt;The Probability Density Function(PDF(x)) of a distribution is
        * the relative likelihood of a sample drawn from that distribution being
        * of value x.
        * &amp;lt;p&amp;gt;The Cumulative Distribution Function (CDF(x)) of a distribution
        * is the probability of a sample drawn from that distribution to be
        * less than or equal to x.
        * &amp;lt;p&amp;gt;The Percentage Point Function (PPF(x)) of a distribution is the
        * inverse of the CDF.  Given a probability, it returns the value
        * at which the probability of occurrence is less than or equal to the
        * given probability.
        **/
        EXPORT Distributions := MODULE
        /**
        * Cumulative Distribution Function (CDF) of the standard normal distribution. The
        * probability that a normal random variable will be smaller than
        * or equal to x standard deviations above or below the mean.
        * &amp;lt;p&amp;gt;Taken from C/C++ Mathematical Algorithms for Scientists and
        * Engineers, n. Shammas, McGraw-Hill, 1995.
        * @param x the number of standard deviations.
        * @return probability of exceeding x.
        **/
        EXPORT REAL8 Normal_CDF(REAL8 x) := DEFINE FUNCTION
        b1 := 0.319381530;
        b2 :=-0.356563782;
        b3 := 1.781477937;
        b4 :=-1.821255978;
        b5 := 1.330274429;
        xp1 := 1.0 / (1.0 + 0.2316419*ABS(x));
        xp2 := xp1*xp1;
        xp3 := xp2*xp1;
        xp4 := xp3*xp1;
        xp5 := xp4*xp1;
        term_sum := xp1*b1 + xp2*b2 + xp3*b3 + xp4*b4 + xp5*b5;
        recip_sqrt_2_pi := 0.39894228040143;
        rslt0 := exp(-x*x/2) * recip_sqrt_2_pi * term_sum;
        rslt := IF(x&amp;gt;=0.0, 1-rslt0, rslt0);
        RETURN rslt;
        END;

        /**
        * Percentage Point Function (PPF) for the Normal Distribution.
        * &amp;lt;p&amp;gt;Translated from C/C++ Mathematical Algorithms for Scientists and
        * Engineers, N. Shammas, McGraw-Hill, 1995.
        * @param x probability.
        * @return number of standard deviations from the mean.
        */
        EXPORT REAL8 Normal_PPF(REAL8 x) := DEFINE FUNCTION
        p0 := -0.322232431088;
        p1 := -1.0;
        p2 := -0.342242088547;
        p3 := -0.204231210245e-1;
        p4 := -0.453642210148e-4;
        q0 :=  0.993484626060e-1;
        q1 :=  0.588581570495;
        q2 :=  0.531103462366;
        q3 :=  0.103537752850;
        q4 :=  0.38560700634e-2;
        x0 := MAP(x&amp;lt;=0.0 =&amp;gt; 0.0001, x&amp;gt;=1.0 =&amp;gt; 0.9999, x);
        xp := SQRT(-2.0 * LN(IF(x0&amp;lt;=0.5, x0, 1-x0)));
        numerator := ((((p4*xp+p3)*xp+p2)*xp+p1)*xp+p0);
        denominator := ((((q4*xp+q3)*xp+q2)*xp+q1)*xp+q0);
        rslt0 := xp + numerator/denominator;
        RETURN MAP(x0=0.5  =&amp;gt; 0.0,
        x0&amp;lt;0.5  =&amp;gt; -rslt0,
        rslt0);
        END;

        // Helper for Students distribution
        REAL8 Sum_Terms(INTEGER4 df, REAL8 c, REAL8 csq) := BEGINC++
        #option pure;
        double work_sum = (df%2==0) ? 1.0  : c;
        double work_term = (df%2==0) ? 1.0  : c;
        int start = (df%2==0) ? 2  : 3;
        int stop = (df - 2);
        for (int i=start; i&amp;lt;=stop; i+=2) {
        work_term *= csq * (((double)(i-1.0))/((double)i));
        work_sum  += work_term;
        }
        return work_sum;
        ENDC++;
        /**
        * Cumulative Distribution Function (CDF) for Students t distribution.
        * &amp;lt;p&amp;gt;The integral evaluated between negative
        * infinity and x.
        * &amp;lt;p&amp;gt;Translated from NIST SEL DATAPAC Fortran TCDF.f source.
        * @param x value of the evaluation.
        * @param df degrees of freedom.
        * @return the probability that a value will be less than or equal to the
        * specified value.
        **/
        EXPORT REAL8 T_CDF(REAL8 x, REAL8 df) := DEFINE FUNCTION
        INTEGER4 DF_Cut := 1000;
        REAL8 PI := Core_Const.Pi;
        INTEGER4 ndf := (INTEGER4) df;
        BOOLEAN isEven := ndf%2 = 0;
        // Small and moderate df definitions
        REAL8 sd := SQRT(df/(df-2.0));
        REAL8 z := x/sd;
        REAL8 c := SQRT(df/(x*x+df));
        REAL8 csq := df/(x*x+df);
        REAL8 s := x/SQRT(x*x+df);
        REAL8 sum_terms := MAP(
        df=1  =&amp;gt; (2/PI)*(ATAN(x)),
        df=2  =&amp;gt; s,
        df=3  =&amp;gt; (2/PI)*(ATAN(x/SQRT(df))+(c*s)),
        isEven=&amp;gt; Sum_Terms(df, c, csq) * s,
        (2/PI)*(ATAN(x/SQRT(df)) + Sum_Terms(df, c, csq)*s));
        // Large df asymptoptic approximation definitions
        REAL8 DCONST := 0.3989422804;
        REAL8 B11 := 0.25;
        REAL8 B21 := 0.01041666666667;
        REAL8 B22 := 3.0;
        REAL8 B23 := -7.0;
        REAL8 B24 := -5.0;
        REAL8 B25 := -3.0;
        REAL8 B31 := 0.00260416666667;
        REAL8 B32 := 1.0;
        REAL8 B33 := -11.0;
        REAL8 B34 := 14.0;
        REAL8 B35 := 6.0;
        REAL8 B36 := -3.0;
        REAL8 B37 := -15.0;
        REAL8 d1 := x;
        REAL8 d3 := d1 * x * x;
        REAL8 d5 := d3 * x * x;
        REAL8 d7 := d5 * x * x;
        REAL8 d9 := d7 * x * x;
        REAL8 d11:= d9 * x * x;
        REAL8 df_2 := df * df;
        REAL8 df_3 := df_2 * df;
        REAL8 Term1 := B11*(d3+d1)/df;
        REAL8 Term2 := B21*(B22*d7+B23*d5+B24*d3+B25*d1)/df_2;
        REAL8 Term3 := B31*(B32*d11+B33*d9+B34*d7+B35*d5+B36*d3+B37*d1)/df_3;
        REAL8 Norm_CDF := Normal_CDF(x);
        T_CDF := MAP(df &amp;lt;= 0                             =&amp;gt; 0.0,
        df BETWEEN 3 AND 9     AND z&amp;lt;= -3000 =&amp;gt; 0.0,
        df BETWEEN 3 AND 9     AND z&amp;gt;=  3000 =&amp;gt; 1.0,
        df BETWEEN 10 AND 1000 AND z&amp;lt;= -150  =&amp;gt; 0.0,
        df BETWEEN 10 AND 1000 AND z&amp;gt;=  150  =&amp;gt; 1.0,
        df BETWEEN 1 AND 1000                =&amp;gt; 0.5+sum_terms/2.0,
        Norm_CDF-(EXP(-x*x*0.5))*(Term1+Term2+Term3)*DCONST);
        RETURN T_CDF;
        END;

        // Inverse T helper functions
        REAL8 df3_helper(REAL8 trm, REAL8 init_z) := BEGINC++
        #option pure;
        #include &amp;lt;math.h&amp;gt;
        const double root_3 = sqrt(3);
        double c = cos(init_z);
        double s = sin(init_z);
        double z = init_z;
        for (int i=0; i&amp;lt;15; i++) {
        z = z-(z+s*c-trm)/(2.0*c*c);
        c = cos(z);
        s = sin(z);
        }
        return root_3*s/c;
        ENDC++;
        REAL8 df4_helper(REAL8 trm, REAL8 init_z) := BEGINC++
        #option pure;
        #include &amp;lt;math.h&amp;gt;
        double c = cos(init_z);
        double s = sin(init_z);
        double z = init_z;
        for (int i=0; i&amp;lt;15; i++) {
        z = z-((1.0+0.5*c*c)*s-trm)/(1.5*c*c*c);
        c = cos(z);
        s = sin(z);
        }
        return sqrt(4)*s/c;
        ENDC++;
        REAL8 df5_helper(REAL8 trm, REAL8 init_z) := BEGINC++
        #option pure;
        #include &amp;lt;math.h&amp;gt;
        double c = cos(init_z);
        double s = sin(init_z);
        double z = init_z;
        for (int i=0; i&amp;lt;15; i++) {
        z = z-(z+(c+(2.0/3.0)*c*c*c)*s-trm)/((8.0/3.0)*c*c*c*c);
        c = cos(z);
        s = sin(z);
        }
        return sqrt(5)*s/c;
        ENDC++;
        REAL8 df6_helper(REAL8 trm, REAL8 init_z) := BEGINC++
        #option pure;
        #include &amp;lt;math.h&amp;gt;
        double c = cos(init_z);
        double s = sin(init_z);
        double z = init_z;
        for (int i=0; i&amp;lt;15; i++) {
        z = z-((1.0+0.5*c*c+0.375*c*c*c*c)*s-trm)/((15.0/8.0)*c*c*c*c*c);
        c = cos(z);
        s = sin(z);
        }
        return sqrt(6)*s/c;
        ENDC++;
        REAL8 dk_helper(REAL8 x, INTEGER4 df, REAL8 mf) := BEGINC++
        #option pure;
        #include&amp;lt;math.h&amp;gt;
        const double last_position = 12; // lowest prob &amp;lt; 0.000001
        const double step = last_position/100000;
        double position = 0;
        double cdf = 0.5;
        double target = (x&amp;lt;0.5) ? 1.0-x :  x;
        while (cdf &amp;lt; target &amp;amp;&amp;amp; position &amp;lt;=last_position) {
        double this_point = (2*position+step)/2;
        cdf += mf*pow(1+(this_point*this_point/df), -0.5*(df+1))*step;
        position += step;
        }
        if (cdf &amp;gt; target) position-= step/2;
        position = (x&amp;lt;0.5)  ? -position  : position;
        return position;
        ENDC++;
        /**
        * Percentage point function (PPF) for the T distribution.
        * &amp;lt;p&amp;gt;Translated from NIST SEL DATAPAC Fortran TPPF.f source.
        * @param x the probability.
        * @param df degrees of freedom of the distribution.
        * @return the value with that probability.
        */
        EXPORT REAL8 T_PPF(REAL8 x, REAL8 df) := DEFINE FUNCTION
        REAL8 PI := Core_Const.Pi; //3.14159265358979;
        REAL8 ROOT_2 := Core_Const.Root_2; //1.414213562373095;
        REAL8 B21 :=  0.25;
        REAL8 B31 :=  0.01041666666667;
        REAL8 B32 :=  5.0;
        REAL8 B33 :=  16.0;
        REAL8 B34 :=  3.0;
        REAL8 B41 :=  0.00260416666667;
        REAL8 B42 :=  3.0;
        REAL8 B43 :=  19.0;
        REAL8 B44 :=  17.0;
        REAL8 B45 := -15.0;
        REAL8 B51 :=  0.00001085069444;
        REAL8 B52 :=  79.0;
        REAL8 B53 :=  776.0;
        REAL8 B54 :=  1482.0;
        REAL8 B55 := -1920.0;
        REAL8 B56 := -945.0;
        REAL8 Norm_PPF := Normal_PPF(x);
        // df 7 and higher
        d1 := Norm_PPF;
        d2 := d1 * d1;
        d3 := d1 * d2;
        d5 := d3 * d2;
        d7 := d5 * d2;
        d9 := d7 * d2;
        df_2 := df * df;
        df_3 := df_2 * df;
        df_4 := df_3 * df;
        trm1 := d1;
        trm2 := B21*(d3+d1)/df;
        trm3 := B31*(B32*d5+B33*d3+B34*d1)/df_2;
        trm4 := B41*(B42*d7+B43*d5+B44*d3+B45*d1)/df_3;
        trm5 := B51*(B52*d9+B53*d7+B54*d5+B55*d3+B56*d1)/df_4;
        trms := trm1 + trm2 + trm3 + trm4 + trm5;
        // df 3, 4, 5, and 6 cases
        init_z := ATAN(Norm_PPF/SQRT(df));
        // df 7 to 50
        INTEGER4 ndf := (INTEGER4) df;
        BOOLEAN isEven := ndf&amp;amp;1 = 0;
        REAL8 m_factor := Math.DoubleFac(ndf-1)
        /(IF(isEven,2,PI)*SQRT(ndf)*Math.DoubleFac(ndf-2));
        //
        rslt := MAP(df=1    =&amp;gt; -COS(PI*x)/SIN(PI*x),
        df=2    =&amp;gt; ((ROOT_2/2.0)*(2.0*x-1.0))/SQRT(x*(1.0-x)),
        df=3    =&amp;gt; df3_helper((PI*(x-0.5)), init_z),
        df=4    =&amp;gt; df4_helper((2.0*(x-0.5)), init_z),
        df=5    =&amp;gt; df5_helper((PI*(x-0.5)), init_z),
        df=6    =&amp;gt; df6_helper((2.0*(x-0.5)), init_z),
        df BETWEEN 7 AND 50 =&amp;gt; dk_helper(x, ndf, m_factor),
        trms);
        RETURN rslt;
        END;

        // helper functions for Chi Squared
        REAL8 Low_DF_Sum(INTEGER4 df, REAL8 x) := BEGINC++
        #option pure;
        #include &amp;lt;math.h&amp;gt;
        if (x &amp;lt;= 0) return 0;
        if (df &amp;lt;=0) return 0;
        double chi = sqrt(x);
        double term_sum = (df%2==0) ? 1.0  : 0.0;
        double term = (df%2==0) ? 1.0  : 1.0/chi;
        int start = (df%2==0) ? 2  : 1;
        int stop = (df%2==0) ? (df-2)  : (df-1);
        for (int i=start; i&amp;lt;=stop; i+=2) {
        term *= x/((double)i);
        term_sum += term;
        }
        return term_sum;
        ENDC++;
        /**
        * The Cumulative Distribution Function (CDF) for the Chi Square
        * distribution for the specified degrees of freedom.
        * &amp;lt;p&amp;gt;Translated from the NIST SEL DATAPAC Fortran subroutine CHSCDF.
        * @param x the value at which to compute.
        * @param df the degrees of freedom of the distribution.
        * @return the cumulative probability.
        **/
        EXPORT REAL8 Chi2_CDF(REAL8 x, REAL8 df) := DEFINE FUNCTION
        INTEGER4 DF_Cut := 1000;
        REAL8 PI := Core_Const.Pi; //3.14159265358979;
        INTEGER4 ndf := (INTEGER4) df;
        BOOLEAN isEven := ndf%2 = 0;
        REAL8 sd := SQRT(2*df);
        REAL8 z := (x-df)/sd;
        // definitions for cases above the cut line for degrees of freedom
        REAL8 DPWR := 0.33333333333333;
        REAL8 dfact := 4.5 * df;
        REAL8 adj_point_gt_x := (POWER(x/df,DPWR)-1.0+1.0/dfact)*SQRT(dfact);
        REAL8 high_df_gt_x := Normal_CDF(adj_point_gt_x);
        REAL8 dw := SQRT(x - df-df*LN(x/df));
        REAL8 root_rdf1 := SQRT(2.0/df);
        REAL8 root_rdf2 := root_rdf1 * root_rdf1;
        REAL8 root_rdf3 := root_rdf2 * root_rdf1;
        REAL8 root_rdf4 := root_rdf3 * root_rdf1;
        REAL8 d1 := dw;
        REAL8 d2 := d1 * dw;
        REAL8 d3 := d2 * dw;
        REAL8 B11 :=  0.33333333333333;
        REAL8 B21 := -0.02777777777778;
        REAL8 B31 := -0.00061728395061;
        REAL8 B32 := -13.0;
        REAL8 B41 := 0.00018004115226;
        REAL8 B42 := 6.0;
        REAL8 B43 := 17.0;
        REAL8 trm0 := dw;
        REAL8 trm1 := B11*root_rdf1;
        REAL8 trm2 := B21*d1*root_rdf2;
        REAL8 trm3 := B31*(d2+B32)*root_rdf3;
        REAL8 trm4 := B41*(B42*d3+B43*d1)*root_rdf4;
        REAL8 high_df_le_x := Normal_CDF(trm0+trm1+trm2+trm3+trm4);
        // definitions for cases below the cut line for degrees of freedom
        REAL8 chi := SQRT(x);
        REAL8 low_even := Low_DF_Sum(ndf, x)*EXP(-x/2.0);
        REAL8 low_odd := (1.0-Normal_CDF(chi))*2.0 + (SQRT(2.0/PI)*low_even);
        // determine the result based upon the case
        rslt := MAP(x &amp;lt;= 0        =&amp;gt; 0.0,
        df&amp;lt;10 AND z &amp;lt; -200    =&amp;gt; 0.0,
        df&amp;gt;=10 AND z &amp;lt; -100   =&amp;gt; 0.0,
        df&amp;lt;10 AND z &amp;gt; 200     =&amp;gt; 1.0,
        df&amp;gt;=10 AND z &amp;gt; 100    =&amp;gt; 1.0,
        df &amp;lt; DF_cut AND isEven=&amp;gt; 1.0 - low_even,
        df &amp;lt; df_Cut           =&amp;gt; 1.0 - low_odd,
        df &amp;gt;=df_cut AND x&amp;lt;=df =&amp;gt; high_df_gt_x,
        high_df_le_x);
        //cdf := Math.lowerGamma(df/2, x/2) / Math.gamma(df/2);
        RETURN rslt;
        END;

        // helpers for Chi squared PPF
        REAL8 df_lt_crit(REAL8 x, REAL8 df) := BEGINC++
        #option pure;
        #include &amp;lt;math.h&amp;gt;
        const int max_iter = 30000;
        const int max_bisect = 1000;
        const double half_df = df / 2.0;
        const double min_delta = 0.0000000001;
        double G = tgamma(half_df);
        // now ready to iterate to find percentage point value
        int iter = 0;
        double curr_point = 0.0;
        double step = pow(x*half_df*G, 2.0/df);
        double min_pos = 0;
        double max_pos = 0;
        // determine upper and lower limits
        while (iter&amp;lt;max_iter &amp;amp;&amp;amp; curr_point &amp;lt; x) {
        min_pos = max_pos;
        max_pos += step;
        double term_sum = 2.0/df;
        double term = 2.0/df;
        double cut1 = max_pos - half_df;
        double cut2 = max_pos*10000000000.0;
        for (long j=1; j&amp;lt;10000 &amp;amp;&amp;amp; ((double)j)&amp;lt;cut1+(cut2*term/term_sum); j++) {
        term = max_pos*term/(half_df+((double)j));
        term_sum += term;
        }
        curr_point = pow(max_pos, half_df) * exp(-max_pos) * term_sum / G;
        iter++;
        }
        // search by bisection
        double target_pos = (min_pos+max_pos) / 2.0;
        curr_point = pow(target_pos, half_df)*exp(-target_pos)*(2.0/half_df)/G;
        double delta = 2*min_delta;
        iter = 0;
        while (iter&amp;lt;max_bisect &amp;amp;&amp;amp; delta&amp;gt;min_delta &amp;amp;&amp;amp; curr_point!=x) {
        double term_sum = 2.0/df;
        double term = 2.0/df;
        double cut1 = target_pos - half_df;
        double cut2 = target_pos*10000000000.0;
        for (int j=1; j&amp;lt;10000.0 &amp;amp;&amp;amp; ((double)j)&amp;lt;(cut1+(cut2*term/term_sum)); j++) {
        term = target_pos*term/(half_df+((double)j));
        term_sum += term;
        }
        curr_point = pow(target_pos, half_df) * exp(-target_pos) * term_sum / G;
        if (curr_point==x) return 2.0 * target_pos;
        if (curr_point &amp;lt; x) min_pos = target_pos;
        else max_pos = target_pos;
        iter++;
        target_pos = (max_pos + min_pos) / 2.0;
        delta = (target_pos&amp;gt;min_pos)  ? target_pos-min_pos  : min_pos-target_pos;
        }
        return 2.0 * target_pos;
        ENDC++;
        /**
        * Probability Point Function (PPF) for the Chi Squared distribution.
        * &amp;lt;p&amp;gt;Translated from the NIST SEL DATAPAC Fortran subroutine CHSPPF.
        * @param x the probability value.
        * @param df the degrees of freedom of the distribution.
        * @return the value with that probability.
        */
        EXPORT REAL8 Chi2_PPF(REAL8 x, REAL8 df) := FUNCTION
        critical := 100;
        x0 := MAP(x&amp;lt;=0.0 =&amp;gt; 0.0001, x&amp;gt;=1.0 =&amp;gt; 0.9999, x);
        REAL8 k := 2.0/9.0;
        xq := Normal_PPF(x0);
        wrk := 1.0 -k/df + xq*SQRT(k/df);
        df_ge_crit := df * wrk * wrk * wrk;
        rslt := IF(df&amp;lt;critical, df_lt_crit(x, df), df_ge_crit);
        RETURN rslt;
        END;
        END;&amp;#10;
        &lt;/Attribute&gt;
        &lt;Attribute key=&quot;doublefac&quot;
        name=&quot;DoubleFac&quot;
        sourcePath=&quot;/Users/alex/.HPCCSystems/bundles/_versions/ML_Core/V3_2_2/ML_Core/Math/DoubleFac.ecl&quot;
        ts=&quot;1621960335000000&quot;&gt;
        /**
        * Compute the double factorial.
        * The double factorial is defined for odd n as the product of
        * all the odd numbers up to and including that number.
        * &amp;lt;p&amp;gt;For even numbers it is the product
        * of the even numbers up to and including that number.
        * &amp;lt;p&amp;gt;Thus DoubleFac(8) = 8*6*4*2.
        * &amp;lt;p&amp;gt;IF i &amp;lt; 2, the value 1 is returned.
        * @param i the input value.
        * @return the numeric result.
        **/
        EXPORT REAL8 DoubleFac(INTEGER2 i) := BEGINC++
        #option pure
        if ( i &amp;lt; 2 )
        return 1.0;
        double accum = (double)i;
        for ( int j = i-2; j &amp;gt; 1; j -= 2 )
        accum *= (double)j;
        return accum;
        ENDC++;&amp;#10;
        &lt;/Attribute&gt;
        &lt;/Module&gt;
        &lt;Module key=&quot;std&quot; name=&quot;std&quot;/&gt;
        &lt;Module key=&quot;std.system&quot; name=&quot;std.system&quot;&gt;
        &lt;Attribute key=&quot;thorlib&quot;
        name=&quot;Thorlib&quot;
        sourcePath=&quot;/opt/HPCCSystems/8.0.14/clienttools/share/ecllibrary/std/system/Thorlib.ecl&quot;
        ts=&quot;1621443946000000&quot;&gt;
        -----BEGIN PGP SIGNED MESSAGE-----
        Hash: SHA1

        /*##############################################################################
        ## HPCC SYSTEMS software Copyright (C) 2012 HPCC Systems®.  All rights reserved.
        ############################################################################## */

        /*
        * Internal functions for accessing system information relating to execution on the thor engine.
        *
        * This module is currently treated as internal, and subject to change without notice.
        */

        externals :=
        SERVICE
        unsigned integer4 node() : ctxmethod, entrypoint=&amp;apos;getNodeNum&amp;apos;;
        unsigned integer4 nodes() : ctxmethod, entrypoint=&amp;apos;getNodes&amp;apos;;
        varstring l2p(const varstring name, boolean create=false) : ctxmethod, entrypoint=&amp;apos;getFilePart&amp;apos;;
        unsigned integer getFileOffset(const varstring lfname) : ctxmethod, entrypoint=&amp;apos;getFileOffset&amp;apos;;
        varstring daliServer() : once, ctxmethod, entrypoint=&amp;apos;getDaliServers&amp;apos;;
        varstring cluster() : once, ctxmethod, entrypoint=&amp;apos;getClusterName&amp;apos;;
        varstring getExpandLogicalName(const varstring name) : pure, ctxmethod, entrypoint=&amp;apos;getExpandLogicalName&amp;apos;;
        varstring group() : once, ctxmethod, entrypoint=&amp;apos;getGroupName&amp;apos;;
        varstring platform() : pure ,ctxmethod, entrypoint=&amp;apos;getPlatform&amp;apos;;
        END;

        RETURN MODULE

        /*
        * Returns the index of the slave node this piece of code is executing on.  Zero based.
        */

        export node() := externals.node();

        /*
        * Converts a logical filename to a physical filename.
        *
        * @param name          The logical filename to be converted.
        * @param create        True if creating a new file, false if reading an existing file.
        */

        export logicalToPhysical(const varstring name, boolean create=false) := externals.l2p(name, create);

        /*
        * How many nodes in the cluster that this code will be executed on.
        */

        export nodes() := CLUSTERSIZE;

        /*
        * Returns the dali server this thor is connected to.
        */

        export daliServer() := externals.daliServer();

        /*
        * Returns which thor group the job is currently executing on.
        */

        export group() := externals.group();

        /*
        * Converts a logical filename to a physical filename.
        */

        export getExpandLogicalName(const varstring name) := externals.getExpandLogicalName(name);

        /*
        * Returns the name of the cluster the query is currently executing on.
        */

        export cluster() := externals.cluster();

        /*
        * Returns the platform the query is currently executing on.
        */

        export platform() := externals.platform();

        /*
        * The following are either unused, or should be replaced with a different syntax.

        export getenv(const varstring name, const varstring defaultValue) := externals.getenv(name, defaultValue);
        - - use getenv() built in command instead.
        export getFileOffset(const varstring lfname) := externals.getFileOffset(lfname);

        */

        END;
        -----BEGIN PGP SIGNATURE-----
        Version: GnuPG v1

        iQEcBAEBAgAGBQJgpUVqAAoJEG37B3CNqkF96soH/3UQSOP7D4Ja5pZHdiV+z3ht
        /8XCEQrn4BIgkUSQYRdIDAqDmxQrgM5R23SLcQliUR7aywcDV0/Tvm3CfQ7tfMLV
        j9+BCbD9M3CHrJeFO/2ZRrQOhMSZCn7CLM+NcG30aPVyXFq2Lcq1mIZZbTER4Nbo
        wU/4vO/iEAxsQQM2Tmpj0xlipUWSkkADr9jd+hrBZ1sq+qO+9/cbau2CEA33DCka
        MaH5PDduCqj4otFLDTuHwbutto0gm/CizUmsMqQMF1aSUZYDZczI9jINo1n8xKAh
        XlSnQ5iIvNgSlUHcsumMej767eb7s0xjCwZ7jtHnkN2XnpT1gbQFCxPzPuW4/+0=
        =fjzT
        -----END PGP SIGNATURE-----&amp;#10;
        &lt;/Attribute&gt;
        &lt;/Module&gt;
        &lt;Option name=&quot;eclcc_compiler_version&quot; value=&quot;8.0.14&quot;/&gt;
        &lt;/Archive&gt;&#10;</Text>
</Query>
<Results>
    <Result isScalar="0"
            name="Y_train"
            recordSizeEntry="mf3"
            rowLimit="-1"
            sequence="1"
            status="undefined">
        <SchemaRaw xsi:type="SOAP-ENC:base64">
            d2kAAQIAaWQAAQgAbnVtYmVyAAEEAHZhbHVlAAEEAQAYbQAAAHJlY29yZF9fMCA6PSBSRUNP
            UkQKICB1bnNpZ25lZDIgd2k7CiAgdW5zaWduZWQ4IGlkOwogIHVuc2lnbmVkNCBudW1iZXI7
            CiBFTkQ7CnsocmVjb3JkX18wKSBpbnRlZ2VyNCB2YWx1ZSB9Owo=   </SchemaRaw>
    </Result>
    <Result isScalar="0"
            name="TrainingData"
            recordSizeEntry="mf1"
            rowLimit="-1"
            sequence="0"
            status="undefined">
        <SchemaRaw xsi:type="SOAP-ENC:base64">
            aWQAAQgAeDEAAgh4MgABCAB4MwABCAB5AAEIAAAYWAAAAFJFQ09SRAogIHVuc2lnbmVkOCBp
            ZDsKICByZWFsOCB4MTsKICB1bnNpZ25lZDggeDI7CiAgdW5zaWduZWQ4IHgzOwogIHVuc2ln
            bmVkOCB5OwogRU5EOwo=   </SchemaRaw>
    </Result>
    <Result isScalar="0"
            name="Model"
            recordSizeEntry="mf21"
            rowLimit="-1"
            sequence="2"
            status="undefined">
        <SchemaRaw xsi:type="SOAP-ENC:base64">
            d2kAAQIAdmFsdWUAAghpbmRleGVzABUBBAAAGDkAAAB7IHVuc2lnbmVkMiB3aSwgcmVhbDgg
            dmFsdWUsIHNldCBvZiB1bnNpZ25lZDQgaW5kZXhlcyB9Owo=   </SchemaRaw>
    </Result>
    <Result isScalar="0"
            name="Tree"
            recordSizeEntry="mfK2"
            rowLimit="-1"
            sequence="4"
            status="undefined">
        <SchemaRaw xsi:type="SOAP-ENC:base64">
            d2kAAQIAbGV2ZWwAAQIAdHJlZWlkAAEEAG5vZGVpZAABCABwYXJlbnRpZAABCABpc2xlZnQA
            AGlkAAEIAG51bWJlcgABBAB2YWx1ZQACCGRlcGVuZAACCHN1cHBvcnQAAQgAaXNvcmRpbmFs
            AAAAGO0AAABSRUNPUkQKICB1bnNpZ25lZDIgd2k7CiAgdW5zaWduZWQyIGxldmVsOwogIHVu
            c2lnbmVkNCB0cmVlaWQ7CiAgdW5zaWduZWQ4IG5vZGVpZDsKICB1bnNpZ25lZDggcGFyZW50
            aWQ7CiAgYm9vbGVhbiBpc2xlZnQ7CiAgdW5zaWduZWQ4IGlkOwogIHVuc2lnbmVkNCBudW1i
            ZXI7CiAgcmVhbDggdmFsdWU7CiAgcmVhbDggZGVwZW5kOwogIHVuc2lnbmVkOCBzdXBwb3J0
            OwogIGJvb2xlYW4gaXNvcmRpbmFsOwogRU5EOwo=   </SchemaRaw>
    </Result>
    <Result isScalar="0"
            name="ModelStats"
            recordSizeEntry="mf03"
            rowLimit="-1"
            sequence="3"
            status="undefined">
        <SchemaRaw xsi:type="SOAP-ENC:base64">
            d2kAAQIAdHJlZWNvdW50AAEIAG1pbnRyZWVkZXB0aAABCABtYXh0cmVlZGVwdGgAAQgAYXZn
            dHJlZWRlcHRoAAIIbWludHJlZW5vZGVzAAEIAG1heHRyZWVub2RlcwABCABhdmd0cmVlbm9k
            ZXMAAgh0b3RhbG5vZGVzAAEIAG1pbnN1cHBvcnQAAQgAbWF4c3VwcG9ydAABCABhdmdzdXBw
            b3J0AAIIYXZnc3VwcG9ydHBlcmxlYWYAAghtYXhzdXBwb3J0cGVybGVhZgABCABhdmdsZWFm
            ZGVwdGgAAghtaW5sZWFmZGVwdGgAAQgAYmZsZXZlbAABCAAAGKMBAABSRUNPUkQKICB1bnNp
            Z25lZDIgd2k7CiAgdW5zaWduZWQ4IHRyZWVjb3VudDsKICB1bnNpZ25lZDggbWludHJlZWRl
            cHRoOwogIHVuc2lnbmVkOCBtYXh0cmVlZGVwdGg7CiAgcmVhbDggYXZndHJlZWRlcHRoOwog
            IHVuc2lnbmVkOCBtaW50cmVlbm9kZXM7CiAgdW5zaWduZWQ4IG1heHRyZWVub2RlczsKICBy
            ZWFsOCBhdmd0cmVlbm9kZXM7CiAgdW5zaWduZWQ4IHRvdGFsbm9kZXM7CiAgdW5zaWduZWQ4
            IG1pbnN1cHBvcnQ7CiAgdW5zaWduZWQ4IG1heHN1cHBvcnQ7CiAgcmVhbDggYXZnc3VwcG9y
            dDsKICByZWFsOCBhdmdzdXBwb3J0cGVybGVhZjsKICB1bnNpZ25lZDggbWF4c3VwcG9ydHBl
            cmxlYWY7CiAgcmVhbDggYXZnbGVhZmRlcHRoOwogIHVuc2lnbmVkOCBtaW5sZWFmZGVwdGg7
            CiAgdW5zaWduZWQ4IGJmbGV2ZWw7CiBFTkQ7Cg==   </SchemaRaw>
    </Result>
</Results>
<State>blocked</State>
<Statistics>
    <Statistic c="esp"
               count="1"
               creator="myesp@10.0.0.209"
               kind="WhenCreated"
               s="global"
               scope=""
               ts="1624947468993793"
               unit="ts"
               value="1624947468993784"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="WhenCompiled"
               s="global"
               scope=""
               ts="1624947469009679"
               unit="ts"
               value="1624947469009438"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="WhenStarted"
               s="compile"
               scope="compile"
               ts="1624947472017608"
               unit="ts"
               value="1624947469063838"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="SizePeakMemory"
               s="compile"
               scope="compile"
               ts="1624947472017626"
               unit="sz"
               value="54095872"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeElapsed"
               s="compile"
               scope="compile"
               ts="1624947472017641"
               unit="ns"
               value="2953416313"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="NumSysContextSwitches"
               s="compile"
               scope="compile"
               ts="1624947472017659"
               unit="cnt"
               value="100825"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeOsUser"
               s="compile"
               scope="compile"
               ts="1624947472017675"
               unit="ns"
               value="6020000000"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeOsSystem"
               s="compile"
               scope="compile"
               ts="1624947472017692"
               unit="ns"
               value="440000000"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeOsTotal"
               s="compile"
               scope="compile"
               ts="1624947472017713"
               unit="ns"
               value="23090000000"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeUser"
               s="compile"
               scope="compile"
               ts="1624947472017733"
               unit="ns"
               value="3190000000"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeSystem"
               s="compile"
               scope="compile"
               ts="1624947472017753"
               unit="ns"
               value="260000000"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="WhenStarted"
               s="compile"
               scope="compile:compile c++"
               ts="1624947472017776"
               unit="ts"
               value="1624947469410530"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeElapsed"
               s="compile"
               scope="compile:compile c++"
               ts="1624947472017796"
               unit="ns"
               value="2606327771"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="WhenStarted"
               s="compile"
               scope="compile:generate"
               ts="1624947472017816"
               unit="ts"
               value="1624947469231739"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeElapsed"
               s="compile"
               scope="compile:generate"
               ts="1624947472017837"
               unit="ns"
               value="160188057"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="WhenStarted"
               s="compile"
               scope="compile:parse"
               ts="1624947472017858"
               unit="ts"
               value="1624947469063868"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeElapsed"
               s="compile"
               scope="compile:parse"
               ts="1624947472017883"
               unit="ns"
               value="148374287"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="WhenStarted"
               s="compile"
               scope="compile:write c++"
               ts="1624947472017925"
               unit="ts"
               value="1624947469388072"/>
    <Statistic c="eclcc"
               count="1"
               creator="myeclccserver@10.0.0.209"
               kind="TimeElapsed"
               s="compile"
               scope="compile:write c++"
               ts="1624947472017960"
               unit="ns"
               value="3812305"/>
    <Statistic c="hthor"
               count="1"
               creator="myeclagent@10.0.0.209"
               kind="WhenStarted"
               s="global"
               scope=""
               ts="1624947472474470"
               unit="ts"
               value="1624947472474236"/>
</Statistics>
<Tracing>
    <EclAgentBuild>community_8.0.2-1</EclAgentBuild>
</Tracing>
<Workflow>
    <Item mode="normal"
          state="reqd"
          type="normal"
          wfid="1">
        <Schedule/>
    </Item>
</Workflow>
</W20210629-061748>